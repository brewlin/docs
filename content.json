{"pages":[{"title":"About","date":"2016-10-24T02:24:00.000Z","path":"about/index.html","text":"关于我自己90后码农军团冲锋兵一枚，不断在与脱发斗争中。向往码出一个未来殿堂。 关于编程不应该局限于软件工程师的思维，不应该只写代码，去学习新技术，沟通、管理、理财，你都应该去学习、去了解、去跟上世界成长的脚步。 会c.c++，熟悉go、熟悉php、熟悉java 业余爱好旅行、运动、篮球、爬山、音乐 -&gt; 是的，就是正常人干的事情 最后人的这一辈子没法做太多的事情，所以每一件都要做的精彩绝伦"},{"title":"Categories","date":"2019-10-26T15:40:12.962Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2019-10-26T15:40:12.974Z","path":"tags/index.html","text":""}],"posts":[{"title":"arp协议","date":"2019-10-24T13:28:59.000Z","path":"wiki/net-protocol/4.网络层/arp协议/","text":"ARP 协议基于arp协议，获取对应的物理mac地址 上层tcp/ip协议报文只包含目标服务器的ip地址，而下层链路层以太网协议需要知道目标服务器的mac地址，则arp的协议是指当前主机发送ARP查询（广播）查询该mac地址，如果目标地址不是在同一个局域网，则该mac地址则是局域网外的路由器mac地址，该所有帧都将发往该路由器地址 总之以太网协议中得到的上层数据中只有IP地址，需要使用arp协议去获得mac地址，arp协议会在链路层进行广播，只有目标地址会回应123ARP Paclket Format arp协议数据包格式6字节(以太网目的地址) + 6字节（以太网源地址） + 2 字节（帧类型） + 28字节（arp请求回应包） 28字节包格式 2字节硬件类型：1 =&gt; 以太网地址 2字节协议类型：0x800 表示ipv4协议 1字节地址长度：单位长度，一般为6 表示以太网地址的长度6字节 1字节协议地址长度：一般为4，ipv4地址长度 2字节操作码：1 =&gt; arp请求 2 =&gt; arp应答 3 =&gt; rarp请求 4 =&gt; rarp应答 6字节原mac地址：源mac地址 4字节源协议地址：源ip地址 如192.168.0.1 6字节目标mac地址：mac地址 不用担心每次请求都会触发arp查询广播，机器是有arp高速缓存的 arp -a @typetype:0x8060 表示arp协议","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"udp","slug":"udp","permalink":"http://blog.huido.site/tags/udp/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"4.网络层","slug":"net-protocol/4-网络层","permalink":"http://blog.huido.site/categories/net-protocol/4-网络层/"}]},{"title":"ip协议","date":"2019-10-24T13:28:59.000Z","path":"wiki/net-protocol/4.网络层/协议_ip/","text":"IP 报文协议首部协议格式 123456789101112131415161718190 1 2 3 40 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|Version| LHL | Type of Service | Total Length |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Identification(fragment Id) |Flags| Fragment Offset || 16 bits |R|D|M| 13 bits |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Time-To-Live | Protocol | Header Checksum || ttl(8 bits) | 8 bits | 16 bits |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source IP Address (32 bits) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Destination Ip Address (32 bits) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Options (*** bits) | Padding |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| transport data... |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 版本（Version）: 1版本字段占 4bit，通信双方使用的版本必须一致。对于 IPv4，字段的值是 4。 首部长度（Internet Header Length， IHL）: 123占 4bit，首部长度说明首部有多少 32 位字（4字节）。由于 IPv4首部可能包含数目不定的选项，这个字段也用来确定数据的偏移量。这个字段的最小值是 5（二进制 0101），相当于 5*4=20 字节（RFC 791），最大十进制值是 15。 区分服务（Differentiated Services，DS): 12占 8bit，最初被定义为服务类型字段，实际上并未使用，但 1998 年被 IETF 重定义为区分服务 RFC 2474。只有在使用区分服务时，这个字段才起作用，在一般的情况 下都不使用这个字段。例如需要实时数据流的技术会应用这个字段，一个例子是 VoIP。 显式拥塞通告（ Explicit Congestion Notification，ECN）:12在 RFC 3168 中定义，允许在不丢弃报文的同时通知对方网络拥塞的发生。ECN 是一种可选的功能，仅当两端都支持并希望使用，且底层网络支持时才被使用。 全长（Total Length）:12345这个 16 位字段定义了报文总长，包含首部和数据，单位为字节。这个字段的最小值是 20（20 字节首部+0 字节数据），最大值是 216-1=65,535。IP 规定所有主机都必须支持最小 576 字节的报文，这是假定上层数据长度 512 字节，加上最长 IP 首部 60 字节，加上 4 字节富裕量，得出 576 字节，但大多数现代主机支持更大的报文。当下层的数据链路协议的最大传输单元（MTU）字段的值小于 IP 报文长度时间，报文就必须被分片，详细见下个标题。 标识符（Identification):12占 16 位，这个字段主要被用来唯一地标识一个报文的所有分片，因为分片不一定按序到达，所以在重组时需要知道分片所属的报文。每产生一个数据报，计数器加 1，并赋值给此字段。一些实验性的工作建议将此字段用于其它目的，例如增加报文跟踪信息以协助探测伪造的源地址。 标志 （Flags）:1234567这个 3 位字段用于控制和识别分片，它们是：位 0：保留，必须为 0； 位 1：禁止分片（Don’t Fragment，DF），当 DF=0 时才允许分片； 位 2：更多分片（More Fragment，MF），MF=1 代表后面还有分片，MF=0 代表已经是最后一个分片。 如果 DF 标志被设置为 1，但路由要求必须分片报文，此报文会被丢弃。这个标志可被用于发往没有能力组装分片的主机。当一个报文被分片，除了最后一片外的所有分片都设置 MF 为 1。最后一个片段具有非零片段偏移字段，将其与未分片数据包区分开，未分片的偏移字段为 0。 分片偏移 （Fragment Offset）:1这个 13 位字段指明了每个分片相对于原始报文开头的偏移量，以 8 字节作单位。 存活时间（Time To Live，TTL）:1234这个 8 位字段避免报文在互联网中永远存在（例如陷入路由环路）。存活时间以秒为单位，但小于一秒的时间均向上取整到一秒。在现实中，这实际上成了一个跳数计数器：报文经过的每个路由器都将此字段减 1，当此字段等于 0 时，报文不再向下一跳传送并被丢弃，最大值是 255。常规地，一份 ICMP 报文被发回报文发送端说明其发送的报文已被丢弃。这也是 traceroute 的核心原理。 协议 （Protocol）:1占 8bit，这个字段定义了该报文数据区使用的协议。IANA 维护着一份协议列表（最初由 RFC 790 定义），详细参见 IP 协议号列表。 首部检验和 （Header Checksum）:1234这个 16 位检验和字段只对首部查错，不包括数据部分。在每一跳，路由器都要重新计算出的首部检验和并与此字段进行比对，如果不一致，此报文将会被丢弃。重新计算的必要性是因为每一跳的一些首部字段（如 TTL、Flag、Offset 等）都有可能发生变化，不检查数据部分是为了减少工作量。数据区的错误留待上层协议处理——用户数据报协议（UDP）和传输控制协议（TCP）都有检验和字段。此处的检验计算方法不使用 CRC。 源地址 123一个 IPv4 地址由四个字节共 32 位构成，此字段的值是将每个字节转为二进制并拼在一起所得到的 32 位值。例如，10.9.8.7 是 00001010000010010000100000000111。但请注意，因为 NAT 的存在，这个地址并不总是报文的真实发送端，因此发往此地址的报文会被送往 NAT 设备，并由它被翻译为真实的地址。 目的地址1与源地址格式相同，但指出报文的接收端。 选项:123附加的首部字段可能跟在目的地址之后，但这并不被经常使用，从 1 到 40 个字节不等。请注意首部长度字段必须包括足够的 32 位字来放下所有的选项（包括任何必须的填充以使首部长度能够被 32 位整除）。当选项列表的结尾不是首部的结尾时，EOL（选项列表结束，0x00）选项被插入列表末尾。下表列出了可能。 字段 长度 描述 备份 1 当此选项需要被备份到所有分片中时，设为 1。 类 2 常规的选项类别，0 为“控制”，2 为“查错和措施”，1 和 3 保留。 数字 5 指明一个选项。 长度 8 指明整个选项的长度，对于简单的选项此字段可能不存在。 数据 可变 选项相关数据，对于简单的选项此字段可能不存在。 注：如果首部长度大于 5，那么选项字段必然存在并必须被考虑。注：备份、类和数字经常被一并称呼为“类型”。 数据 数据字段不是首部的一部分，因此并不被包含在首部检验和中。数据的格式在协议首部字段中被指明，并可以是任意的传输层协议。 一些常见协议的协议字段值被列在下面 协议字段值 协议名 缩写 1 互联网控制消息协议 ICMP 2 互联网组管理协议 IGMP 6 传输控制协议 TCP 17 用户数据报协议 UDP 41 IPv6 封装 ENCAP 89 开放式最短路径优先 OSPF 132 流控制传输协议 SCTP 总结IP 层最重要的目的是让两个主机之间通信，无论他们相隔多远。IP 协议理论上允许的最大 IP 数据报为 65535 字节（16 位来表示包总长）。但是因为协议栈网络层下面的数据链路层一般允许的帧长远远小于这个值，例如以太网的 MTU 通常在 1500 字节左右。所以较大的 IP 数据包会被分片传递给数据链路层发送，分片的 IP 数据报可能会以不同的路径传输到接收主机，接收主机通过一系列的重组，将其还原为一个完整的 IP 数据报，再提交给上层协议处理。IP 分片会带来一定的问题，分片和重组会消耗发送方、接收方一定的 CPU 等资源，如果存在大量的分片报文的话，可能会造成较为严重的资源消耗；分片丢包导致的重传问题；分片攻击；","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"udp","slug":"udp","permalink":"http://blog.huido.site/tags/udp/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"4.网络层","slug":"net-protocol/4-网络层","permalink":"http://blog.huido.site/categories/net-protocol/4-网络层/"}]},{"title":"端口机制","date":"2019-10-24T13:28:59.000Z","path":"wiki/net-protocol/4.网络层/协议_端口/","text":"端口端口在tcp协议中的体现端口一般在tcp首部前四个字节中，前2字节表示源端口 后两字节表示目标端口 1.周知端口（Well Known Ports）周知端口是众所周知的端口号，范围从 0 到 1023，其中 80 端口分配给 WWW 服务，21 端口分配给 FTP 服务等。我们在 IE 的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下 WWW 服务的端口是”80”。网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在 地址栏上指定端口号，方法是在地址后面加上冒号”:”，再加上端口号。比如使用”8080”作为 WWW 服务的端口，则需要在地址栏里输入”网址:8080”。但是有些系统协议使用固定的端口号，它是不能被改变的，比如 139 端口专门用于 NetBIOS 与 TCP/IP 之间的通信，不能手动改变。 2.注册端口（Registered Ports）端口 1024 到 49151，分配给用户进程或应用程序。这些进程主要是用户选择安装的一些应用程序，而不是已经分配好了公认端口的常用程序。这些端口在没有被服务器资源占用的时候，可以用用户端动态选用为源端口。 3.动态端口（Dynamic Ports）动态端口的范围是从 49152 到 65535。之所以称为动态端口，是因为它 一般不固定分配某种服务，而是动态分配。比如本地想和远端建立 TCP 连接，如果没有指定本地源端口，系统就会给你自动分配一个未占用的源端口，这个端口值就是动态的，当你断开再次建立连接的时候，很有可能你的源端口和上次得到的端口不一样。 一些常见的端口号及其用途如下： TCP21 端口：FTP 文件传输服务 TCP22 端口：SSH 安全外壳协议 TCP23 端口：TELNET 终端仿真服务 TCP25 端口：SMTP 简单邮件传输服务 UDP53 端口：DNS 域名解析服务 UDP67 端口：DHCP 的服务端端口 UDP68 端口：DHCP 的客户端端口 TCP80 端口：HTTP 超文本传输服务 TCP110 端 口：POP3“邮局协议版本 3”使用的端口 TCP443 端口：HTTPS 加密的超文本传输服务 注意点端口是网络层协议地址+传输层协议号+端口号来区分的，比如： ipv4的tcp 80端口和ipv4的udp 80端口不会冲突。 如果你主机有两个 ip 地址 ip1 和 ip2，那么你同时监听ip1:80和ip2:80不会冲突。 ipv4的tcp 80端口和ipv6的tcp 80端口不会冲突。","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"udp","slug":"udp","permalink":"http://blog.huido.site/tags/udp/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"4.网络层","slug":"net-protocol/4-网络层","permalink":"http://blog.huido.site/categories/net-protocol/4-网络层/"}]},{"title":"icmp协议","date":"2019-10-24T13:28:59.000Z","path":"wiki/net-protocol/4.网络层/协议_icmp/","text":"ICMP 协议ICMP 的全称是 Internet Control Message Protocol 。与 IP 协议一样同属 TCP/IP 模型中的网络层，并且 ICMP 数据包是包裹在 IP 数据包中的。他的作用是报告一些网络传输过程中的错误与做一些同步工作。ICMP 数据包有许多类型。每一个数据包只有前 4 个字节是相同域的，剩余的字段有不同的数据包类型的不同而不同。ICMP 数据包的格式如下 1234567891011https://tools.ietf.org/html/rfc792 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Type | Code | Checksum |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| || 不同的Type和Code有不同的内容 | | |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 从技术角度来说，ICMP 就是一个“错误侦测与回报机制”， 其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性﹐其功能主要有： 侦测远端主机是否存在。 建立及维护路由信息。 重导数据传送路径（ICMP 重定向）。 数据流量控制。ICMP 在沟通之中，主要是透过不同的类别(Type)与代码(Code) 让机器来识别不同的连线状况。 完整类型列表 TYPE CODE Description 0 0 Echo Reply——回显应答（Ping 应答） 3 0 Network Unreachable——网络不可达 3 1 Host Unreachable——主机不可达 3 2 Protocol Unreachable——协议不可达 3 3 Port Unreachable——端口不可达 3 4 Fragmentation needed but no frag. bit set——需要进行分片但设置不分片标志 3 5 Source routing failed——源站选路失败 3 6 Destination network unknown——目的网络未知 3 7 Destination host unknown——目的主机未知 3 8 Source host isolated (obsolete)——源主机被隔离（作废不用） 3 9 Destination network administratively prohibited——目的网络被强制禁止 3 10 Destination host administratively prohibited——目的主机被强制禁止 3 11 Network unreachable for TOS——由于服务类型 TOS，网络不可达 3 12 Host unreachable for TOS——由于服务类型 TOS，主机不可达 3 13 Communication administratively prohibited by filtering——由于过滤，通信被强制禁止 3 14 Host precedence violation——主机越权 3 15 Precedence cutoff in effect——优先中止生效 4 0 Source quench——源端被关闭（基本流控制） 5 0 Redirect for network——对网络重定向 5 1 Redirect for host——对主机重定向 5 2 Redirect for TOS and network——对服务类型和网络重定向 5 3 Redirect for TOS and host——对服务类型和主机重定向 8 0 Echo request——回显请求（Ping 请求） 9 0 Router advertisement——路由器通告 10 0 Route solicitation——路由器请求 11 0 TTL equals 0 during transit——传输期间生存时间为 0 11 1 TTL equals 0 during reassembly——在数据报组装期间生存时间为 0 12 0 IP header bad (catchall error)——坏的 IP 首部（包括各种差错） 12 1 Required options missing——缺少必需的选项 13 0 Timestamp request (obsolete)——时间戳请求（作废不用） 14 Timestamp reply (obsolete)——时间戳应答（作废不用） 15 0 Information request (obsolete)——信息请求（作废不用） 16 0 Information reply (obsolete)——信息应答（作废不用） 17 0 Address mask request——地址掩码请求 18 0 Address mask ICMP 是个非常有用的协议，尤其是当我们要对网路连接状况进行判断的时候。","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"udp","slug":"udp","permalink":"http://blog.huido.site/tags/udp/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"4.网络层","slug":"net-protocol/4-网络层","permalink":"http://blog.huido.site/categories/net-protocol/4-网络层/"}]},{"title":"tcp头部","date":"2019-10-22T13:28:59.000Z","path":"wiki/net-protocol/3.传输层/tcp/1.头部/","text":"传输层 tcp 协议 实现 首部协议格式12345678910111213141516171819 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source Port | Destination Port |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Sequence Number |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Acknowledgment Number |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Data | |U|A|P|R|S|F| || Offset| Reserved |R|C|S|S|Y|I| Window || | |G|K|H|T|N|N| |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Checksum | Urgent Pointer |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Options | Padding |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| data |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 源端口和目的端口各占 2 个字节，分别 tcp 连接的源端口和目的端口。关于端口的概念之前已经介绍过了。 序号占 4 字节，序号范围是[0，2^32 - 1]，共 2^32（即 4294967296）个序号。序号增加到 2^32-1 后，下一个序号就又回到 0。TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号（ISN）必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号是 301，而接待的数据共有 100 字节。这就表明：本报文段的数据的第一个字节的序号是 301，最后一个字节的序号是 400。显然，下一个报文段（如果还有的话）的数据序号应当从 401 开始，即下一个报文段的序号字段值应为 401。 确认号占 4 字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B 正确收到了 A 发送过来的一个报文段，其序号字段值是 501，而数据长度是 200 字节（序号 501~700），这表明 B 正确收到了 A 发送的到序号 700 为止的数据。因此，B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701。注意，现在确认号不是 501，也不是 700，而是 701。总之：若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。TCP 除了第一个 SYN 报文之外，所有 TCP 报文都需要携带 ACK 状态位。 数据偏移占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出 TCP 报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是 4 个字节，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节。 保留占 6 位，保留为今后使用，但目前应置为 0。 控制报文标志紧急URG（URGent）当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收 TCP 的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。当 URG 置为 1 时，发送应用进程就告诉发送方的 TCP 有紧急数据要传送。于是发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。 确认ACK（ACKnowledgment）仅当 ACK=1 时确认号字段才有效，当 ACK=0 时确认号无效。TCP 规定，在连接建立后所有的传送的报文段都必须把 ACK 置为 1。 推送 PSH（PuSH）当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH=1 的报文段，就尽快地交付接收应用进程。复位RST（ReSeT）当 RST=1 时，表名 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST 置为 1 用来拒绝一个非法的报文段或拒绝打开一个连接。 同步SYN（SYNchronization）在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN=1 和 ACK=1，因此 SYN 置为 1 就表示这是一个连接请求或连接接受报文。 终止FIN（FINis，意思是“完”“终”）用来释放一个连接。当 FIN=1 时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。 窗口占 2 字节，窗口值是[0，2^16-1]之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据，作为流量控制的依据，后面会详细介绍。总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。 检验和占 2 字节，检验和字段检验的范围包括首部和数据这两部分。和 UDP 用户数据报一样，在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。伪首部的格式和 UDP 用户数据报的伪首部一样。但应把伪首部第 4 个字段中的 17 改为 6（TCP 的协议号是 6）；把第 5 字段中的 UDP 中的长度改为 TCP 长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用 IPv6，则相应的伪首部也要改变。 紧急指针占 2 字节，紧急指针仅在 URG=1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据) 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为 0 时也可以发送紧急数据。 选项选项长度可变，最长可达 40 字节。当没有使用“选项”时，TCP 的首部长度是 20 字节。TCP 首部总长度由 TCP 头中的“数据偏移”字段决定，前面说了，最长偏移为 60 字节。那么“tcp 选项”的长度最大为 60-20=40 字节。 选项的一般结构体1234 1byte 1byte nbytes+--------+--------+------------------+ | Kind | Length | Info |+--------+--------+------------------+ TCP 最初只规定了一种选项，即最大报文段长度 MSS（Maximum Segment Szie）。后来又增加了几个选项如窗口扩大选项、时间戳选项等，下面说明常用的选项。 kind=0 是选项表结束选项。 kind=1 是空操作（nop）选项没有特殊含义，一般用于将 TCP 选项的总长度填充为 4 字节的整数倍，为啥需要 4 字节整数倍？因为前面讲了数据偏移字段的单位是 4 个字节。 kind=2 是最大报文段长度选项TCP 连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP 模块通常将 MSS 设置为（MTU-40）字节（减掉的这 40 字节包括 20 字节的 TCP 头部和 20 字节的 IP 头部）。这样携带 TCP 报文段的 IP 数据报的长度就不会超过 MTU（假设 TCP 头部和 IP 头部都不包含选项字段，并且这也是一般情况），从而避免本机发生 IP 分片。对以太网而言，MSS 值是 1460（1500-40）字节。 kind=3 是窗口扩大因子选项TCP 连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在 TCP 的头部中，接收通告窗口大小是用 16 位表示的，故最大为 65535 字节，但实际上 TCP 模块允许的接收通告窗口大小远不止这个数（为了提高 TCP 通信的吞吐量）。窗口扩大因子解决了这个问题。假设 TCP 头部中的接收通告窗口大小是 N，窗口扩大因子（移位数）是 M，那么 TCP 报文段的实际接收通告窗口大小是 N 乘 2M，或者说 N 左移 M 位。注意，M 的取值范围是 0～14。 和 MSS 选项一样，窗口扩大因子选项只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该 TCP 报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。关于窗口扩大因子选项的细节，可参考标准文档 RFC 1323。 kind=4 是选择性确认（Selective Acknowledgment，SACK）选项TCP 通信时，如果某个 TCP 报文段丢失，则 TCP 模块会重传最后被确认的 TCP 报文段后续的所有报文段，这样原先已经正确传输的 TCP 报文段也可能重复发送，从而降低了 TCP 性能。SACK 技术正是为改善这种情况而产生的，它使 TCP 模块只重新发送丢失的 TCP 报文段，不用发送所有未被确认的 TCP 报文段。选择性确认选项用在连接初始化时，表示是否支持 SACK 技术。 kind=5 是 SACK 实际工作的选项该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿（edge of block）参数包含一个 4 字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用 8 字节，所以 TCP 头部选项中实际上最多可以包含 4 个这样的不连续数据块（考虑选项类型和长度占用的 2 字节）。 kind=8 是时间戳选项该选项提供了较为准确的计算通信双方之间的回路时间（Round Trip Time，RTT）的方法，从而为 TCP 流量控制提供重要信息。","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"tcp","slug":"tcp","permalink":"http://blog.huido.site/tags/tcp/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"3.传输层","slug":"net-protocol/3-传输层","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/"},{"name":"tcp","slug":"net-protocol/3-传输层/tcp","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/tcp/"}]},{"title":"udp协议","date":"2019-10-22T13:28:59.000Z","path":"wiki/net-protocol/3.传输层/udp/1.协议/","text":"udp协议udp协议 包体 源端口 源端口号 目的端口 目的端口号 长度 UDP 数据报的长度，包含首部，最小为 8 检验和 UDP 数据报的校验和，如果接收到检验和不正确的情况下，直接丢弃该报文。 计算校验和算法UDP 计算校验和的方法和 IP 数据报首部校验和的方法相似。不同的是：IP 数据报校验和只校验 IP 数据报的首部，但 UDP 的校验和是把首部和数据部分一起都检验。 UDP 的校验和需要计算 UDP 首部加数据荷载部分，但也需要加上 UDP 伪首部。这个伪首部指，源地址、目的地址、UDP 数据长度、协议类型（0x11），协议类型就一个字节，但需要补一个字节的 0x0，构成 12 个字节。伪首部+UDP 首部+数据一起计算校验和。 UDP 检验和的计算方法是：按每 16 位求和得出一个 32 位的数；如果这个 32 位的数，高 16 位不为 0，则高 16 位加低 16 位再得到一个 32 位的数；重复第 2 步直到高 16 位为 0，将低 16 位取反，得到校验和。","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"udp","slug":"udp","permalink":"http://blog.huido.site/tags/udp/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"3.传输层","slug":"net-protocol/3-传输层","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/"},{"name":"udp","slug":"net-protocol/3-传输层/udp","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/udp/"}]},{"title":"tcp可靠性机制","date":"2019-10-22T13:28:59.000Z","path":"wiki/net-protocol/3.传输层/tcp/3.可靠性机制/","text":"tcp 可靠性机制可靠性指的是网络层能通信的前提下，保证数据包正确且按序到达对端。 比如发送端发送了“12345678”，那么接收端一定能收到“12345678”，不会乱序“12456783”，也不会少或多数据。 实现 TCP 的可靠传输有以下机制：1.校验和机制（检测和重传受到损伤的报文段） 2.确认应答机制（保存失序到达的报文段直至缺失的报文到期，以及检测和丢弃重复的报文段） 3.超时重传机制（重传丢失的报文段） 1.校验和每个 tcp 段都包含了一个检验和字段，用来检查报文段是否收到损伤。如果某个报文段因检验和无效而被检查出受到损伤，就由终点 TCP 将其丢弃，并被认为是丢失了。TCP 规定每个报文段都必须使用 16 位的检验和。12345678910111213141516// 校验和的计算func Checksum(buf []byte, initial uint16) uint16 &#123; v := uint32(initial) l := len(buf) if l&amp;1 != 0 &#123; l-- v += uint32(buf[l]) &lt;&lt; 8 &#125; for i := 0; i &lt; l; i += 2 &#123; v += (uint32(buf[i]) &lt;&lt; 8) + uint32(buf[i+1]) &#125; return ChecksumCombine(uint16(v), uint16(v&gt;&gt;16))&#125; 2.确认机制控制报文段不携带数据，但需要消耗一个序号，它也需要被确认，而 ACK 报文段永远不需要确认，ACK 报文段不消耗序号，也不需要被确认。在以前，TCP 只使用一种类型的确认，叫积累确认，目前 TCP 实现还实现了选择确认。 累积确认（ACK） 接收方通告它期望接收的下一个字节的序号，并忽略所有失序到达并被保存的报文段。有时这被称为肯定累积确认。在 TCP 首部的 32 位 ACK 字段用于积累确认，而它的值仅在 ACK 标志为 1 时才有效。举个例子来说，这里先不考虑 tcp 的序列号，如果发送方发了数据包 p1，p2，p3，p4；接受方成功收到 p1，p2，p4。那么接收方需要发回一个确认包，序号为 3(3 表示期望下一个收到的包的序号)，那么发送方就知道 p1 到 p2 都发送接收成功，必要时重发 p3。一个确认包确认了累积到某一序号的所有包，而不是对每个序号都发确认包。实际的 tcp 确认的都是序列号，而不是包的序号，但原理是一样的。 累积确认是快速重传的基础，这个后面讲拥塞控制的时候会详细说明。 累积确认是快速重传的基础，这个后面讲拥塞控制的时候会详细说明。 选择确认（SACK） 选择确认 SACK 要报告失序的数据块以及重复的报文段块，是为了更准确的告诉发送方需要重传哪些数据块。SACK 并没有取代 ACK，而是向发送方报告了更多的信息。SACK 是作为 TCP 首部末尾的选项来实现的。首先是否要启动 sack，应该在握手的时候告诉对方自己是否开启了 sack，这个是通过 kind=4 是选择性确认（Selective Acknowledgment，SACK）选项来实现的。实际传送 sack 信息的是 kind=5 的选项，其格式如下：123456789101112131415 +--------+--------+ | Kind=5 | Length | +--------+--------+--------+---------+ | Start of 1st Block | +--------+--------+--------+---------+ | End of 1st Block | +--------+--------+--------+---------+ | | / . . . . . . / | | +--------+--------+--------+---------+ | Start of nth Block | +--------+--------+--------+---------+ | End of nth Block | +--------+--------+--------+---------+ sack 的每个块是由两个参数构成的{ Start, End } Start 不连续块的第一个数据的序列号。End 不连续块的最后一个数据的序列号之后的序列号。 该选项参数告诉对方已经接收到并缓存的不连续的数据块，注意都是已经接收的，发送方可根据此信息检查究竟是哪个块丢失，从而发送相应的数据块。 比如下图：如图所示，tcp 接收方在接收到不连续的 tcp 段，可以看出，序号 1～1000，1501～3000，3501～4500 接收到了，但却少了序号 1001～1500，3001～3500 。 前面说了，sack 报告的是已接收的不连续的块，在这个例子中，sack 块的内容为{Start:1501, End:3001},{Start:3501, End:4501}， 注意：这里的 End 不是接收到数据段最后的序列号，而是最后的序列号加 1。 产生确认的情况 确认机制 当接收方收到了按序到达（序号是所期望的）的报文段，那么接收方就累积发送确认报文段。 当具有所期望的序号的报文段到达，而前一个按序到达的报文段还没有被确认，那么接收方就要立即发送 ACK 报文段。 当序号比期望的序号还大的失序报文段到达时，接收方立即发送 ACK 报文段，并宣布下一个期望的报文段序号。这将导致对丢失报文段的快重传。 当一个丢失的报文段到达时，接收方要发送 ACK 报文段，并宣布下一个所期望的序号。 如果到达一个重复的报文段，接收方丢弃该报文段，但是应当立即发送确认，指出下一个期望的报文段。 收到 fin 报文的时候，立即回复确认。 3.重传机制关于重传的基本概念RTO 即超时重传时间RTT 数据包往返时间平均偏差是指单项测定值与平均值的偏差（取绝对值）之和，除以测定次数。可靠性的核心就是报文段的重传。在一个报文段发送时，它会被保存到一个队列中，直至被确认为止。当重传计时器超时，或者发送方收到该队列中第一个报文段的三个重复的 ACK 时，该报文段被重传。 超时重传的概念很简单，就是一定时间内未收到确认，进行再次发送，但是如何计算重传的时间确实 tcp 最复杂的问题之一，毕竟要适应各种网络情况。TCP 一个连接期间只有一个 RTO 计时器，目前大部分实现都是采用Jacobaon/Karels 算法，详细可以看RFC6298，其计算公式如下， rto 的计算公式：1234567891011第一次rtt计算： SRTT = RRTTVAR = R/2RTO = SRTT + max (G, K*RTTVAR)K = 4之后：RTTVAR = (1 - beta) * RTTVAR + beta * |SRTT - R&apos;|SRTT = (1 - alpha) * SRTT + alpha * R&apos;RTO = SRTT + max (G, K*RTTVAR)K = 4 SRTT(smoothed round-trip time)平滑 RTT 时间RTTVAR(round-trip time variation)RTT 变量，其实就是 rtt 平均偏差G 表示系统时钟的粒度，一般很小，us 级别。 beta = 1/4, alpha = 1/8 发送方 TCP 的计时器时间到，TCP 发送队列中最前面的报文段（即序列号最小的报文段），并重启计时器。","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"tcp","slug":"tcp","permalink":"http://blog.huido.site/tags/tcp/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"3.传输层","slug":"net-protocol/3-传输层","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/"},{"name":"tcp","slug":"net-protocol/3-传输层/tcp","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/tcp/"}]},{"title":"tcp流量控制","date":"2019-10-22T13:28:59.000Z","path":"wiki/net-protocol/3.传输层/tcp/2.流量控制/","text":"tcp 流量控制tcp是由丢包重传的机制的 那么如果服务端因为负载导致不能接受发送端的数据从而丢弃数据 发送端接受到ack确认为丢包后导致重传 然后服务端导致负载更加严重，从而一个劲的重发数据，对网络造成更大的伤害。于是就提出了拥塞控制，当拥塞发生的时候，要做自我牺牲，降低发送速率。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"tcp","slug":"tcp","permalink":"http://blog.huido.site/tags/tcp/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"3.传输层","slug":"net-protocol/3-传输层","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/"},{"name":"tcp","slug":"net-protocol/3-传输层/tcp","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/tcp/"}]},{"title":"websocket算法","date":"2019-10-21T13:28:59.000Z","path":"wiki/net-protocol/2.应用层/websocket/2.websocket算法/","text":"websocket协议中的一些算法在分析 WebSocket 协议握手过程和数据帧格式过程中，我们讲到了一些算法，下面我们讲解下具体实现。 Sec-WebSocket-Accept的计算方法从上面的分析中，我们知道字段的值是通过固定字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11加上请求中Sec-WebSocket-Key字段的值，然后再对其结果通过 SHA1 哈希算法求出的结果。可以通过以下 golang 代码实现：1234567var keyGUID = []byte(\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\")func computeAcceptKey(challengeKey string) string &#123; h := sha1.New() h.Write([]byte(challengeKey)) h.Write(keyGUID) return base64.StdEncoding.EncodeToString(h.Sum(nil))&#125; 掩码处理浏览器发送给服务器的数据帧是经过掩码处理的，那怎么样对数据进行解码呢？以下是来自RFC6455文档的解释具体的流程是：将传输的数据按字节 byte 处理，同时将 Masking-key 代表的值也按字节处理。假如 data-byte-i 代表的是数据的第 i 个字节，那么 j = i MOD 4，然后从Maksing-key中(一共有 4 个字节）取出第 j 个字节 mask-key-byte-j，然后将 data-byte-i 和 mask-key-byte-j 代表的字节进行异或操作，取得结果就是最终的结果。该操作可以用如下 golang 代码实现：1234567func maskBytes(key [4]byte,pos int,b[]byte)int&#123; for i := range b&#123; b[i] ^= key[pos &amp; 3] pos++ &#125; return pos &amp; 3&#125; 注意以上的操作，pos &amp; 3这里代表的操作是pos%4,因为 a % (2 ^ n) 等价于 a &amp; (2^n -1),在这里使用按位与操作更加高效","tags":[{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"golang","slug":"golang","permalink":"http://blog.huido.site/tags/golang/"},{"name":"websocket","slug":"websocket","permalink":"http://blog.huido.site/tags/websocket/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"2.应用层","slug":"net-protocol/2-应用层","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/"},{"name":"websocket","slug":"net-protocol/2-应用层/websocket","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/websocket/"}]},{"title":"websocket实现","date":"2019-10-21T13:28:59.000Z","path":"wiki/net-protocol/2.应用层/websocket/3.websocket实现/","text":"编写基本的httpserver启动一个基本的httpserver，提供两个接口，一个index返回主页，另一个是就是我们自定义的websocket协议接口@main.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( \"fmt\" \"log\" \"github.com/brewlin/net-protocol/pkg/logging\" \"github.com/brewlin/net-protocol/protocol/application/http\" \"github.com/brewlin/net-protocol/protocol/application/websocket\")func init() &#123; logging.Setup()&#125;func main() &#123; serv := http.NewHTTP(\"tap1\", \"192.168.1.0/24\", \"192.168.1.1\", \"9502\") serv.HandleFunc(\"/ws\", echo) serv.HandleFunc(\"/\", func(request *http.Request, response *http.Response) &#123; response.End(\"hello\") &#125;) fmt.Println(\"@main: server is start ip:192.168.1.1 port:9502 \") serv.ListenAndServ()&#125;//websocket处理器func echo(r *http.Request, w *http.Response) &#123; fmt.Println(\"got http request ; start to upgrade websocket protocol....\") //协议升级 c *websocket.Conn c, err := websocket.Upgrade(r, w) if err != nil &#123; //升级协议失败，直接return 交由http处理响应 fmt.Println(\"Upgrade error:\", err) return &#125; defer c.Close() //循环处理数据，接受数据，然后返回 for &#123; message, err := c.ReadData() if err != nil &#123; log.Println(\"read:\", err) break &#125; fmt.Println(\"recv client msg:\", string(message)) // c.SendData(message ) c.SendData([]byte(\"hello\")) &#125;&#125; echo 接口接受http请求并进行升级我们的websocket页面如下 自定义的webscoket upgrade进行升级根据之前的协议分析，我知道握手的过程其实就是检查 HTTP 请求头部字段的过程，值得注意的一点就是需要针对客户端发送的 Sec-WebSocket-Key 生成一个正确的 Sec-WebSocket-Accept 只。关于生成的 Sec-WebSocket-Accpet 的实现，可以参考之前的分析。握手过程的具体代码如下：@upgrade.go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package websocketimport( \"net/http\" \"net\" \"errors\" \"log\" \"bufio\")func Upgrade(w http.ResponseWriter,r *http.Request)(c *Conn,err error)&#123; //是否是Get方法 if r.Method != \"GET\" &#123; http.Error(w,http.StatusText(http.StatusMethodNotAllowed),http.StatusMethodNotAllowed) return nil,errors.New(\"websocket:method not GET\") &#125; //检查 Sec-WebSocket-Version 版本 if values := r.Header[\"Sec-Websocket-Version\"];len(values) == 0 || values[0] != \"13\" &#123; http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest) return nil,errors.New(\"websocket:version != 13\") &#125; //检查Connection 和 Upgrade if !tokenListContainsValue(r.Header,\"Connection\",\"upgrade\") &#123; http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest) return nil,errors.New(\"websocket:could not find connection header with token 'upgrade'\") &#125; if !tokenListContainsValue(r.Header,\"Upgrade\",\"websocket\") &#123; http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest) return nil,errors.New(\"websocket:could not find connection header with token 'websocket'\") &#125; //计算Sec-Websocket-Accept的值 challengeKey := r.Header.Get(\"Sec-Websocket-Key\") if challengeKey == \"\" &#123; http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest) return nil,errors.New(\"websocket:key missing or blank\") &#125; var ( netConn net.Conn br *bufio.Reader ) h,ok := w.(http.Hijacker) if !ok &#123; http.Error(w,http.StatusText(http.StatusInternalServerError),http.StatusInternalServerError) return nil,errors.New(\"websocket:response dose not implement http.Hijacker\") &#125; var rw *bufio.ReadWriter //接管当前tcp连接，阻止内置http接管连接 netConn,rw,err = h.Hijack() if err != nil &#123; http.Error(w,http.StatusText(http.StatusInternalServerError),http.StatusInternalServerError) return nil,err &#125; br = rw.Reader if br.Buffered() &gt; 0 &#123; netConn.Close() return nil,errors.New(\"websocket:client send data before hanshake is complete\") &#125; // 构造握手成功后返回的 response p := []byte&#123;&#125; p = append(p, \"HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: \"...) p = append(p, computeAcceptKey(challengeKey)...) p = append(p, \"\\r\\n\\r\\n\"...) //返回repson 但不关闭连接 if _,err = netConn.Write(p);err != nil &#123; netConn.Close() return nil,err &#125; //升级为websocket log.Println(\"Upgrade http to websocket successfully\") conn := newConn(netConn) return conn,nil&#125; 握手过程的代码比较直观，就不多做解释了。到这里 WebSocket 的实现就基本完成了，可以看到有了之前的各种约定，我们实现 WebSocket 协议也是比较简单的。封装的websocket结构体和对应的方法@conn.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168package websocketimport ( \"fmt\" \"encoding/binary\" \"log\" \"errors\" \"net\")const ( /* * 是否是最后一个数据帧 * Fin Rsv1 Rsv2 Rsv3 Opcode * 1 0 0 0 0 0 0 0 =&gt; 128 */ finalBit = 1 &lt;&lt; 7 /* * 是否需要掩码处理 * Mask payload-len 第一位mask表示是否需要进行掩码处理 后面 * 7位表示数据包长度 1.0-125 表示长度 2.126 后面需要扩展2 字节 16bit * 3.127则扩展8bit * 1 0 0 0 0 0 0 0 =&gt; 128 */ maskBit = 1 &lt;&lt; 7 /* * 文本帧类型 * 0 0 0 0 0 0 0 1 */ TextMessage = 1 /* * 关闭数据帧类型 * 0 0 0 0 1 0 0 0 */ CloseMessage = 8)//websocket 连接type Conn struct &#123; writeBuf []byte maskKey [4]byte conn net.Conn&#125;func newConn(conn net.Conn)*Conn&#123; return &amp;Conn&#123;conn:conn&#125;&#125;func (c *Conn)Close()&#123; c.conn.Close()&#125;//发送数据func (c *Conn)SendData(data []byte)&#123; length := len(data) c.writeBuf = make([]byte,10 + length) //数据开始和结束位置 payloadStart := 2 /** *数据帧的第一个字节，不支持且只能发送文本类型数据 *finalBit 1 0 0 0 0 0 0 0 * | *Text 0 0 0 0 0 0 0 1 * =&gt; 1 0 0 0 0 0 0 1 */ c.writeBuf[0] = byte(TextMessage) | finalBit fmt.Printf(\"1 bit:%b\\n\",c.writeBuf[0]) //数据帧第二个字节，服务器发送的数据不需要进行掩码处理 switch&#123; //大于2字节的长度 case length &gt;= 1 &lt;&lt; 16 ://65536 //c.writeBuf[1] = byte(0x00) | 127 // 127 c.writeBuf[1] = byte(127) // 127 //大端写入64位 binary.BigEndian.PutUint64(c.writeBuf[payloadStart:],uint64(length)) //需要8byte来存储数据长度 payloadStart += 8 case length &gt; 125: //c.writeBuf[1] = byte(0x00) | 126 c.writeBuf[1] = byte(126) binary.BigEndian.PutUint16(c.writeBuf[payloadStart:],uint16(length)) payloadStart += 2 default: //c.writeBuf[1] = byte(0x00) | byte(length) c.writeBuf[1] = byte(length) &#125; fmt.Printf(\"2 bit:%b\\n\",c.writeBuf[1]) copy(c.writeBuf[payloadStart:],data[:]) c.conn.Write(c.writeBuf[:payloadStart+length])&#125;//读取数据func (c *Conn)ReadData()(data []byte,err error)&#123; var b [8]byte //读取数据帧的前两个字节 if _,err := c.conn.Read(b[:2]); err != nil &#123; return nil,err &#125; //开始解析第一个字节 是否还有后续数据帧 final := b[0] &amp; finalBit != 0 fmt.Printf(\"read data 1 bit :%b\\n\",b[0]) //不支持数据分片 if !final &#123; log.Println(\"Recived fragemented frame,not support\") return nil,errors.New(\"not suppeort fragmented message\") &#125; //数据帧类型 /* *1 0 0 0 0 0 0 1 * &amp; *0 0 0 0 1 1 1 1 *0 0 0 0 0 0 0 1 * =&gt; 1 这样就可以直接获取到类型了 */ frameType := int(b[0] &amp; 0xf) //如果 关闭类型，则关闭连接 if frameType == CloseMessage &#123; c.conn.Close() log.Println(\"Recived closed message,connection will be closed\") return nil,errors.New(\"recived closed message\") &#125; //只实现了文本格式的传输,编码utf-8 if frameType != TextMessage &#123; return nil,errors.New(\"only support text message\") &#125; //检查数据帧是否被掩码处理 //maskBit =&gt; 1 0 0 0 0 0 0 0 任何与他 要么为0 要么为 128 mask := b[1] &amp; maskBit != 0 //数据长度 payloadLen := int64(b[1] &amp; 0x7F)//0 1 1 1 1 1 1 1 1 127 dataLen := int64(payloadLen) //根据payload length 判断数据的真实长度 switch payloadLen &#123; case 126://扩展2字节 if _,err := c.conn.Read(b[:2]);err != nil &#123; return nil,err &#125; //获取扩展二字节的真实数据长度 dataLen = int64(binary.BigEndian.Uint16(b[:2])) case 127 : if _,err := c.conn.Read(b[:8]);err != nil &#123; return nil,err &#125; dataLen = int64(binary.BigEndian.Uint64(b[:8])) &#125; log.Printf(\"Read data length :%d,payload length %d\",payloadLen,dataLen) //读取mask key if mask &#123;//如果需要掩码处理的话 需要取出key //maskKey 是 4 字节 32位 if _,err := c.conn.Read(c.maskKey[:]);err != nil &#123; return nil ,err &#125; &#125; //读取数据内容 p := make([]byte,dataLen) if _,err := c.conn.Read(p);err != nil &#123; return nil,err &#125; if mask &#123; maskBytes(c.maskKey,p)//进行解码 &#125; return p,nil&#125; http 头部检查12345678910111213141516171819202122232425262728293031323334353637import ( \"crypto/sha1\" \"encoding/base64\" \"strings\" \"net/http\")var KeyGUID = []byte(\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\")//握手阶段使用 加密key返回 进行握手func computeAcceptKey(challengeKey string)string&#123; h := sha1.New() h.Write([]byte(challengeKey)) h.Write(KeyGUID) return base64.StdEncoding.EncodeToString(h.Sum(nil))&#125;//解码func maskBytes(key [4]byte,b []byte)&#123; pos := 0 for i := range b &#123; b[i] ^= key[pos &amp; 3] pos ++ &#125;&#125;// 检查http 头部字段中是否包含指定的值func tokenListContainsValue(header http.Header, name string, value string)bool&#123; for _,v := range header[name] &#123; for _, s := range strings.Split(v,\",\")&#123; if strings.EqualFold(value,strings.TrimSpace(s)) &#123; return true &#125; &#125; &#125; return false&#125;","tags":[{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"golang","slug":"golang","permalink":"http://blog.huido.site/tags/golang/"},{"name":"websocket","slug":"websocket","permalink":"http://blog.huido.site/tags/websocket/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"2.应用层","slug":"net-protocol/2-应用层","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/"},{"name":"websocket","slug":"net-protocol/2-应用层/websocket","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/websocket/"}]},{"title":"websocket协议解析","date":"2019-10-21T13:28:59.000Z","path":"wiki/net-protocol/2.应用层/websocket/1.websocket协议解析/","text":"websocket 协议报文websocket协议也是基于tcp协议，和http不同的是，tcp接受的数据包为二进制帧，而http为字符串数据包。并且websocket协议在连接阶段会触发一个http请求进行websocket协议校验。校验成功后才会接管tcp通讯流程不会断开该http连接 1234567891011121314151617181920websocket 数据帧报文 0 1 2 3 4 0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+ WebSocket协议详解WebSocket 协议解决了浏览器和服务器之间的全双工通信问题。在 WebSocket 出现之前，浏览器如果需要从服务器及时获得更新，则需要不停的对服务器主动发起请求，也就是 Web 中常用的poll技术。这样的操作非常低效，这是因为每发起一次新的 HTTP 请求，就需要单独开启一个新的 TCP 链接，同时 HTTP 协议本身也是一种开销非常大的协议。为了解决这些问题，所以出现了 WebSocket 协议。WebSocket 使得浏览器和服务器之间能通过一个持久的 TCP 链接就能完成数据的双向通信。关于 WebSocket 的 RFC 提案，可以参看RFC6455。 WebSocket 和 HTTP 协议一般情况下都工作在浏览器中，但 WebSocket 是一种完全不同于 HTTP 的协议。尽管，浏览器需要通过 HTTP 协议的GET请求，将 HTTP 协议升级为 WebSocket 协议。升级的过程被称为握手(handshake)。当浏览器和服务器成功握手后，则可以开始根据 WebSocket 定义的通信帧格式开始通信了。像其他各种协议一样，WebSocket 协议的通信帧也分为控制数据帧和普通数据帧，前者用于控制 WebSocket 链接状态，后者用于承载数据。下面我们将一一分析 WebSocket 协议的握手过程以及通信帧格式。 一、websocket握手握手的过程也就是将HTTP协议升级为WebSocket协议的过程，握手开始首先由浏览器端发送一个GET请求，该请求的HTTP头部信息如下:12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protcol: chat, superchatSec-WebSocket-Version: 13 当服务器端，成功验证了以上信息后，则会返回一个形如以下的响应：12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat 可以看到，浏览器发送端HTTP请求中，增加了一些新端字段，其作用如下所示： Upgrade: 规定必需的字段，其值必需为 websocket, 如果不是则握手失败； Connection: 规定必需的字段，值必需为 Upgrade, 如果不是则握手失败；Sec-WebSocket-Key: 必需字段，一个随机的字符串；Sec-WebSocket-Protocol: 可选字段，可以用于标识应用层的协议；Sec-WebSocket-Version: 必需字段，代表了 WebSocket 协议版本，值必需是 13, 否则握手失败；返回端响应中，如果握手成功会返回状态码101的HTTP响应，同时其他字段说明如下： Upgrade: 规定必需的字段，其值必需为 websocket, 如果不是则握手失败； Connection: 规定必需的字段，值必需为 Upgrade, 如果不是则握手失败； Sec-WebSocket-Accept: 规定必需的字段，该字段的值是通过固定字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11加上请求中Sec-WebSocket-Key字段的值，然后再对其结果通过 SHA1 哈希算法求出的结果。 Sec-WebSocket-Protocol: 对应于请求中的 Sec-WebSocket-Protocol 字段；当浏览器和服务端成功握手后，就可以传递数据了，传送数据是按照WebSocket的数据格式生成的二、WebSocket协议数据帧数据帧的定义类似与TCP/IP的格式定义，具体看下图：123456789101112131415161718 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len | Extended payload length ||I|S|S|S| (4) |A| (7) | (16/64) ||N|V|V|V| |S| | (if payload len==126/127) || |1|2|3| |K| | |+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +| Extended payload length continued, if payload len == 127 |+ - - - - - - - - - - - - - - - +-------------------------------+| |Masking-key, if MASK set to 1 |+-------------------------------+-------------------------------+| Masking-key (continued) | Payload Data |+-------------------------------- - - - - - - - - - - - - - - - +: Payload Data continued ... :+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +| Payload Data continued ... |+---------------------------------------------------------------+ 以上这张图，一行代表32bit（位），也就是4bytes（字节），总体上包含两份，帧头部和数据内容。每个从WebSocket链接中接受到的数据帧，都要按照以上格式进行解析，这样才能知道该数据帧是用于控制的还是用于传送数据的，关于以上数据帧的各个比特位的解释如下： FIN:1bit,当该比特位值为%x0时，表示后面还有更多的数据帧，%x1时表示这是最后一个数据帧； RSV1,RSV2,RSV3:各占1个比特位。一般情况下全为0，当客户端、服务端协商采用WebSocket扩展时，这三个标识位可以非0，且值当含义由扩展进行定义，如果出现非0当值，且没有采用WebSocket扩展，则链接出错 opcode:4 bit,用于表明数据帧当类型，一共可以表示16种帧类型，如下所示： %x0:表示这是一个分片当帧，它属于前面帧当后续帧； %x1:表示该数据帧携带的数据类型是文本类型，且编码utf-8 %x2 : 表示携带的是二进制数据； %x3-7 : 保留未使用； %x8 : 表示该帧用于关闭 WebSocket 链接； %x9 : 表示该帧代表了 ping 操作； %xA : 表示该帧代表了 pong 回应； %xB-F : 保留未使用； MASK:1 bit,%x0表示数据帧没有经过掩码计算，而%x1则表示数据帧已经经过掩码计算，得到真正当数据需要解码，一般情况下，只有浏览器发送给服务端当数据帧才需要进行掩码计算； Payload len:7 bit,表示了数据帧携带当数据长度，7 bit 的值根据三种情况，帧的解析有所不同： %x0 - 7D : 也就是从 0 到 125，表示数据长度, 数据总长度也就是 7 bit 代表的长度； %x7E : 7 bit 的值是 126 时，则后续的 2 个字节（16 bit)表示的一个 16 位无符号数，这个数用来表示数据的长度； %x7F : 7 bit 的值是 127 时，则后续的 8 个字节（64 bit)表示的一个 64 位无符号数，这个数用来表示数据的长度； Masking-key: 32 bit, 表示了用于解码的 key，只有当 MASK 比特位的值为 %x1 是，才有该数据； Payload Data: 余下的比特位用于存储具体的数据；通过以上分析可以看出，WebSocket 协议数据帧的最大头部为 2 + 8 + 4 = 14 bytes 也就是 14 个字节。同时我们要实现 WebSocket 协议，最主要的工作就是实现对数据帧的解析。","tags":[{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"golang","slug":"golang","permalink":"http://blog.huido.site/tags/golang/"},{"name":"websocket","slug":"websocket","permalink":"http://blog.huido.site/tags/websocket/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"2.应用层","slug":"net-protocol/2-应用层","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/"},{"name":"websocket","slug":"net-protocol/2-应用层/websocket","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/websocket/"}]},{"title":"http协议解析","date":"2019-10-18T13:28:59.000Z","path":"wiki/net-protocol/2.应用层/http/1.http协议解析/","text":"http协议报文这是一个典型的http请求的报文样例，可以看出是一个websocket升级前的http请求。该字符报文完全基于tcp协议，协议报文内容为tcp数据包，也就是tcp进行recv调用获取的数据内容。如下报文表示已经接受完http报文数据。 解析http报文的源码为application/http/request.go中123456789http 协议报文GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protcol: chat, superchatSec-WebSocket-Version: 13 @请求方法解析tcp数据包第一行数据，遇到空格就拆分，则获取到请求方法 @uri解析tcp数据包第一行数据，遇到空格就拆分，则获取到uri路径 @header头部接下来都是一些头部信息的keyvalue，每次读取一行，然后根据:分隔符进行拆分，获取header头部请求键值对","tags":[{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"golang","slug":"golang","permalink":"http://blog.huido.site/tags/golang/"},{"name":"http","slug":"http","permalink":"http://blog.huido.site/tags/http/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"2.应用层","slug":"net-protocol/2-应用层","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/"},{"name":"http","slug":"net-protocol/2-应用层/http","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/http/"}]},{"title":"应用层前世今生","date":"2019-10-17T13:28:59.000Z","path":"wiki/net-protocol/2.应用层/应用层前世今生/","text":"应用层的作用对传输层协议对再次封装，例如对tcp进行封装对http、websocket协议等，以及http3协议基于udp协议的封装等 http协议报文123456789http 协议报文GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protcol: chat, superchatSec-WebSocket-Version: 13 websocket 协议报文1234567891011121314151617181920websocket 数据帧报文 0 1 2 3 4 0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"2.应用层","slug":"net-protocol/2-应用层","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/"}]},{"title":"快速开始","date":"2019-10-16T13:28:59.000Z","path":"wiki/net-protocol/1.前言/1.快速开始/","text":"demo案例cmd:该目录下为各协议的实现demo，提供api调用实现以及测试","tags":[{"name":"Go","slug":"Go","permalink":"http://blog.huido.site/tags/Go/"},{"name":"Protocol","slug":"Protocol","permalink":"http://blog.huido.site/tags/Protocol/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"1.前言","slug":"net-protocol/1-前言","permalink":"http://blog.huido.site/categories/net-protocol/1-前言/"}]},{"title":"相关资料","date":"2017-10-26T13:28:59.000Z","path":"wiki/go-stl/raft/相关资料/","text":"参考资料动画演示 raft 协议http://thesecretlivesofdata.com/raft/ raft 比较好的bloghttp://oserror.com/distributed/implement-raft-with-golang-first/ http://blog.luoyuanhang.com/2017/02/02/raft-paper-in-zh-CN/ 相关原版英语论文http://people.csail.mit.edu/cowling/vr/vr-revisited.pdf","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"algorithm","slug":"algorithm","permalink":"http://blog.huido.site/tags/algorithm/"},{"name":"raft","slug":"raft","permalink":"http://blog.huido.site/tags/raft/"}],"categories":[{"name":"go-stl","slug":"go-stl","permalink":"http://blog.huido.site/categories/go-stl/"},{"name":"raft","slug":"go-stl/raft","permalink":"http://blog.huido.site/categories/go-stl/raft/"}]},{"title":"raft分布式一致性原理(二)","date":"2017-10-26T13:28:59.000Z","path":"wiki/go-stl/raft/raft分布式一致性原理(二)/","text":"@1 选举此阶段为集群初始化，所有的节点都是FOLLOWER身份 进行事件循环 @fllower 身份 接受主节点心跳 接受投票选举 如果在超时时间里还没有处触发上面两个事件 则转换为 CANDIDATE 候选身份，作为新的候选人进行选举 @candidate 身份 开始选举，增加当前任期 term 投票给自己 广播rpc向所有节点发起选举投票 当前任期小于其他节点则转换为fllower节点等待心跳到来或者超时 当前依然为candidate 且 收到的投票大于 总结点1/2 则准换为 leader节点结束选举 监听广播的投票结果 收到心跳 说明选举失败退化为follwer节点 选举成功为leader 结束选举@leader 身份 广播所有节点心跳 和日志复制 睡眠等待下一次心跳发送 原则 性质 描述 选举安全原则（Election Safety） 一个任期（term）内最多允许有一个领导人被选上 领导人只增加原则（Leader Append-Only） 领导人永远不会覆盖或者删除自己的日志，它只会增加条目 日志匹配原则（Log Matching） 如果两个日志在相同的索引位置上的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间的条目完全相同 领导人完全原则（Leader Completeness) 如果一个日志条目在一个给定任期内被提交，那么这个条目一定会出现在所有任期号更大的领导人中 状态机安全原则（State Machine Safety） 如果一个服务器已经将给定索引位置的日志条目应用到状态机中，则所有其他服务器不会在该索引位置应用不同的条目 @2日志复制只有当该日志同步到所有node才可以进行提交commited 到状态机state machine @状态机其实就是实际进行操作的区域，如果该服务是数据库，那么状态机就是实际执行命令储存的地方 当收到所有的节点回复可以提交到状态机后，然后leader节点进行提交，提交后在广播到其他节点，通知其他节点可以提交日志到状态机执行命令 到这里就算是成功提交了一条命令","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"algorithm","slug":"algorithm","permalink":"http://blog.huido.site/tags/algorithm/"},{"name":"raft","slug":"raft","permalink":"http://blog.huido.site/tags/raft/"}],"categories":[{"name":"go-stl","slug":"go-stl","permalink":"http://blog.huido.site/categories/go-stl/"},{"name":"raft","slug":"go-stl/raft","permalink":"http://blog.huido.site/categories/go-stl/raft/"}]},{"title":"raft分布式一致性原理(一)","date":"2017-10-26T13:28:59.000Z","path":"wiki/go-stl/raft/raft分布式一致性原理(一)/","text":"raft分布式一致性原理无限循环选leader异常当启动所有server时，默认都是follower 此时没有leader角色，然后follower会转换成candidate 身份进行选取leader @选取leader失败导致的重复选取当所有的follower 都转换为candidate身份进行leader选举时，可能导致选取leader失败，那么会更新选举时间，进行下一次重新选举 此时就可能导致无限次选举 @随机定时器其实就是采用 150ms - 300ms之间 随机产生一个定时时间，此时默认同一时刻基本只有一个server会转换为candidate身份，解决了单次无法选举出leader的问题 @选举leader 限制候选人进行选举leader时发起并行请求投票 RPC 实现了这样的限制： RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。 总的来说 就是过滤掉那些日志比较落后的候选人节点 Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"algorithm","slug":"algorithm","permalink":"http://blog.huido.site/tags/algorithm/"},{"name":"raft","slug":"raft","permalink":"http://blog.huido.site/tags/raft/"}],"categories":[{"name":"go-stl","slug":"go-stl","permalink":"http://blog.huido.site/categories/go-stl/"},{"name":"raft","slug":"go-stl/raft","permalink":"http://blog.huido.site/categories/go-stl/raft/"}]},{"title":"并发压测对比","date":"2017-10-25T13:28:59.000Z","path":"wiki/im-cloud/1.前言/2.并发压测对比/","text":"im-cloud &lt;&gt; goim 分布式中间件并发压测对比系统环境 此次测试环境为 window8.1 启动 virtualbox虚拟机部署的ubuntu14 goim无需担心进程配置，im-cloud测试时候需要根据机器配置做更改worker进程和task进程最好和cpu核心数保持一致，太大会使性能大大降低 测评对象 goim im-cloud goim (bilibili出品，经过B站生产验证 百万级消息秒级推送) im-cloud（借鉴goim 使用swoole原生实现 经过自己验证。。。）硬件环境123CPU: 4 核cpuMEM: 2G 内存 System: Ubunutu 14.04 (64bit) 软件环境123456789单节点启动im-cloud: cloud(2 个worker进程 2个子进程) job( 2 个worker进程 2个task进程 1个子进程) logic(2个worker进程 2个task进程 1个子进程)goim : comet(单进程) job(单进程) logic(单进程) 评测结果1234567891011c : concurrent 并发请求n : number 总请求数-----------------------------------c:500 | n:2000 | n:5000 | n:20000im-cloud: 6300 6082 3815goim : 5377 5540 5894 -----------------------------------c:1000 | n:20000im-cloud: 5014goim : 5950 ----------------------------------- @Concurrent:500 @Number:2000 im-cloud 整体高达6300qps goim 整体高达 5300qps im-cloud123456789101112131415161718192021222324Server Software: swoole-http-serverServer Hostname: 127.0.0.1Server Port: 9600Concurrency Level: 500Time taken for tests: 0.321 secondsComplete requests: 2000Failed requests: 0Total transferred: 354000 bytesTotal body sent: 374000HTML transferred: 58000 bytesRequests per second: 6239.74 [#/sec] (mean)Time per request: 80.131 [ms] (mean)Time per request: 0.160 [ms] (mean, across all concurrent requests)Transfer rate: 1078.55 [Kbytes/sec] received 1139.48 kb/s sent 2218.03 kb/s totalConnection Times (ms) min mean[+/-sd] median maxConnect: 10 22 5.0 21 35Processing: 6 33 11.3 30 74Waiting: 4 25 10.1 24 68Total: 31 54 11.1 54 98 goim123456789101112131415161718192021222324Document Path: /goim/push/mids?mids=123&amp;operation=1000Document Length: 23 bytesConcurrency Level: 500Time taken for tests: 0.372 secondsComplete requests: 2000Failed requests: 0Total transferred: 292000 bytesTotal body sent: 356000HTML transferred: 46000 bytesRequests per second: 5377.91 [#/sec] (mean)Time per request: 92.973 [ms] (mean)Time per request: 0.186 [ms] (mean, across all concurrent requests)Transfer rate: 766.77 [Kbytes/sec] received 934.83 kb/s sent 1701.60 kb/s totalConnection Times (ms) min mean[+/-sd] median maxConnect: 0 14 11.8 11 46Processing: 17 65 27.7 62 149Waiting: 16 59 24.1 57 136Total: 31 79 22.0 75 162 @Concurrent:500 @Number:5000 5000的请求下 im-cloud高达6100qps im-cloud12345678910111213141516171819Server Software: swoole-http-serverServer Hostname: 127.0.0.1Server Port: 9600Document Path: /im/push/mids?mids=123&amp;operation=9&amp;msg=push_midsDocument Length: 29 bytesConcurrency Level: 500Time taken for tests: 0.822 secondsComplete requests: 5000Failed requests: 0Total transferred: 885000 bytesTotal body sent: 935000HTML transferred: 145000 bytesRequests per second: 6082.98 [#/sec] (mean)Time per request: 82.196 [ms] (mean)Time per request: 0.164 [ms] (mean, across all concurrent requests)Transfer rate: 1051.45 [Kbytes/sec] received 1110.86 kb/s sent 2162.31 kb/s total goim1234567891011121314151617181920212223Document Path: /goim/push/mids?mids=123&amp;operation=1000Document Length: 23 bytesConcurrency Level: 500Time taken for tests: 0.907 secondsComplete requests: 5000Failed requests: 0Total transferred: 730000 bytesTotal body sent: 890000HTML transferred: 115000 bytesRequests per second: 5514.84 [#/sec] (mean)Time per request: 90.664 [ms] (mean)Time per request: 0.181 [ms] (mean, across all concurrent requests)Transfer rate: 786.30 [Kbytes/sec] received 958.63 kb/s sent 1744.93 kb/s totalConnection Times (ms) min mean[+/-sd] median maxConnect: 0 18 13.4 16 54Processing: 20 64 25.0 63 143Waiting: 17 55 20.5 54 117Total: 35 82 21.3 80 161 @Concurrent:500 @Number:20000 请求20000 并发500 goim1234567891011121314151617181920212223Document Path: /goim/push/mids?mids=123&amp;operation=1000Document Length: 23 bytesConcurrency Level: 500Time taken for tests: 3.393 secondsComplete requests: 20000Failed requests: 0Total transferred: 2920000 bytesTotal body sent: 3560000HTML transferred: 460000 bytesRequests per second: 5894.30 [#/sec] (mean)Time per request: 84.828 [ms] (mean)Time per request: 0.170 [ms] (mean, across all concurrent requests)Transfer rate: 840.40 [Kbytes/sec] received 1024.60 kb/s sent 1864.99 kb/s totalConnection Times (ms) min mean[+/-sd] median maxConnect: 0 30 129.4 10 1025Processing: 10 50 19.2 47 128Waiting: 6 42 16.1 40 125Total: 16 80 131.8 60 1100 im-cloud12345678910111213141516171819Server Software: swoole-http-serverServer Hostname: 127.0.0.1Server Port: 9600Document Path: /im/push/mids?mids=123&amp;operation=9&amp;msg=push_midsDocument Length: 29 bytesConcurrency Level: 500Time taken for tests: 5.242 secondsComplete requests: 20000Failed requests: 0Total transferred: 3540000 bytesTotal body sent: 3740000HTML transferred: 580000 bytesRequests per second: 3815.33 [#/sec] (mean)Time per request: 131.050 [ms] (mean)Time per request: 0.262 [ms] (mean, across all concurrent requests)Transfer rate: 659.49 [Kbytes/sec] received 696.75 kb/s sent 1356.23 kb/s total @Concurrent:1000 @Number:20000 请求20000 并发1000 goim12345678910111213141516Document Path: /goim/push/mids?mids=123&amp;operation=1000Document Length: 23 bytesConcurrency Level: 1000Time taken for tests: 3.361 secondsComplete requests: 20000Failed requests: 0Total transferred: 2920000 bytesTotal body sent: 3560000HTML transferred: 460000 bytesRequests per second: 5950.20 [#/sec] (mean)Time per request: 168.061 [ms] (mean)Time per request: 0.168 [ms] (mean, across all concurrent requests)Transfer rate: 848.37 [Kbytes/sec] received 1034.31 kb/s sent 1882.68 kb/s total im-cloud1234567891011121314151617181920Server Software: swoole-http-serverServer Hostname: 127.0.0.1Server Port: 9600Document Path: /im/push/mids?mids=123&amp;operation=9&amp;msg=push_midsDocument Length: 29 bytesConcurrency Level: 500Time taken for tests: 3.988 secondsComplete requests: 20000Failed requests: 0Total transferred: 3540000 bytesTotal body sent: 3740000HTML transferred: 580000 bytesRequests per second: 5014.66 [#/sec] (mean)Time per request: 99.708 [ms] (mean)Time per request: 0.199 [ms] (mean, across all concurrent requests)Transfer rate: 866.79 [Kbytes/sec] received 915.76 kb/s sent 1782.56 kb/s total","tags":[{"name":"php","slug":"php","permalink":"http://blog.huido.site/tags/php/"},{"name":"swoole","slug":"swoole","permalink":"http://blog.huido.site/tags/swoole/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://blog.huido.site/tags/rabbitmq/"}],"categories":[{"name":"im-cloud","slug":"im-cloud","permalink":"http://blog.huido.site/categories/im-cloud/"},{"name":"1.前言","slug":"im-cloud/1-前言","permalink":"http://blog.huido.site/categories/im-cloud/1-前言/"}]},{"title":"cloud节点实现","date":"2017-10-25T13:28:59.000Z","path":"wiki/im-cloud/2.底层实现/3.cloud节点/","text":"im-cloud分布式中间件分析-cloud节点实现1.概述 cloud 节点对外提供websocket、tcp client 注册。并维护每个连接对应的客户端信息。作为Grpc server，接受grpc推送数据，并推送到client端 数据流程图 2.@Grpc server grpc server 基于swoole 的http2协议，然后通过config/router.php 配置项注册路由既可以使用如rest模式下的交互流程 grpc 路由注册 配置文件 config/router.php1234567&lt;?php//Grpc server routerHttpRouter::post('/im.cloud.Cloud/Ping', '/Grpc/Cloud/ping');HttpRouter::post('/im.cloud.Cloud/Close', '/Grpc/Cloud/close');HttpRouter::post('/im.cloud.Cloud/PushMsg', '/Grpc/Cloud/pushMsg');HttpRouter::post('/im.cloud.Cloud/Broadcast', '/Grpc/Cloud/broadcast');HttpRouter::post('/im.cloud.Cloud/Rooms', '/Grpc/Cloud/rooms'); 和rest 路由一样只需要注册路由到对应的方法即可，当使用grpc-client进行请求时，就能分发到最远的控制器去， grpc 参数解析 当接收到请求后，可以根据协程上下文获取当前连接的请求参数，grpc传输的协议是二进制，所以不能通过get，post方法直接获得对应的参数，需要采用grpc提供的方法进行解包1234567891011use Grpc\\Parser;use Core\\Context\\Context;public function pushMsg()&#123; $rawbody = Context::get()-&gt;getRequest()-&gt;getRawBody(); /** @var PushMsgReq $pushMsgReq */ $pushMsgReq = Parser::deserializeMessage( [PushMsgReq::class,null], $rawbody );&#125; 获取请求参数可以通过协程上下文获取 Context::get()-&gt;getRequest()-&gt;getRawBody(); request()-&gt;getRawBody(); Grpc\\Parser 方法使用的是 swoole\\grpc-client 组件包提供的方法，使用swoole对原生grpc 进行了封装3.@websocket server 基于websocket 协议注册到cloud节点，cloud 进行认证，通过grpc将注册信息传递到logic统一管理，认证成功后cloud节点将保存改连接的基础信息 握手阶段 命名空间：App/Websocket/HandshakeListener.class 该事件为swoole 监听事件，所以需要注册监听回调函数,配置文件为config/event.php1234567use \\Core\\Swoole\\SwooleEvent;use \\App\\Websocket\\HandshakeListener;return [ //websocket握手事件 SwooleEvent::HANDSHAKE =&gt; new HandshakeListener(),]; 接下来是握手流程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * token check &apos;&#123;&quot;mid&quot;:123, &quot;room_id&quot;:&quot;live://1000&quot;, &quot;platform&quot;:&quot;web&quot;, &quot;accepts&quot;:[1000,1001,1002]&#125;&apos; * @param Request $request * @param Response $response * @return bool */public function onHandshake(Request $request, Response $response): bool&#123; $httpRequest = HttpRequest::new($request); //握手失败 if($httpRequest-&gt;getUriPath() != self::upgradeUrl)&#123; $response-&gt;end(); return false; &#125; // websocket握手连接算法验证 $secWebSocketKey = $request-&gt;header[&apos;sec-websocket-key&apos;]; $patten = &apos;#^[+/0-9A-Za-z]&#123;21&#125;[AQgw]==$#&apos;; if (0 === preg_match($patten, $secWebSocketKey) || 16 !== strlen(base64_decode($secWebSocketKey))) &#123; $response-&gt;end(); return false; &#125; $key = base64_encode(sha1( $request-&gt;header[&apos;sec-websocket-key&apos;] . &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos;, true )); $headers = [ &apos;Upgrade&apos; =&gt; &apos;websocket&apos;, &apos;Connection&apos; =&gt; &apos;Upgrade&apos;, &apos;Sec-WebSocket-Accept&apos; =&gt; $key, &apos;Sec-WebSocket-Version&apos; =&gt; &apos;13&apos;, ]; // WebSocket connection to &apos;ws://127.0.0.1:9502/&apos; // failed: Error during WebSocket handshake: // Response must not include &apos;Sec-WebSocket-Protocol&apos; header if not present in request: websocket if (isset($request-&gt;header[&apos;sec-websocket-protocol&apos;])) &#123; $headers[&apos;Sec-WebSocket-Protocol&apos;] = $request-&gt;header[&apos;sec-websocket-protocol&apos;]; &#125; foreach ($headers as $key =&gt; $val) &#123; $response-&gt;header($key, $val); &#125; $response-&gt;status(101); $response-&gt;end(); return true;&#125; 该方法在握手阶段对于http请求进行校验，如果路径不为 ‘/sub’ 则认证失败关闭连接，成功后校验websocekt协议并升级为websocket， 主事件处理 同样需要注册websocket的onmessage事件 配置文件:config/envent.php @step1 解包 使用 App\\Packet\\Packet::class 进行解包，通讯协议为二进制传输，会有单独一章分析im-cloud通讯协议的设计 @step2 处理分发(注册) 根据协议，如果为注册请求，则进行注册流程，心跳则进行心跳流程im-cloud暂时不支持双向推送，也就是该连接不支持接受推送消息，推送请走logic节点push @step3 注册 1.进行auth参数校验 2.通过grpc 注册到logic节点 123456789101112$server = LogicClient::getLogicClient();if(empty($server)) throw new \\Exception(\"not find any logic node\");$connectReq = new ConnectReq();/** @var \\Im\\Logic\\LogicClient $rpcClient */$rpcClient = null;$serverId = env(\"APP_HOST\",\"127.0.0.1\").\":\".env(\"GRPC_PORT\",9500);$connectReq-&gt;setServer($serverId);$connectReq-&gt;setCookie(\"\");$connectReq-&gt;setToken(json_encode($data));/** @var ConnectReply $rpy */$rpy = GrpcLogicClient::Connect($server,$connectReq)[0]; 3.注册成功后将当前用户信息 写入bucket进程，独立维护所有的用户信息和连接 1234[$mid,$key,$roomId,$accepts,$heartbeat] = $this-&gt;registerLogic($body);/** @var Task $task */\\bean(Task::class)-&gt;deliver(Bucket::class,&quot;put&quot;,[$roomId,$key,$fd]); 4.@tcp server tcp 处理流程和websocket大致相似，走同样的流程,只是监听对应的api有些区别 5.自定义进程cloud节点 默认启动了两个自定义进程伴随swoole启动而启动 discoveryProcess 注册发现进程 该进程 在启动时注册到 注册中心(默认consul，可以扩展其他的注册中心),然后进行事件轮训，获取健康状态的实例节点 配置文件 config/process.php 注册进程到进程管理器 config/consul.php 配置发现中心的配置 获取到实例节点后 更新swoole所有的worker进程里的实例节点信息使用sendMessage()进行进程间通信123456789101112131415161718192021222324/*** 自定义子进程 执行入口* @param Process $process*/public function run(Process $process)&#123; provider()-&gt;select()-&gt;registerService(); $config = config(\"discovery\"); $discovery = $config[\"consul\"][\"discovery\"][\"name\"]; while (true)&#123; $services = provider()-&gt;select()-&gt;getServiceList($discovery); if(empty($services))&#123; CLog::error(\"not find any instance node:$discovery\"); goto SLEEP; &#125; for($i = 0; $i &lt; (int)env(\"WORKER_NUM\",4);$i++) &#123; //将可以用的服务同步到所有的worker进程 Cloud::server()-&gt;getSwooleServer()-&gt;sendMessage($services,$i); &#125;SLEEP: sleep(10); &#125;&#125; bucketProcess 用户缓存池 配置文件 config/process.php 注册该进程 该进程两个任务: 1 注册成功后缓存用户信息，管理用户连接 123456//step 1[$mid,$key,$roomId,$accepts,$heartbeat] = $this-&gt;registerLogic($body);//step 2/** @var Task $task */\\bean(Task::class)-&gt;deliver(Bucket::class,\"put\",[$roomId,$key,$fd]);使用deliver进程间通信，发送到bucketProcess进程处理 2.作为主要的推送进程 当cloud节点grpcserver 接收到推送请求，则创建一个协程写入bucketprocess进程，当前进程消费管道里的数据，每个数据创建一个协程，处理推送问题 3.使用自定义进程管理用户信息的选择 12出版采用的redis缓存用户信息，在实际压测的时候发现即使是redis缓存还是会影响并发处理。导致慢了4-5倍，而采用自定义进程处理的好处有如下两点，多进程下对数据不需要加锁。针对每个请求单独创建一个协程反而效率要高些 5.监听事件，生命周期管理 swoole 相关生命周期执行管理都依赖监听事件，例如 进程启动 请求事件 握手连接 关闭连接 等等。。123456789101112131415161718192021222324252627282930313233343536/** * set event to base swoole * 给swoole 设置基础的监听事件， */use \\Core\\Swoole\\SwooleEvent;use \\App\\Event\\PipeMessageListener;use \\App\\Event\\WorkerStopListener;use \\App\\Event\\ShutdownListener;use \\App\\Websocket\\MessageListener;use \\App\\Websocket\\HandshakeListener;use App\\Tcp\\ReceiveListener;use App\\Event\\OnCloseListener;use App\\Event\\WorkerStartListener;return [ //监听onpipmessage事件 SwooleEvent::PIPE_MESSAGE =&gt; new PipeMessageListener(), //监听进程启动事件 SwooleEvent::WORKER_START =&gt; new WorkerStartListener(), //监听进程关闭事件 SwooleEvent::WORKER_STOP =&gt; new WorkerStopListener(), SwooleEvent::SHUTDOWN =&gt; new ShutdownListener(), //监听tcp事件 SwooleEvent::RECEIVE =&gt; new ReceiveListener(), //监听websocket 事件 SwooleEvent::MESSAGE =&gt; new MessageListener(), //websocket握手事件 SwooleEvent::HANDSHAKE =&gt; new HandshakeListener(), //server监听关闭连接事件然后grpc通知logic销毁连接信息 SwooleEvent::CLOSE =&gt; new OnCloseListener(),];","tags":[{"name":"php","slug":"php","permalink":"http://blog.huido.site/tags/php/"},{"name":"swoole","slug":"swoole","permalink":"http://blog.huido.site/tags/swoole/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://blog.huido.site/tags/rabbitmq/"}],"categories":[{"name":"im-cloud","slug":"im-cloud","permalink":"http://blog.huido.site/categories/im-cloud/"},{"name":"2.底层实现","slug":"im-cloud/2-底层实现","permalink":"http://blog.huido.site/categories/im-cloud/2-底层实现/"}]},{"title":"job节点实现","date":"2017-10-25T13:28:59.000Z","path":"wiki/im-cloud/2.底层实现/4.job节点/","text":"im-cloud分布式中间件分析-job节点实现1.概述 job 节点 作为消费端，消费logic生产的数据，然后通过grpc推送至cloud节点，cloud点真正处理客户端数据，job节点默认多进程消费启动4个worker进程，以及默认10个grpc连接池 数据流程图 2.@Consumer 消费中心 默认启动4个worker进程消费logic请求，耗时处理投放至task进程处理，并转发至cloud节点 监听worker启动事件需要在config/queue.php ,config/event.php 注册相应的事件和相关配置123456789101112131415161718use App\\Consumer\\Consumer;use Core\\App;use Core\\Swoole\\WorkerStartInterface;use Swoole\\Server as SwooleServer;class WorkerStartListener implements WorkerStartInterface&#123; const INIT_LOGIC = 1; public function onWorkerStart(SwooleServer $server, int $workerId): void &#123; if(App::isWorkerStatus())&#123; //启动的n个 worker进程 分别作为消费者进程消费，每个进程会直接阻塞直到消费到数据 consumer()-&gt;consume(new Consumer()); &#125; &#125;&#125; 消费主流程 1.为每个消费数据请求建立一个协程，处理相关数据 2.将每个数据投递至worker进程进行真正的grpc与cloud推送请求 12345678Co::create(function()use($data)&#123; if(empty(CloudClient::$table-&gt;getAllInstance()))&#123; Log::error(&quot;cancle task deliver discovery cloud node is empty&quot;); return; &#125; Task::deliver(Job::class,&quot;push&quot;,[$data]);&#125;,false);return Result::ACK; 3.通过以上做法能加快并发是消费速度，task进程也进行协程处理，增加并行处理能力，如果task进程阻塞也会造成task任务投递阻塞，所以在worker进程也需要加一个协程处理","tags":[{"name":"php","slug":"php","permalink":"http://blog.huido.site/tags/php/"},{"name":"swoole","slug":"swoole","permalink":"http://blog.huido.site/tags/swoole/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://blog.huido.site/tags/rabbitmq/"}],"categories":[{"name":"im-cloud","slug":"im-cloud","permalink":"http://blog.huido.site/categories/im-cloud/"},{"name":"2.底层实现","slug":"im-cloud/2-底层实现","permalink":"http://blog.huido.site/categories/im-cloud/2-底层实现/"}]},{"title":"logic节点实现","date":"2017-10-25T13:28:59.000Z","path":"wiki/im-cloud/2.底层实现/5.logic节点/","text":"im-cloud分布式中间件分析-logic节点实现1.概述 logic 节点 作为生产者和client端，作为业务节点，提供push推送resetapi接口，可以扩容多个节点做nginx负载均衡 2.@Producer 默认启动10个消息队列连接池，在task进程为每个人物创建协程异步生产任务 异步task任务直接调用组件task接口进行投递到task进程执行，task投递为非阻塞操作，执行完毕会直接返回，大大的提升了worker处理并发请求的能力，唯一的影响是，如果多个task进程的消费能力更不上worker的投递速度也会影响worker的处理能力，所以需要做取舍 具体的消息队列生成在task进程中执行 task进程启用了协程模式，投递的每个任务都默认创建一个协程 12345use Task\\Task;/*** @var LogicPush*/Task::deliver(LogicPush::class,&quot;pushMids&quot;,[(int)$arg[&quot;op&quot;],$arg[&quot;mids&quot;],$arg[&quot;msg&quot;]]); 相关异步任务 存放在命名空间App\\Task下 相关优化容器化单个请求流程执行的生命周期会调用生成多个对象，多达10多个。并发大的情况下GC 几乎会首先挂掉，而且会耗时等待，所以new对象也有优化的空间 项目在初始化也就是主进程启动期间就扫描相关代码，有注解的就进行收集，然后实例化到容器container中，以后再多次使用的时候直接复用代码，而无需多次new对象，大大节省空间和时间，如下图为创建一个协程去执行任务，相关的对象都从容器中获取1234567891011121314Co::create(function ()use($op,$mids,$msg)&#123; /** @var RedisDao $servers */ $servers = \\container()-&gt;get(RedisDao::class)-&gt;getKeysByMids($mids); $keys = []; foreach($servers as $key =&gt; $server)&#123; $keys[$server][] = $key; &#125; foreach($keys as $server =&gt; $key)&#123; //丢到队列里去操做，让job去处理 \\container()-&gt;get(QueueDao::class)-&gt;pushMsg($op,$server,$key,$msg); &#125;&#125;,true);//第二个参数为true 表示使用Context::waitGroup() 等待任务执行完成 如上图所示可以调用组件提供的多个方法获取容器对象 container()-&gt;get(class) bean(class) 两种都可以获取容器对象， 提高并发性能即使将主要的耗时任务放到task进程中执行，worker进程中依然会有少量的等待时间，现在采取的方式，是请求到来时获取数据后，直接回复结束当前连接，然后在继续执行任务，这样就不用等到投递task任务后再结束当前连接，大大提高并发能力，虽然可能耗时性能没有发生太大的改变，但是并发能力大大的提升。如下所示： 123456789101112131415161718192021/** * @return \\Core\\Http\\Response\\Response|static */public function mids()&#123; Context::get()-&gt;getResponse()-&gt;end(); $post = Context::get()-&gt;getRequest()-&gt;input(); if(empty($post[&quot;operation&quot;]) || empty($post[&quot;mids&quot;]) ||empty($post[&quot;msg&quot;]))&#123; return $this-&gt;error(&quot;缺少参数&quot;); &#125; $arg = [ &quot;op&quot; =&gt; $post[&quot;operation&quot;], &quot;mids&quot; =&gt; is_array($post[&quot;mids&quot;])?$post[&quot;mids&quot;]:[$post[&quot;mids&quot;]], &quot;msg&quot; =&gt; $post[&quot;msg&quot;] ]; Log::debug(&quot;push mids post data:&quot;.json_encode($arg)); /** * @var LogicPush */ Task::deliver(LogicPush::class,&quot;pushMids&quot;,[(int)$arg[&quot;op&quot;],$arg[&quot;mids&quot;],$arg[&quot;msg&quot;]]);&#125; 如上图直接使用Context::get()-&gt;getResponse()-&gt;end();通过协程上下文获取reponse对象直接结束当前连接，然后在继续执行当前任务，并释放内存","tags":[{"name":"php","slug":"php","permalink":"http://blog.huido.site/tags/php/"},{"name":"swoole","slug":"swoole","permalink":"http://blog.huido.site/tags/swoole/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://blog.huido.site/tags/rabbitmq/"}],"categories":[{"name":"im-cloud","slug":"im-cloud","permalink":"http://blog.huido.site/categories/im-cloud/"},{"name":"2.底层实现","slug":"im-cloud/2-底层实现","permalink":"http://blog.huido.site/categories/im-cloud/2-底层实现/"}]},{"title":"安装部署","date":"2017-10-25T13:28:59.000Z","path":"wiki/im-cloud/1.前言/1.安装部署/","text":"im-cloud 分布式中间件的安装部署 github:http://github.com/brewlin/im-cloud im-cloud 基于swoole 原生协程构建分布式推送中间件 im-cloud 分布式中间件的安装部署 im-cloud &lt;&gt; goim 分布式中间件并发压测对比 im-cloud分布式中间件分析(一)-通讯协议 im-cloud分布式中间件分析(二)-cloud节点实现 im-cloud分布式中间件分析(三)-job节点实现 im-cloud分布式中间件分析(四)-logic节点实现 安装方式主要提供 docker单节点部署 docker-compose自动化编排部署 手动部署 三种方式部署环境 一、docker部署 基础镜像足够小 不用担心 base image+php7.2+swoole 4 才75M docker-compose networknamespace 为host模式，所以需要注意本地端口冲突的问题,也可以根据自己的环境更改compose.yml配置 1.docker 单独部署 镜像 consul redis 多进程版本镜像 brewlin/cloud-m brewlin/job-m brewlin/logic-m 单进程协程版镜像 brewlin/cloud-s brewlin/job-s brewlin/logic-s 启动consul 1docker run --network host consul 启动redis 1docker run --network host redis 启动cloud节点 123docker run --network host brewlin/cloud-mordocker run --network host brewlin/cloud-s 启动job节点 123docker run --network host brewlin/job-mordocker run --network host brewlin/job-s 启动logic节点 123docker run --network host brewlin/logic-mordocker run --network host brewlin/logic-s 2.docker-compose 编排服务1234git clone http://github.com/brewlin/im-cloudcd im-cloud//默认多进程版本docker-compose up 二、手动部署help process status 环境要求 swoole 4 + php 7.2 + console rabbitmq redis1.安装依赖make脚本使用composer自动install相关组件12cd path/im-cloudmake install 2.启动cloud节点12cd path/im-cloud/app/cloudphp bin/app --start --d --log=true --debug 3.启动logic节点12cd path/im-cloud/app/logic;php bin/app --start --d --log=true --debug 4.启动job节点12cd path/im-cloud/app/job;php bin/app --start --d --log=true --debug @makefile自动工具1234cd im-cloud;make startmake stopmake restart 5.安装启动consul1docker run --network -d consul 6.安装rabbitmq1docker run --network -d rabbitmq 三、测试 1.使用js sdk 提供的demo 注册到cloud 2.post http://host:9600/im/push/mids?mids=123&amp;operation=9&amp;msg=pushtest 进行单点推送","tags":[{"name":"php","slug":"php","permalink":"http://blog.huido.site/tags/php/"},{"name":"swoole","slug":"swoole","permalink":"http://blog.huido.site/tags/swoole/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://blog.huido.site/tags/rabbitmq/"}],"categories":[{"name":"im-cloud","slug":"im-cloud","permalink":"http://blog.huido.site/categories/im-cloud/"},{"name":"1.前言","slug":"im-cloud/1-前言","permalink":"http://blog.huido.site/categories/im-cloud/1-前言/"}]},{"title":"通讯协议","date":"2017-10-25T13:28:59.000Z","path":"wiki/im-cloud/2.底层实现/2.通讯协议/","text":"通讯协议@heartbeat 心跳注意心跳是10s间隔，如果20s还未收到心跳则断开连接","tags":[{"name":"php","slug":"php","permalink":"http://blog.huido.site/tags/php/"},{"name":"swoole","slug":"swoole","permalink":"http://blog.huido.site/tags/swoole/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://blog.huido.site/tags/rabbitmq/"}],"categories":[{"name":"im-cloud","slug":"im-cloud","permalink":"http://blog.huido.site/categories/im-cloud/"},{"name":"2.底层实现","slug":"im-cloud/2-底层实现","permalink":"http://blog.huido.site/categories/im-cloud/2-底层实现/"}]},{"title":"im-cloud","date":"2017-10-25T13:28:59.000Z","path":"wiki/im-cloud/2.底层实现/1.im-cloud/","text":"im-cloud 基于swoole 原生协程构建分布式推送中间件一、概述 基于swoole原生协程构建商业化即时推送im服务中间件,不进行业务处理，单独作为中间件使用，可弹性扩充节点增加性能处理.不依赖外部框架，核心代码为原生swoole构建的组件 借鉴goim(bilibili出品,生产级百万消息秒级推送)，使用swoole实现基于php的高性能分布式im中间件，提升高并发性能的推送 二、服务业务节点 cloud,job,logic 等节点都可以水平扩容 例如在消费能力不足时可以启动n个job节点提高并消费能力 启动多个cloud节点作为client客户端负载均衡，将多个websocket，tcp client分布到多个cloud节点中，提高cloud节点中心处理能力 logic 提供对外restapi 作为主要业务节点 高性能 协程化、水平扩容、分布式服务架构、接入服务治理 @cloudcloud 作为中心服务节点 grpc-server 节点，对外接收TCP、Websocket客户端进行长连接,可以水平扩容至多个节点 并注册到服务中心，例如consul。每个cloud节点维护自己的客户端 @jobjob 节点作为消费节点 消费队列数据 然后进行grpc 和cloud服务进行通讯 进行 push push room broadcast,作为节点中间件，消费kafaka，rockermq。。。之类，可以扩展多个节点提高并发消费能力 @logiclogic 节点 提供rest api接口，作为生产节点 和 grpc客户端,可写入队列作为生产者，也可以扩展自己的业务进行grpc直接调用cloud节点中心进行推送 三、组件依赖包 package 服务间配置独立，使用composer进行依赖管理，进行composer组件化开发 im-core 为核心基础组件，底层设计借鉴 swoft源码设计 im-grpc 定义grpc接口规范composer包,使用protobuf构建,封装有连接池 im-discovery 服务发现注册组件，注册grpc-server，发现服务等封装 im-process 进程管理模块，可以注册启动自定义进程，并交由swoole master进程管理声明周期 im-queue 消息队列管理模块，提供消息队列接口，底层实现了连接池接口，无需管理连接，根据类型可以切换不同的消息队列(done rabbitmq,soon kafak) im-redis 封装了连接池版本的redis client im-task 异步任务组件，封装投递task进程任务的接口，目前仅支持投递worker-&gt;task,不支持自定义进程投递以及投递到自定义进程 四、数据流程im-cloud 连接流程图 im-cloud 数据流程图 im-cloud 业务流程","tags":[{"name":"php","slug":"php","permalink":"http://blog.huido.site/tags/php/"},{"name":"swoole","slug":"swoole","permalink":"http://blog.huido.site/tags/swoole/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://blog.huido.site/tags/rabbitmq/"}],"categories":[{"name":"im-cloud","slug":"im-cloud","permalink":"http://blog.huido.site/categories/im-cloud/"},{"name":"2.底层实现","slug":"im-cloud/2-底层实现","permalink":"http://blog.huido.site/categories/im-cloud/2-底层实现/"}]},{"title":"im-cloud 分布式推送中间件","date":"2017-10-25T13:28:59.000Z","path":"wiki/im-cloud/index/","text":"基于原生 swoole 全协程化构建 im-cloud中间件，多节点扩容 概述 基于swoole原生构建即时推送im分布式服务,不进行业务处理，单独作为中间件使用，可弹性扩充节点增加性能处理,业务demo:(todo) 高性能 水平扩容 分布式服务架构 接入服务治理 cloud 作为中心服务节点 grpc-server 节点，对外可以进行tcp、websocket 客户端进行长连接注册,可水平扩容至多个节点 并注册到服务中心 例如consul，每个cloud节点维护自己的客户端 job 节点作为消费节点 消费队列数据 然后进行grpc 和cloud服务进行通讯 进行 push push room broadcast,作为节点中间件，消费kafaka，rabbitmq。。。之类,可以通过配置切换消息队列类型 logic 节点 提供rest api接口，作为生产节点 和 grpc客户端,可写入队列作为生产者，也可以扩展自己的业务进行rpc直接调用center中心进行推送,客户端数据缓存至redis中，多个logic节点访问redis数据同步 cloud,job,logic 等节点可水平扩容多个节点增加并发处理 appm &amp; apps appm多进程版本(multi process coroutine) 测试和单元测试中 test version apps单进程全协程化server版本(single process coroutine) 分支apps 待官方实现http2协议,暂取消合并到master notice api 流程图im-cloud 连接流程图 im-cloud 数据流程图 im-cloud 业务流程 组件依赖 相关组件为纯swoole实现 @core (done) 核心架构@grpc (done) grpc包依赖 grpc-client连接池@discovery (done) 服务发现注册@process(done) 自定义进程管理器@redis(done) redis连接池@queue(done amqp,soon kafak) 消息队列连接池@memory(done)swoole 相关内存操作封装@task(done) 异步任务投递组件@cloud (test verion)@job (test version)@logic (test version)","tags":[{"name":"php","slug":"php","permalink":"http://blog.huido.site/tags/php/"},{"name":"swoole","slug":"swoole","permalink":"http://blog.huido.site/tags/swoole/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://blog.huido.site/tags/rabbitmq/"}],"categories":[{"name":"im-cloud","slug":"im-cloud","permalink":"http://blog.huido.site/categories/im-cloud/"}]},{"title":"微服务应用","date":"2017-10-24T13:28:59.000Z","path":"wiki/swoft-im/微服务应用/","text":"","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.huido.site/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://blog.huido.site/tags/Swoole/"},{"name":"IM","slug":"IM","permalink":"http://blog.huido.site/tags/IM/"}],"categories":[{"name":"swoft-im","slug":"swoft-im","permalink":"http://blog.huido.site/categories/swoft-im/"}]},{"title":"index","date":"2017-10-24T13:28:59.000Z","path":"wiki/net-protocol/index/","text":"net-protocol基于go 实现链路层、网络层、传输层、应用层 网络协议栈 ，使用虚拟网卡实现 @docs1相关md文档在cmd目录下，以及相关协议的demo测试 ./cmd/*.md @application 应用层 http docs websocket docs @transport 传输层 tcp docs udp docs port 端口机制 @network 网络层 icmp ipv4 ipv6 @link 链路层 arp docs ethernet @物理层 tun tap 虚拟网卡的实现 协议相关api1.应用层相关协议应用层暂时只实现了http、websocket等文本协议。都基于tcp、对tcp等进行二次封装 http api :http-api.md123456789http 协议报文GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protcol: chat, superchatSec-WebSocket-Version: 13 websocket api : websocket-api.md1234567891011121314151617181920websocket 数据帧报文 0 1 2 3 4 0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+ 2.传输层相关协议传输层实现了upd、tcp、灯协议，并实现了主要接口 tcp api:tcp-api.md 1234567891011121314151617181920 tcp 首部协议报文0 1 2 3 40 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source Port | Destination Port |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Sequence Number |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Acknowledgment Number |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Data | |U|A|P|R|S|F| || Offset| Reserved |R|C|S|S|Y|I| Window || | |G|K|H|T|N|N| |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Checksum | Urgent Pointer |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Options | Padding |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| data |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ udp-api:./udp-api.md1udp 协议报文 端口机制 3.网络层相关协议ip:ipv4-api.md123456789101112131415161718 ip头部协议报文0 1 2 3 40 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|Version| LHL | Type of Service | Total Length |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Identification(fragment Id) |Flags| Fragment Offset || 16 bits |R|D|M| 13 bits |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Time-To-Live | Protocol | Header Checksum || ttl(8 bits) | 8 bits | 16 bits |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source IP Address (32 bits) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Destination Ip Address (32 bits) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Options (*** bits) | Padding |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+","tags":[{"name":"Go","slug":"Go","permalink":"http://blog.huido.site/tags/Go/"},{"name":"Protocol","slug":"Protocol","permalink":"http://blog.huido.site/tags/Protocol/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"}]},{"title":"GO标准库和算法应用","date":"2017-10-24T13:28:59.000Z","path":"wiki/go-stl/index/","text":"go-stltodo..","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"algorithm","slug":"algorithm","permalink":"http://blog.huido.site/tags/algorithm/"}],"categories":[{"name":"go-stl","slug":"go-stl","permalink":"http://blog.huido.site/categories/go-stl/"}]},{"title":"Welcome Brewlin's Wiki Site","date":"2017-01-21T17:55:57.000Z","path":"wiki/index/","text":"@net-protocol基于go模拟内核协议栈 实现链路层、网络层、传输层、应用层 网络协议栈 ，使用虚拟网卡实现 @go-stlGolang Standard Template Library @im-cloud原生swoole4 全协程化分布式中间件、多节点扩容、多节点服务 @swoft-im基于swoft-cloud的微服务架构，最小化拆分粒度，PHP7、多进程、协程、异步任务、mysql连接池、redi连接池、rpc连接池、服务治理、服务注册与发现、Aop切面、全注解 http://chat.huido.site","tags":[],"categories":[]}]}