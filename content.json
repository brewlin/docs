{"pages":[{"title":"About","date":"2016-10-24T02:24:00.000Z","path":"about/index.html","text":"关于我自己关于编程背景图包业余爱好最后"},{"title":"Categories","date":"2019-10-22T10:38:59.833Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2019-10-22T10:38:59.833Z","path":"tags/index.html","text":""}],"posts":[{"title":"websocket算法","date":"2019-10-21T13:28:59.000Z","path":"wiki/net-protocol/2.应用层/4.websocket算法/","text":"websocket协议中的一些算法在分析 WebSocket 协议握手过程和数据帧格式过程中，我们讲到了一些算法，下面我们讲解下具体实现。 Sec-WebSocket-Accept的计算方法从上面的分析中，我们知道字段的值是通过固定字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11加上请求中Sec-WebSocket-Key字段的值，然后再对其结果通过 SHA1 哈希算法求出的结果。可以通过以下 golang 代码实现：1234567var keyGUID = []byte(\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\")func computeAcceptKey(challengeKey string) string &#123; h := sha1.New() h.Write([]byte(challengeKey)) h.Write(keyGUID) return base64.StdEncoding.EncodeToString(h.Sum(nil))&#125; 掩码处理浏览器发送给服务器的数据帧是经过掩码处理的，那怎么样对数据进行解码呢？以下是来自RFC6455文档的解释具体的流程是：将传输的数据按字节 byte 处理，同时将 Masking-key 代表的值也按字节处理。假如 data-byte-i 代表的是数据的第 i 个字节，那么 j = i MOD 4，然后从Maksing-key中(一共有 4 个字节）取出第 j 个字节 mask-key-byte-j，然后将 data-byte-i 和 mask-key-byte-j 代表的字节进行异或操作，取得结果就是最终的结果。该操作可以用如下 golang 代码实现：1234567func maskBytes(key [4]byte,pos int,b[]byte)int&#123; for i := range b&#123; b[i] ^= key[pos &amp; 3] pos++ &#125; return pos &amp; 3&#125; 注意以上的操作，pos &amp; 3这里代表的操作是pos%4,因为 a % (2 ^ n) 等价于 a &amp; (2^n -1),在这里使用按位与操作更加高效","tags":[{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"golang","slug":"golang","permalink":"http://blog.huido.site/tags/golang/"},{"name":"websocket","slug":"websocket","permalink":"http://blog.huido.site/tags/websocket/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"2.应用层","slug":"net-protocol/2-应用层","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/"}]},{"title":"websocket实现","date":"2019-10-21T13:28:59.000Z","path":"wiki/net-protocol/2.应用层/5.websocket实现/","text":"编写基本的httpserver启动一个基本的httpserver，提供两个接口，一个index返回主页，另一个是就是我们自定义的websocket协议接口@main.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package mainimport ( \"html/template\" \"log\" \"net/http\" \"http/websocket\")//websocket处理器func echo(w http.ResponseWriter, r *http.Request)&#123; //协议升级 c,err := websocket.Upgrade(w,r) if err != nil &#123; log.Print(\"Upgrade error:\",err) return &#125; defer c.Close() //循环处理数据，接受数据，然后返回 for &#123; message,err := c.ReadData() if err != nil &#123; log.Println(\"read:\",err) break &#125; log.Printf(\"recv:%s\",message) c.SendData(message) &#125;&#125;//indexfunc home(w http.ResponseWriter, r *http.Request)&#123; homeTemplate.Execute(w,\"ws://\"+r.Host+\"/echo\")&#125;func main()&#123; log.SetFlags(0) http.HandleFunc(\"/echo\",echo) http.HandleFunc(\"/\",home) log.Fatal(http.ListenAndServe(\"0.0.0.0:8000\",nil))&#125;var homeTemplate = template.Must(template.New(\"\").Parse(`&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;script&gt;window.addEventListener(\"load\", function(evt) &#123; var output = document.getElementById(\"output\"); var input = document.getElementById(\"input\"); var ws; var print = function(message) &#123; var d = document.createElement(\"div\"); d.innerHTML = message; output.appendChild(d); &#125;; document.getElementById(\"open\").onclick = function(evt) &#123; if (ws) &#123; return false; &#125; ws = new WebSocket(\"&#123;&#123;.&#125;&#125;\"); ws.onopen = function(evt) &#123; print(\"OPEN\"); &#125; ws.onclose = function(evt) &#123; print(\"CLOSE\"); ws = null; &#125; ws.onmessage = function(evt) &#123; print(\"RESPONSE: \" + evt.data); &#125; ws.onerror = function(evt) &#123; print(\"ERROR: \" + evt.data); &#125; return false; &#125;; document.getElementById(\"send\").onclick = function(evt) &#123; if (!ws) &#123; return false; &#125; print(\"SEND: \" + input.value); ws.send(input.value); return false; &#125;; document.getElementById(\"close\").onclick = function(evt) &#123; if (!ws) &#123; return false; &#125; ws.close(); return false; &#125;;&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;td valign=\"top\" width=\"50%\"&gt;&lt;p&gt;点击 \"Open\" 开始一个新的WebSocket链接,“Send\" 将内容发送到服务器，\"Close\" 将关闭链接。&lt;p&gt;&lt;form&gt;&lt;button id=\"open\"&gt;Open&lt;/button&gt;&lt;button id=\"close\"&gt;Close&lt;/button&gt;&lt;p&gt;&lt;input id=\"input\" type=\"text\" value=\"hello world!\"&gt;&lt;button id=\"send\"&gt;Send&lt;/button&gt;&lt;/form&gt;&lt;/td&gt;&lt;td valign=\"top\" width=\"50%\"&gt;&lt;div id=\"output\"&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;`)) index 返回我们自定义的一段html代码，echo 接口进行升级我们的websocket页面如下 自定义的webscoket upgrade进行升级根据之前的协议分析，我知道握手的过程其实就是检查 HTTP 请求头部字段的过程，值得注意的一点就是需要针对客户端发送的 Sec-WebSocket-Key 生成一个正确的 Sec-WebSocket-Accept 只。关于生成的 Sec-WebSocket-Accpet 的实现，可以参考之前的分析。握手过程的具体代码如下：@upgrade.go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package websocketimport( \"net/http\" \"net\" \"errors\" \"log\" \"bufio\")func Upgrade(w http.ResponseWriter,r *http.Request)(c *Conn,err error)&#123; //是否是Get方法 if r.Method != \"GET\" &#123; http.Error(w,http.StatusText(http.StatusMethodNotAllowed),http.StatusMethodNotAllowed) return nil,errors.New(\"websocket:method not GET\") &#125; //检查 Sec-WebSocket-Version 版本 if values := r.Header[\"Sec-Websocket-Version\"];len(values) == 0 || values[0] != \"13\" &#123; http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest) return nil,errors.New(\"websocket:version != 13\") &#125; //检查Connection 和 Upgrade if !tokenListContainsValue(r.Header,\"Connection\",\"upgrade\") &#123; http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest) return nil,errors.New(\"websocket:could not find connection header with token 'upgrade'\") &#125; if !tokenListContainsValue(r.Header,\"Upgrade\",\"websocket\") &#123; http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest) return nil,errors.New(\"websocket:could not find connection header with token 'websocket'\") &#125; //计算Sec-Websocket-Accept的值 challengeKey := r.Header.Get(\"Sec-Websocket-Key\") if challengeKey == \"\" &#123; http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest) return nil,errors.New(\"websocket:key missing or blank\") &#125; var ( netConn net.Conn br *bufio.Reader ) h,ok := w.(http.Hijacker) if !ok &#123; http.Error(w,http.StatusText(http.StatusInternalServerError),http.StatusInternalServerError) return nil,errors.New(\"websocket:response dose not implement http.Hijacker\") &#125; var rw *bufio.ReadWriter //接管当前tcp连接，阻止内置http接管连接 netConn,rw,err = h.Hijack() if err != nil &#123; http.Error(w,http.StatusText(http.StatusInternalServerError),http.StatusInternalServerError) return nil,err &#125; br = rw.Reader if br.Buffered() &gt; 0 &#123; netConn.Close() return nil,errors.New(\"websocket:client send data before hanshake is complete\") &#125; // 构造握手成功后返回的 response p := []byte&#123;&#125; p = append(p, \"HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: \"...) p = append(p, computeAcceptKey(challengeKey)...) p = append(p, \"\\r\\n\\r\\n\"...) //返回repson 但不关闭连接 if _,err = netConn.Write(p);err != nil &#123; netConn.Close() return nil,err &#125; //升级为websocket log.Println(\"Upgrade http to websocket successfully\") conn := newConn(netConn) return conn,nil&#125; 握手过程的代码比较直观，就不多做解释了。到这里 WebSocket 的实现就基本完成了，可以看到有了之前的各种约定，我们实现 WebSocket 协议也是比较简单的。封装的websocket结构体和对应的方法@conn.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168package websocketimport ( \"fmt\" \"encoding/binary\" \"log\" \"errors\" \"net\")const ( /* * 是否是最后一个数据帧 * Fin Rsv1 Rsv2 Rsv3 Opcode * 1 0 0 0 0 0 0 0 =&gt; 128 */ finalBit = 1 &lt;&lt; 7 /* * 是否需要掩码处理 * Mask payload-len 第一位mask表示是否需要进行掩码处理 后面 * 7位表示数据包长度 1.0-125 表示长度 2.126 后面需要扩展2 字节 16bit * 3.127则扩展8bit * 1 0 0 0 0 0 0 0 =&gt; 128 */ maskBit = 1 &lt;&lt; 7 /* * 文本帧类型 * 0 0 0 0 0 0 0 1 */ TextMessage = 1 /* * 关闭数据帧类型 * 0 0 0 0 1 0 0 0 */ CloseMessage = 8)//websocket 连接type Conn struct &#123; writeBuf []byte maskKey [4]byte conn net.Conn&#125;func newConn(conn net.Conn)*Conn&#123; return &amp;Conn&#123;conn:conn&#125;&#125;func (c *Conn)Close()&#123; c.conn.Close()&#125;//发送数据func (c *Conn)SendData(data []byte)&#123; length := len(data) c.writeBuf = make([]byte,10 + length) //数据开始和结束位置 payloadStart := 2 /** *数据帧的第一个字节，不支持且只能发送文本类型数据 *finalBit 1 0 0 0 0 0 0 0 * | *Text 0 0 0 0 0 0 0 1 * =&gt; 1 0 0 0 0 0 0 1 */ c.writeBuf[0] = byte(TextMessage) | finalBit fmt.Printf(\"1 bit:%b\\n\",c.writeBuf[0]) //数据帧第二个字节，服务器发送的数据不需要进行掩码处理 switch&#123; //大于2字节的长度 case length &gt;= 1 &lt;&lt; 16 ://65536 //c.writeBuf[1] = byte(0x00) | 127 // 127 c.writeBuf[1] = byte(127) // 127 //大端写入64位 binary.BigEndian.PutUint64(c.writeBuf[payloadStart:],uint64(length)) //需要8byte来存储数据长度 payloadStart += 8 case length &gt; 125: //c.writeBuf[1] = byte(0x00) | 126 c.writeBuf[1] = byte(126) binary.BigEndian.PutUint16(c.writeBuf[payloadStart:],uint16(length)) payloadStart += 2 default: //c.writeBuf[1] = byte(0x00) | byte(length) c.writeBuf[1] = byte(length) &#125; fmt.Printf(\"2 bit:%b\\n\",c.writeBuf[1]) copy(c.writeBuf[payloadStart:],data[:]) c.conn.Write(c.writeBuf[:payloadStart+length])&#125;//读取数据func (c *Conn)ReadData()(data []byte,err error)&#123; var b [8]byte //读取数据帧的前两个字节 if _,err := c.conn.Read(b[:2]); err != nil &#123; return nil,err &#125; //开始解析第一个字节 是否还有后续数据帧 final := b[0] &amp; finalBit != 0 fmt.Printf(\"read data 1 bit :%b\\n\",b[0]) //不支持数据分片 if !final &#123; log.Println(\"Recived fragemented frame,not support\") return nil,errors.New(\"not suppeort fragmented message\") &#125; //数据帧类型 /* *1 0 0 0 0 0 0 1 * &amp; *0 0 0 0 1 1 1 1 *0 0 0 0 0 0 0 1 * =&gt; 1 这样就可以直接获取到类型了 */ frameType := int(b[0] &amp; 0xf) //如果 关闭类型，则关闭连接 if frameType == CloseMessage &#123; c.conn.Close() log.Println(\"Recived closed message,connection will be closed\") return nil,errors.New(\"recived closed message\") &#125; //只实现了文本格式的传输,编码utf-8 if frameType != TextMessage &#123; return nil,errors.New(\"only support text message\") &#125; //检查数据帧是否被掩码处理 //maskBit =&gt; 1 0 0 0 0 0 0 0 任何与他 要么为0 要么为 128 mask := b[1] &amp; maskBit != 0 //数据长度 payloadLen := int64(b[1] &amp; 0x7F)//0 1 1 1 1 1 1 1 1 127 dataLen := int64(payloadLen) //根据payload length 判断数据的真实长度 switch payloadLen &#123; case 126://扩展2字节 if _,err := c.conn.Read(b[:2]);err != nil &#123; return nil,err &#125; //获取扩展二字节的真实数据长度 dataLen = int64(binary.BigEndian.Uint16(b[:2])) case 127 : if _,err := c.conn.Read(b[:8]);err != nil &#123; return nil,err &#125; dataLen = int64(binary.BigEndian.Uint64(b[:8])) &#125; log.Printf(\"Read data length :%d,payload length %d\",payloadLen,dataLen) //读取mask key if mask &#123;//如果需要掩码处理的话 需要取出key //maskKey 是 4 字节 32位 if _,err := c.conn.Read(c.maskKey[:]);err != nil &#123; return nil ,err &#125; &#125; //读取数据内容 p := make([]byte,dataLen) if _,err := c.conn.Read(p);err != nil &#123; return nil,err &#125; if mask &#123; maskBytes(c.maskKey,p)//进行解码 &#125; return p,nil&#125; http 头部检查12345678910111213141516171819202122232425262728293031323334353637import ( \"crypto/sha1\" \"encoding/base64\" \"strings\" \"net/http\")var KeyGUID = []byte(\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\")//握手阶段使用 加密key返回 进行握手func computeAcceptKey(challengeKey string)string&#123; h := sha1.New() h.Write([]byte(challengeKey)) h.Write(KeyGUID) return base64.StdEncoding.EncodeToString(h.Sum(nil))&#125;//解码func maskBytes(key [4]byte,b []byte)&#123; pos := 0 for i := range b &#123; b[i] ^= key[pos &amp; 3] pos ++ &#125;&#125;// 检查http 头部字段中是否包含指定的值func tokenListContainsValue(header http.Header, name string, value string)bool&#123; for _,v := range header[name] &#123; for _, s := range strings.Split(v,\",\")&#123; if strings.EqualFold(value,strings.TrimSpace(s)) &#123; return true &#125; &#125; &#125; return false&#125;","tags":[{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"golang","slug":"golang","permalink":"http://blog.huido.site/tags/golang/"},{"name":"websocket","slug":"websocket","permalink":"http://blog.huido.site/tags/websocket/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"2.应用层","slug":"net-protocol/2-应用层","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/"}]},{"title":"websocket协议解析","date":"2019-10-21T13:28:59.000Z","path":"wiki/net-protocol/2.应用层/3.websocket协议解析/","text":"websocket 协议报文websocket协议也是基于tcp协议，和http不同的是，tcp接受的数据包为二进制帧，而http为字符串数据包。并且websocket协议在连接阶段会触发一个http请求进行websocket协议校验。校验成功后才会接管tcp通讯流程不会断开该http连接 1234567891011121314151617181920websocket 数据帧报文 0 1 2 3 4 0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+ WebSocket协议详解WebSocket 协议解决了浏览器和服务器之间的全双工通信问题。在 WebSocket 出现之前，浏览器如果需要从服务器及时获得更新，则需要不停的对服务器主动发起请求，也就是 Web 中常用的poll技术。这样的操作非常低效，这是因为每发起一次新的 HTTP 请求，就需要单独开启一个新的 TCP 链接，同时 HTTP 协议本身也是一种开销非常大的协议。为了解决这些问题，所以出现了 WebSocket 协议。WebSocket 使得浏览器和服务器之间能通过一个持久的 TCP 链接就能完成数据的双向通信。关于 WebSocket 的 RFC 提案，可以参看RFC6455。 WebSocket 和 HTTP 协议一般情况下都工作在浏览器中，但 WebSocket 是一种完全不同于 HTTP 的协议。尽管，浏览器需要通过 HTTP 协议的GET请求，将 HTTP 协议升级为 WebSocket 协议。升级的过程被称为握手(handshake)。当浏览器和服务器成功握手后，则可以开始根据 WebSocket 定义的通信帧格式开始通信了。像其他各种协议一样，WebSocket 协议的通信帧也分为控制数据帧和普通数据帧，前者用于控制 WebSocket 链接状态，后者用于承载数据。下面我们将一一分析 WebSocket 协议的握手过程以及通信帧格式。 一、websocket握手握手的过程也就是将HTTP协议升级为WebSocket协议的过程，握手开始首先由浏览器端发送一个GET请求，该请求的HTTP头部信息如下:12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protcol: chat, superchatSec-WebSocket-Version: 13 当服务器端，成功验证了以上信息后，则会返回一个形如以下的响应：12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat 可以看到，浏览器发送端HTTP请求中，增加了一些新端字段，其作用如下所示： Upgrade: 规定必需的字段，其值必需为 websocket, 如果不是则握手失败； Connection: 规定必需的字段，值必需为 Upgrade, 如果不是则握手失败；Sec-WebSocket-Key: 必需字段，一个随机的字符串；Sec-WebSocket-Protocol: 可选字段，可以用于标识应用层的协议；Sec-WebSocket-Version: 必需字段，代表了 WebSocket 协议版本，值必需是 13, 否则握手失败；返回端响应中，如果握手成功会返回状态码101的HTTP响应，同时其他字段说明如下： Upgrade: 规定必需的字段，其值必需为 websocket, 如果不是则握手失败； Connection: 规定必需的字段，值必需为 Upgrade, 如果不是则握手失败； Sec-WebSocket-Accept: 规定必需的字段，该字段的值是通过固定字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11加上请求中Sec-WebSocket-Key字段的值，然后再对其结果通过 SHA1 哈希算法求出的结果。 Sec-WebSocket-Protocol: 对应于请求中的 Sec-WebSocket-Protocol 字段；当浏览器和服务端成功握手后，就可以传递数据了，传送数据是按照WebSocket的数据格式生成的二、WebSocket协议数据帧数据帧的定义类似与TCP/IP的格式定义，具体看下图：123456789101112131415161718 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len | Extended payload length ||I|S|S|S| (4) |A| (7) | (16/64) ||N|V|V|V| |S| | (if payload len==126/127) || |1|2|3| |K| | |+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +| Extended payload length continued, if payload len == 127 |+ - - - - - - - - - - - - - - - +-------------------------------+| |Masking-key, if MASK set to 1 |+-------------------------------+-------------------------------+| Masking-key (continued) | Payload Data |+-------------------------------- - - - - - - - - - - - - - - - +: Payload Data continued ... :+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +| Payload Data continued ... |+---------------------------------------------------------------+ 以上这张图，一行代表32bit（位），也就是4bytes（字节），总体上包含两份，帧头部和数据内容。每个从WebSocket链接中接受到的数据帧，都要按照以上格式进行解析，这样才能知道该数据帧是用于控制的还是用于传送数据的，关于以上数据帧的各个比特位的解释如下： FIN:1bit,当该比特位值为%x0时，表示后面还有更多的数据帧，%x1时表示这是最后一个数据帧； RSV1,RSV2,RSV3:各占1个比特位。一般情况下全为0，当客户端、服务端协商采用WebSocket扩展时，这三个标识位可以非0，且值当含义由扩展进行定义，如果出现非0当值，且没有采用WebSocket扩展，则链接出错 opcode:4 bit,用于表明数据帧当类型，一共可以表示16种帧类型，如下所示： %x0:表示这是一个分片当帧，它属于前面帧当后续帧； %x1:表示该数据帧携带的数据类型是文本类型，且编码utf-8 %x2 : 表示携带的是二进制数据； %x3-7 : 保留未使用； %x8 : 表示该帧用于关闭 WebSocket 链接； %x9 : 表示该帧代表了 ping 操作； %xA : 表示该帧代表了 pong 回应； %xB-F : 保留未使用； MASK:1 bit,%x0表示数据帧没有经过掩码计算，而%x1则表示数据帧已经经过掩码计算，得到真正当数据需要解码，一般情况下，只有浏览器发送给服务端当数据帧才需要进行掩码计算； Payload len:7 bit,表示了数据帧携带当数据长度，7 bit 的值根据三种情况，帧的解析有所不同： %x0 - 7D : 也就是从 0 到 125，表示数据长度, 数据总长度也就是 7 bit 代表的长度； %x7E : 7 bit 的值是 126 时，则后续的 2 个字节（16 bit)表示的一个 16 位无符号数，这个数用来表示数据的长度； %x7F : 7 bit 的值是 127 时，则后续的 8 个字节（64 bit)表示的一个 64 位无符号数，这个数用来表示数据的长度； Masking-key: 32 bit, 表示了用于解码的 key，只有当 MASK 比特位的值为 %x1 是，才有该数据； Payload Data: 余下的比特位用于存储具体的数据；通过以上分析可以看出，WebSocket 协议数据帧的最大头部为 2 + 8 + 4 = 14 bytes 也就是 14 个字节。同时我们要实现 WebSocket 协议，最主要的工作就是实现对数据帧的解析。","tags":[{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"golang","slug":"golang","permalink":"http://blog.huido.site/tags/golang/"},{"name":"websocket","slug":"websocket","permalink":"http://blog.huido.site/tags/websocket/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"2.应用层","slug":"net-protocol/2-应用层","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/"}]},{"title":"http协议解析","date":"2019-10-18T13:28:59.000Z","path":"wiki/net-protocol/4.网络层/2.http协议解析/","text":"http 报文协议","tags":[{"name":"Go","slug":"Go","permalink":"http://blog.huido.site/tags/Go/"},{"name":"Protocol","slug":"Protocol","permalink":"http://blog.huido.site/tags/Protocol/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"4.网络层","slug":"net-protocol/4-网络层","permalink":"http://blog.huido.site/categories/net-protocol/4-网络层/"}]},{"title":"http协议解析","date":"2019-10-18T13:28:59.000Z","path":"wiki/net-protocol/2.应用层/2.http协议解析/","text":"http协议报文这是一个典型的http请求的报文样例，可以看出是一个websocket升级前的http请求。该字符报文完全基于tcp协议，协议报文内容为tcp数据包，也就是tcp进行recv调用获取的数据内容。如下报文表示已经接受完http报文数据。 解析http报文的源码为application/http/request.go中123456789http 协议报文GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protcol: chat, superchatSec-WebSocket-Version: 13 @请求方法解析tcp数据包第一行数据，遇到空格就拆分，则获取到请求方法 @uri解析tcp数据包第一行数据，遇到空格就拆分，则获取到uri路径 @header头部接下来都是一些头部信息的keyvalue，每次读取一行，然后根据:分隔符进行拆分，获取header头部请求键值对","tags":[{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"golang","slug":"golang","permalink":"http://blog.huido.site/tags/golang/"},{"name":"http","slug":"http","permalink":"http://blog.huido.site/tags/http/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"2.应用层","slug":"net-protocol/2-应用层","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/"}]},{"title":"http协议解析","date":"2019-10-18T13:28:59.000Z","path":"wiki/net-protocol/5.链路层/2.http协议解析/","text":"http 报文协议","tags":[{"name":"Go","slug":"Go","permalink":"http://blog.huido.site/tags/Go/"},{"name":"Protocol","slug":"Protocol","permalink":"http://blog.huido.site/tags/Protocol/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"5.链路层","slug":"net-protocol/5-链路层","permalink":"http://blog.huido.site/categories/net-protocol/5-链路层/"}]},{"title":"http协议解析","date":"2019-10-18T13:28:59.000Z","path":"wiki/net-protocol/6.物理层/2.http协议解析/","text":"http 报文协议","tags":[{"name":"Go","slug":"Go","permalink":"http://blog.huido.site/tags/Go/"},{"name":"Protocol","slug":"Protocol","permalink":"http://blog.huido.site/tags/Protocol/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"6.物理层","slug":"net-protocol/6-物理层","permalink":"http://blog.huido.site/categories/net-protocol/6-物理层/"}]},{"title":"应用层前世今生","date":"2019-10-17T13:28:59.000Z","path":"wiki/net-protocol/2.应用层/1.应用层前世今生/","text":"应用层的作用对传输层协议对再次封装，例如对tcp进行封装对http、websocket协议等，以及http3协议基于udp协议的封装等 http协议报文123456789http 协议报文GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protcol: chat, superchatSec-WebSocket-Version: 13 websocket 协议报文1234567891011121314151617181920websocket 数据帧报文 0 1 2 3 4 0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"2.应用层","slug":"net-protocol/2-应用层","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/"}]},{"title":"应用层前世今生","date":"2019-10-17T13:28:59.000Z","path":"wiki/net-protocol/3.传输层/1.应用层前世今生/","text":"应用层的作用对传输层协议对再次封装，例如对tcp进行封装对http、websocket协议等，以及http3协议基于udp协议的封装等","tags":[{"name":"Go","slug":"Go","permalink":"http://blog.huido.site/tags/Go/"},{"name":"Protocol","slug":"Protocol","permalink":"http://blog.huido.site/tags/Protocol/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"3.传输层","slug":"net-protocol/3-传输层","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/"}]},{"title":"应用层前世今生","date":"2019-10-17T13:28:59.000Z","path":"wiki/net-protocol/5.链路层/1.应用层前世今生/","text":"应用层的作用对传输层协议对再次封装，例如对tcp进行封装对http、websocket协议等，以及http3协议基于udp协议的封装等","tags":[{"name":"Go","slug":"Go","permalink":"http://blog.huido.site/tags/Go/"},{"name":"Protocol","slug":"Protocol","permalink":"http://blog.huido.site/tags/Protocol/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"5.链路层","slug":"net-protocol/5-链路层","permalink":"http://blog.huido.site/categories/net-protocol/5-链路层/"}]},{"title":"应用层前世今生","date":"2019-10-17T13:28:59.000Z","path":"wiki/net-protocol/6.物理层/1.应用层前世今生/","text":"应用层的作用对传输层协议对再次封装，例如对tcp进行封装对http、websocket协议等，以及http3协议基于udp协议的封装等","tags":[{"name":"Go","slug":"Go","permalink":"http://blog.huido.site/tags/Go/"},{"name":"Protocol","slug":"Protocol","permalink":"http://blog.huido.site/tags/Protocol/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"6.物理层","slug":"net-protocol/6-物理层","permalink":"http://blog.huido.site/categories/net-protocol/6-物理层/"}]},{"title":"快速开始","date":"2019-10-16T13:28:59.000Z","path":"wiki/net-protocol/1.前言/1.快速开始/","text":"demo案例cmd:该目录下为各协议的实现demo，提供api调用实现以及测试","tags":[{"name":"Go","slug":"Go","permalink":"http://blog.huido.site/tags/Go/"},{"name":"Protocol","slug":"Protocol","permalink":"http://blog.huido.site/tags/Protocol/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"1.前言","slug":"net-protocol/1-前言","permalink":"http://blog.huido.site/categories/net-protocol/1-前言/"}]},{"title":"readme","date":"2017-10-24T13:28:59.000Z","path":"wiki/net-protocol/readme/","text":"net-protocol基于go 实现链路层、网络层、传输层、应用层 网络协议栈 ，使用虚拟网卡实现 @docs1相关md文档在cmd目录下，以及相关协议的demo测试 ./cmd/*.md @application 应用层 http docs websocket docs @transport 传输层 tcp docs udp docs port 端口机制 @network 网络层 icmp ipv4 ipv6 @link 链路层 arp docs ethernet @物理层 tun tap 虚拟网卡的实现 协议相关api1.应用层相关协议应用层暂时只实现了http、websocket等文本协议。都基于tcp、对tcp等进行二次封装 http api :http-api.md123456789http 协议报文GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protcol: chat, superchatSec-WebSocket-Version: 13 websocket api : websocket-api.md1234567891011121314151617181920websocket 数据帧报文 0 1 2 3 4 0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+ 2.传输层相关协议传输层实现了upd、tcp、灯协议，并实现了主要接口 tcp api:tcp-api.md 1234567891011121314151617181920 tcp 首部协议报文0 1 2 3 40 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source Port | Destination Port |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Sequence Number |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Acknowledgment Number |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Data | |U|A|P|R|S|F| || Offset| Reserved |R|C|S|S|Y|I| Window || | |G|K|H|T|N|N| |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Checksum | Urgent Pointer |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Options | Padding |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| data |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ udp-api:./udp-api.md1udp 协议报文 端口机制 3.网络层相关协议ip:ipv4-api.md123456789101112131415161718 ip头部协议报文0 1 2 3 40 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|Version| LHL | Type of Service | Total Length |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Identification(fragment Id) |Flags| Fragment Offset || 16 bits |R|D|M| 13 bits |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Time-To-Live | Protocol | Header Checksum || ttl(8 bits) | 8 bits | 16 bits |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source IP Address (32 bits) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Destination Ip Address (32 bits) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Options (*** bits) | Padding |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+","tags":[{"name":"Go","slug":"Go","permalink":"http://blog.huido.site/tags/Go/"},{"name":"Protocol","slug":"Protocol","permalink":"http://blog.huido.site/tags/Protocol/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"}]},{"title":"微服务应用","date":"2017-10-24T13:28:59.000Z","path":"wiki/swoft-im/微服务应用/","text":"","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.huido.site/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://blog.huido.site/tags/Swoole/"},{"name":"IM","slug":"IM","permalink":"http://blog.huido.site/tags/IM/"}],"categories":[{"name":"swoft-im","slug":"swoft-im","permalink":"http://blog.huido.site/categories/swoft-im/"}]},{"title":"GO标准库和算法应用","date":"2017-10-24T13:28:59.000Z","path":"wiki/go-stl/GO标准库和算法应用/","text":"go-stltodo..","tags":[{"name":"Go","slug":"Go","permalink":"http://blog.huido.site/tags/Go/"}],"categories":[{"name":"go-stl","slug":"go-stl","permalink":"http://blog.huido.site/categories/go-stl/"}]},{"title":"分布式推送中间件","date":"2017-10-24T13:28:59.000Z","path":"wiki/im-cloud/分布式推送中间件/","text":"im-cloud","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.huido.site/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://blog.huido.site/tags/Swoole/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://blog.huido.site/tags/RabbitMQ/"}],"categories":[{"name":"im-cloud","slug":"im-cloud","permalink":"http://blog.huido.site/categories/im-cloud/"}]},{"title":"Welcome Brewlin's Wiki Site","date":"2017-01-21T17:55:57.000Z","path":"wiki/index/","text":"@net-protocol基于go模拟内核协议栈 实现链路层、网络层、传输层、应用层 网络协议栈 ，使用虚拟网卡实现 @go-stlGolang Standard Template Library @im-cloud原生swoole4 全协程化分布式中间件、多节点扩容、多节点服务 @swoft-im基于swoft-cloud的微服务架构，最小化拆分粒度，PHP7、多进程、协程、异步任务、mysql连接池、redi连接池、rpc连接池、服务治理、服务注册与发现、Aop切面、全注解 http://chat.huido.site","tags":[],"categories":[]}]}