{"pages":[{"title":"About","date":"2016-10-24T02:24:00.000Z","path":"about/index.html","text":"关于我自己关于编程背景图包业余爱好最后"},{"title":"Categories","date":"2019-10-24T07:54:55.555Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2019-10-24T07:54:55.559Z","path":"tags/index.html","text":""}],"posts":[{"title":"tcp头部","date":"2019-10-22T13:28:59.000Z","path":"wiki/net-protocol/3.传输层/tcp/1.头部/","text":"传输层 tcp 协议 实现 首部协议格式12345678910111213141516171819 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source Port | Destination Port |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Sequence Number |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Acknowledgment Number |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Data | |U|A|P|R|S|F| || Offset| Reserved |R|C|S|S|Y|I| Window || | |G|K|H|T|N|N| |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Checksum | Urgent Pointer |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Options | Padding |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| data |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 源端口和目的端口各占 2 个字节，分别 tcp 连接的源端口和目的端口。关于端口的概念之前已经介绍过了。 序号占 4 字节，序号范围是[0，2^32 - 1]，共 2^32（即 4294967296）个序号。序号增加到 2^32-1 后，下一个序号就又回到 0。TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号（ISN）必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号是 301，而接待的数据共有 100 字节。这就表明：本报文段的数据的第一个字节的序号是 301，最后一个字节的序号是 400。显然，下一个报文段（如果还有的话）的数据序号应当从 401 开始，即下一个报文段的序号字段值应为 401。 确认号占 4 字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B 正确收到了 A 发送过来的一个报文段，其序号字段值是 501，而数据长度是 200 字节（序号 501~700），这表明 B 正确收到了 A 发送的到序号 700 为止的数据。因此，B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701。注意，现在确认号不是 501，也不是 700，而是 701。总之：若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。TCP 除了第一个 SYN 报文之外，所有 TCP 报文都需要携带 ACK 状态位。 数据偏移占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出 TCP 报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是 4 个字节，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节。 保留占 6 位，保留为今后使用，但目前应置为 0。 控制报文标志紧急URG（URGent）当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收 TCP 的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。当 URG 置为 1 时，发送应用进程就告诉发送方的 TCP 有紧急数据要传送。于是发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。 确认ACK（ACKnowledgment）仅当 ACK=1 时确认号字段才有效，当 ACK=0 时确认号无效。TCP 规定，在连接建立后所有的传送的报文段都必须把 ACK 置为 1。 推送 PSH（PuSH）当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH=1 的报文段，就尽快地交付接收应用进程。复位RST（ReSeT）当 RST=1 时，表名 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST 置为 1 用来拒绝一个非法的报文段或拒绝打开一个连接。 同步SYN（SYNchronization）在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN=1 和 ACK=1，因此 SYN 置为 1 就表示这是一个连接请求或连接接受报文。 终止FIN（FINis，意思是“完”“终”）用来释放一个连接。当 FIN=1 时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。 窗口占 2 字节，窗口值是[0，2^16-1]之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据，作为流量控制的依据，后面会详细介绍。总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。 检验和占 2 字节，检验和字段检验的范围包括首部和数据这两部分。和 UDP 用户数据报一样，在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。伪首部的格式和 UDP 用户数据报的伪首部一样。但应把伪首部第 4 个字段中的 17 改为 6（TCP 的协议号是 6）；把第 5 字段中的 UDP 中的长度改为 TCP 长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用 IPv6，则相应的伪首部也要改变。 紧急指针占 2 字节，紧急指针仅在 URG=1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据) 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为 0 时也可以发送紧急数据。 选项选项长度可变，最长可达 40 字节。当没有使用“选项”时，TCP 的首部长度是 20 字节。TCP 首部总长度由 TCP 头中的“数据偏移”字段决定，前面说了，最长偏移为 60 字节。那么“tcp 选项”的长度最大为 60-20=40 字节。 选项的一般结构体1234 1byte 1byte nbytes+--------+--------+------------------+ | Kind | Length | Info |+--------+--------+------------------+ TCP 最初只规定了一种选项，即最大报文段长度 MSS（Maximum Segment Szie）。后来又增加了几个选项如窗口扩大选项、时间戳选项等，下面说明常用的选项。 kind=0 是选项表结束选项。 kind=1 是空操作（nop）选项没有特殊含义，一般用于将 TCP 选项的总长度填充为 4 字节的整数倍，为啥需要 4 字节整数倍？因为前面讲了数据偏移字段的单位是 4 个字节。 kind=2 是最大报文段长度选项TCP 连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP 模块通常将 MSS 设置为（MTU-40）字节（减掉的这 40 字节包括 20 字节的 TCP 头部和 20 字节的 IP 头部）。这样携带 TCP 报文段的 IP 数据报的长度就不会超过 MTU（假设 TCP 头部和 IP 头部都不包含选项字段，并且这也是一般情况），从而避免本机发生 IP 分片。对以太网而言，MSS 值是 1460（1500-40）字节。 kind=3 是窗口扩大因子选项TCP 连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在 TCP 的头部中，接收通告窗口大小是用 16 位表示的，故最大为 65535 字节，但实际上 TCP 模块允许的接收通告窗口大小远不止这个数（为了提高 TCP 通信的吞吐量）。窗口扩大因子解决了这个问题。假设 TCP 头部中的接收通告窗口大小是 N，窗口扩大因子（移位数）是 M，那么 TCP 报文段的实际接收通告窗口大小是 N 乘 2M，或者说 N 左移 M 位。注意，M 的取值范围是 0～14。 和 MSS 选项一样，窗口扩大因子选项只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该 TCP 报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。关于窗口扩大因子选项的细节，可参考标准文档 RFC 1323。 kind=4 是选择性确认（Selective Acknowledgment，SACK）选项TCP 通信时，如果某个 TCP 报文段丢失，则 TCP 模块会重传最后被确认的 TCP 报文段后续的所有报文段，这样原先已经正确传输的 TCP 报文段也可能重复发送，从而降低了 TCP 性能。SACK 技术正是为改善这种情况而产生的，它使 TCP 模块只重新发送丢失的 TCP 报文段，不用发送所有未被确认的 TCP 报文段。选择性确认选项用在连接初始化时，表示是否支持 SACK 技术。 kind=5 是 SACK 实际工作的选项该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿（edge of block）参数包含一个 4 字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用 8 字节，所以 TCP 头部选项中实际上最多可以包含 4 个这样的不连续数据块（考虑选项类型和长度占用的 2 字节）。 kind=8 是时间戳选项该选项提供了较为准确的计算通信双方之间的回路时间（Round Trip Time，RTT）的方法，从而为 TCP 流量控制提供重要信息。","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"tcp","slug":"tcp","permalink":"http://blog.huido.site/tags/tcp/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"3.传输层","slug":"net-protocol/3-传输层","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/"},{"name":"tcp","slug":"net-protocol/3-传输层/tcp","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/tcp/"}]},{"title":"udp协议","date":"2019-10-22T13:28:59.000Z","path":"wiki/net-protocol/3.传输层/udp/1.协议/","text":"udp协议udp协议 包体 源端口 源端口号 目的端口 目的端口号 长度 UDP 数据报的长度，包含首部，最小为 8 检验和 UDP 数据报的校验和，如果接收到检验和不正确的情况下，直接丢弃该报文。 计算校验和算法UDP 计算校验和的方法和 IP 数据报首部校验和的方法相似。不同的是：IP 数据报校验和只校验 IP 数据报的首部，但 UDP 的校验和是把首部和数据部分一起都检验。 UDP 的校验和需要计算 UDP 首部加数据荷载部分，但也需要加上 UDP 伪首部。这个伪首部指，源地址、目的地址、UDP 数据长度、协议类型（0x11），协议类型就一个字节，但需要补一个字节的 0x0，构成 12 个字节。伪首部+UDP 首部+数据一起计算校验和。 UDP 检验和的计算方法是：按每 16 位求和得出一个 32 位的数；如果这个 32 位的数，高 16 位不为 0，则高 16 位加低 16 位再得到一个 32 位的数；重复第 2 步直到高 16 位为 0，将低 16 位取反，得到校验和。","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"udp","slug":"udp","permalink":"http://blog.huido.site/tags/udp/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"3.传输层","slug":"net-protocol/3-传输层","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/"},{"name":"udp","slug":"net-protocol/3-传输层/udp","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/udp/"}]},{"title":"tcp可靠性机制","date":"2019-10-22T13:28:59.000Z","path":"wiki/net-protocol/3.传输层/tcp/3.可靠性机制/","text":"tcp 可靠性机制可靠性指的是网络层能通信的前提下，保证数据包正确且按序到达对端。 比如发送端发送了“12345678”，那么接收端一定能收到“12345678”，不会乱序“12456783”，也不会少或多数据。 实现 TCP 的可靠传输有以下机制：1.校验和机制（检测和重传受到损伤的报文段） 2.确认应答机制（保存失序到达的报文段直至缺失的报文到期，以及检测和丢弃重复的报文段） 3.超时重传机制（重传丢失的报文段） 1.校验和每个 tcp 段都包含了一个检验和字段，用来检查报文段是否收到损伤。如果某个报文段因检验和无效而被检查出受到损伤，就由终点 TCP 将其丢弃，并被认为是丢失了。TCP 规定每个报文段都必须使用 16 位的检验和。12345678910111213141516// 校验和的计算func Checksum(buf []byte, initial uint16) uint16 &#123; v := uint32(initial) l := len(buf) if l&amp;1 != 0 &#123; l-- v += uint32(buf[l]) &lt;&lt; 8 &#125; for i := 0; i &lt; l; i += 2 &#123; v += (uint32(buf[i]) &lt;&lt; 8) + uint32(buf[i+1]) &#125; return ChecksumCombine(uint16(v), uint16(v&gt;&gt;16))&#125; 2.确认机制控制报文段不携带数据，但需要消耗一个序号，它也需要被确认，而 ACK 报文段永远不需要确认，ACK 报文段不消耗序号，也不需要被确认。在以前，TCP 只使用一种类型的确认，叫积累确认，目前 TCP 实现还实现了选择确认。 累积确认（ACK） 接收方通告它期望接收的下一个字节的序号，并忽略所有失序到达并被保存的报文段。有时这被称为肯定累积确认。在 TCP 首部的 32 位 ACK 字段用于积累确认，而它的值仅在 ACK 标志为 1 时才有效。举个例子来说，这里先不考虑 tcp 的序列号，如果发送方发了数据包 p1，p2，p3，p4；接受方成功收到 p1，p2，p4。那么接收方需要发回一个确认包，序号为 3(3 表示期望下一个收到的包的序号)，那么发送方就知道 p1 到 p2 都发送接收成功，必要时重发 p3。一个确认包确认了累积到某一序号的所有包，而不是对每个序号都发确认包。实际的 tcp 确认的都是序列号，而不是包的序号，但原理是一样的。 累积确认是快速重传的基础，这个后面讲拥塞控制的时候会详细说明。 累积确认是快速重传的基础，这个后面讲拥塞控制的时候会详细说明。 选择确认（SACK） 选择确认 SACK 要报告失序的数据块以及重复的报文段块，是为了更准确的告诉发送方需要重传哪些数据块。SACK 并没有取代 ACK，而是向发送方报告了更多的信息。SACK 是作为 TCP 首部末尾的选项来实现的。首先是否要启动 sack，应该在握手的时候告诉对方自己是否开启了 sack，这个是通过 kind=4 是选择性确认（Selective Acknowledgment，SACK）选项来实现的。实际传送 sack 信息的是 kind=5 的选项，其格式如下：123456789101112131415 +--------+--------+ | Kind=5 | Length | +--------+--------+--------+---------+ | Start of 1st Block | +--------+--------+--------+---------+ | End of 1st Block | +--------+--------+--------+---------+ | | / . . . . . . / | | +--------+--------+--------+---------+ | Start of nth Block | +--------+--------+--------+---------+ | End of nth Block | +--------+--------+--------+---------+ sack 的每个块是由两个参数构成的{ Start, End } Start 不连续块的第一个数据的序列号。End 不连续块的最后一个数据的序列号之后的序列号。 该选项参数告诉对方已经接收到并缓存的不连续的数据块，注意都是已经接收的，发送方可根据此信息检查究竟是哪个块丢失，从而发送相应的数据块。 比如下图：如图所示，tcp 接收方在接收到不连续的 tcp 段，可以看出，序号 1～1000，1501～3000，3501～4500 接收到了，但却少了序号 1001～1500，3001～3500 。 前面说了，sack 报告的是已接收的不连续的块，在这个例子中，sack 块的内容为{Start:1501, End:3001},{Start:3501, End:4501}， 注意：这里的 End 不是接收到数据段最后的序列号，而是最后的序列号加 1。 产生确认的情况 确认机制 当接收方收到了按序到达（序号是所期望的）的报文段，那么接收方就累积发送确认报文段。 当具有所期望的序号的报文段到达，而前一个按序到达的报文段还没有被确认，那么接收方就要立即发送 ACK 报文段。 当序号比期望的序号还大的失序报文段到达时，接收方立即发送 ACK 报文段，并宣布下一个期望的报文段序号。这将导致对丢失报文段的快重传。 当一个丢失的报文段到达时，接收方要发送 ACK 报文段，并宣布下一个所期望的序号。 如果到达一个重复的报文段，接收方丢弃该报文段，但是应当立即发送确认，指出下一个期望的报文段。 收到 fin 报文的时候，立即回复确认。 3.重传机制关于重传的基本概念RTO 即超时重传时间RTT 数据包往返时间平均偏差是指单项测定值与平均值的偏差（取绝对值）之和，除以测定次数。可靠性的核心就是报文段的重传。在一个报文段发送时，它会被保存到一个队列中，直至被确认为止。当重传计时器超时，或者发送方收到该队列中第一个报文段的三个重复的 ACK 时，该报文段被重传。 超时重传的概念很简单，就是一定时间内未收到确认，进行再次发送，但是如何计算重传的时间确实 tcp 最复杂的问题之一，毕竟要适应各种网络情况。TCP 一个连接期间只有一个 RTO 计时器，目前大部分实现都是采用Jacobaon/Karels 算法，详细可以看RFC6298，其计算公式如下， rto 的计算公式：1234567891011第一次rtt计算： SRTT = RRTTVAR = R/2RTO = SRTT + max (G, K*RTTVAR)K = 4之后：RTTVAR = (1 - beta) * RTTVAR + beta * |SRTT - R&apos;|SRTT = (1 - alpha) * SRTT + alpha * R&apos;RTO = SRTT + max (G, K*RTTVAR)K = 4 SRTT(smoothed round-trip time)平滑 RTT 时间RTTVAR(round-trip time variation)RTT 变量，其实就是 rtt 平均偏差G 表示系统时钟的粒度，一般很小，us 级别。 beta = 1/4, alpha = 1/8 发送方 TCP 的计时器时间到，TCP 发送队列中最前面的报文段（即序列号最小的报文段），并重启计时器。","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"tcp","slug":"tcp","permalink":"http://blog.huido.site/tags/tcp/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"3.传输层","slug":"net-protocol/3-传输层","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/"},{"name":"tcp","slug":"net-protocol/3-传输层/tcp","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/tcp/"}]},{"title":"tcp流量控制","date":"2019-10-22T13:28:59.000Z","path":"wiki/net-protocol/3.传输层/tcp/2.流量控制/","text":"tcp 流量控制tcp是由丢包重传的机制的 那么如果服务端因为负载导致不能接受发送端的数据从而丢弃数据 发送端接受到ack确认为丢包后导致重传 然后服务端导致负载更加严重，从而一个劲的重发数据，对网络造成更大的伤害。于是就提出了拥塞控制，当拥塞发生的时候，要做自我牺牲，降低发送速率。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"tcp","slug":"tcp","permalink":"http://blog.huido.site/tags/tcp/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"3.传输层","slug":"net-protocol/3-传输层","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/"},{"name":"tcp","slug":"net-protocol/3-传输层/tcp","permalink":"http://blog.huido.site/categories/net-protocol/3-传输层/tcp/"}]},{"title":"websocket实现","date":"2019-10-21T13:28:59.000Z","path":"wiki/net-protocol/2.应用层/websocket/3.websocket实现/","text":"编写基本的httpserver启动一个基本的httpserver，提供两个接口，一个index返回主页，另一个是就是我们自定义的websocket协议接口@main.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( \"fmt\" \"log\" \"github.com/brewlin/net-protocol/pkg/logging\" \"github.com/brewlin/net-protocol/protocol/application/http\" \"github.com/brewlin/net-protocol/protocol/application/websocket\")func init() &#123; logging.Setup()&#125;func main() &#123; serv := http.NewHTTP(\"tap1\", \"192.168.1.0/24\", \"192.168.1.1\", \"9502\") serv.HandleFunc(\"/ws\", echo) serv.HandleFunc(\"/\", func(request *http.Request, response *http.Response) &#123; response.End(\"hello\") &#125;) fmt.Println(\"@main: server is start ip:192.168.1.1 port:9502 \") serv.ListenAndServ()&#125;//websocket处理器func echo(r *http.Request, w *http.Response) &#123; fmt.Println(\"got http request ; start to upgrade websocket protocol....\") //协议升级 c *websocket.Conn c, err := websocket.Upgrade(r, w) if err != nil &#123; //升级协议失败，直接return 交由http处理响应 fmt.Println(\"Upgrade error:\", err) return &#125; defer c.Close() //循环处理数据，接受数据，然后返回 for &#123; message, err := c.ReadData() if err != nil &#123; log.Println(\"read:\", err) break &#125; fmt.Println(\"recv client msg:\", string(message)) // c.SendData(message ) c.SendData([]byte(\"hello\")) &#125;&#125; echo 接口接受http请求并进行升级我们的websocket页面如下 自定义的webscoket upgrade进行升级根据之前的协议分析，我知道握手的过程其实就是检查 HTTP 请求头部字段的过程，值得注意的一点就是需要针对客户端发送的 Sec-WebSocket-Key 生成一个正确的 Sec-WebSocket-Accept 只。关于生成的 Sec-WebSocket-Accpet 的实现，可以参考之前的分析。握手过程的具体代码如下：@upgrade.go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package websocketimport( \"net/http\" \"net\" \"errors\" \"log\" \"bufio\")func Upgrade(w http.ResponseWriter,r *http.Request)(c *Conn,err error)&#123; //是否是Get方法 if r.Method != \"GET\" &#123; http.Error(w,http.StatusText(http.StatusMethodNotAllowed),http.StatusMethodNotAllowed) return nil,errors.New(\"websocket:method not GET\") &#125; //检查 Sec-WebSocket-Version 版本 if values := r.Header[\"Sec-Websocket-Version\"];len(values) == 0 || values[0] != \"13\" &#123; http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest) return nil,errors.New(\"websocket:version != 13\") &#125; //检查Connection 和 Upgrade if !tokenListContainsValue(r.Header,\"Connection\",\"upgrade\") &#123; http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest) return nil,errors.New(\"websocket:could not find connection header with token 'upgrade'\") &#125; if !tokenListContainsValue(r.Header,\"Upgrade\",\"websocket\") &#123; http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest) return nil,errors.New(\"websocket:could not find connection header with token 'websocket'\") &#125; //计算Sec-Websocket-Accept的值 challengeKey := r.Header.Get(\"Sec-Websocket-Key\") if challengeKey == \"\" &#123; http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest) return nil,errors.New(\"websocket:key missing or blank\") &#125; var ( netConn net.Conn br *bufio.Reader ) h,ok := w.(http.Hijacker) if !ok &#123; http.Error(w,http.StatusText(http.StatusInternalServerError),http.StatusInternalServerError) return nil,errors.New(\"websocket:response dose not implement http.Hijacker\") &#125; var rw *bufio.ReadWriter //接管当前tcp连接，阻止内置http接管连接 netConn,rw,err = h.Hijack() if err != nil &#123; http.Error(w,http.StatusText(http.StatusInternalServerError),http.StatusInternalServerError) return nil,err &#125; br = rw.Reader if br.Buffered() &gt; 0 &#123; netConn.Close() return nil,errors.New(\"websocket:client send data before hanshake is complete\") &#125; // 构造握手成功后返回的 response p := []byte&#123;&#125; p = append(p, \"HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: \"...) p = append(p, computeAcceptKey(challengeKey)...) p = append(p, \"\\r\\n\\r\\n\"...) //返回repson 但不关闭连接 if _,err = netConn.Write(p);err != nil &#123; netConn.Close() return nil,err &#125; //升级为websocket log.Println(\"Upgrade http to websocket successfully\") conn := newConn(netConn) return conn,nil&#125; 握手过程的代码比较直观，就不多做解释了。到这里 WebSocket 的实现就基本完成了，可以看到有了之前的各种约定，我们实现 WebSocket 协议也是比较简单的。封装的websocket结构体和对应的方法@conn.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168package websocketimport ( \"fmt\" \"encoding/binary\" \"log\" \"errors\" \"net\")const ( /* * 是否是最后一个数据帧 * Fin Rsv1 Rsv2 Rsv3 Opcode * 1 0 0 0 0 0 0 0 =&gt; 128 */ finalBit = 1 &lt;&lt; 7 /* * 是否需要掩码处理 * Mask payload-len 第一位mask表示是否需要进行掩码处理 后面 * 7位表示数据包长度 1.0-125 表示长度 2.126 后面需要扩展2 字节 16bit * 3.127则扩展8bit * 1 0 0 0 0 0 0 0 =&gt; 128 */ maskBit = 1 &lt;&lt; 7 /* * 文本帧类型 * 0 0 0 0 0 0 0 1 */ TextMessage = 1 /* * 关闭数据帧类型 * 0 0 0 0 1 0 0 0 */ CloseMessage = 8)//websocket 连接type Conn struct &#123; writeBuf []byte maskKey [4]byte conn net.Conn&#125;func newConn(conn net.Conn)*Conn&#123; return &amp;Conn&#123;conn:conn&#125;&#125;func (c *Conn)Close()&#123; c.conn.Close()&#125;//发送数据func (c *Conn)SendData(data []byte)&#123; length := len(data) c.writeBuf = make([]byte,10 + length) //数据开始和结束位置 payloadStart := 2 /** *数据帧的第一个字节，不支持且只能发送文本类型数据 *finalBit 1 0 0 0 0 0 0 0 * | *Text 0 0 0 0 0 0 0 1 * =&gt; 1 0 0 0 0 0 0 1 */ c.writeBuf[0] = byte(TextMessage) | finalBit fmt.Printf(\"1 bit:%b\\n\",c.writeBuf[0]) //数据帧第二个字节，服务器发送的数据不需要进行掩码处理 switch&#123; //大于2字节的长度 case length &gt;= 1 &lt;&lt; 16 ://65536 //c.writeBuf[1] = byte(0x00) | 127 // 127 c.writeBuf[1] = byte(127) // 127 //大端写入64位 binary.BigEndian.PutUint64(c.writeBuf[payloadStart:],uint64(length)) //需要8byte来存储数据长度 payloadStart += 8 case length &gt; 125: //c.writeBuf[1] = byte(0x00) | 126 c.writeBuf[1] = byte(126) binary.BigEndian.PutUint16(c.writeBuf[payloadStart:],uint16(length)) payloadStart += 2 default: //c.writeBuf[1] = byte(0x00) | byte(length) c.writeBuf[1] = byte(length) &#125; fmt.Printf(\"2 bit:%b\\n\",c.writeBuf[1]) copy(c.writeBuf[payloadStart:],data[:]) c.conn.Write(c.writeBuf[:payloadStart+length])&#125;//读取数据func (c *Conn)ReadData()(data []byte,err error)&#123; var b [8]byte //读取数据帧的前两个字节 if _,err := c.conn.Read(b[:2]); err != nil &#123; return nil,err &#125; //开始解析第一个字节 是否还有后续数据帧 final := b[0] &amp; finalBit != 0 fmt.Printf(\"read data 1 bit :%b\\n\",b[0]) //不支持数据分片 if !final &#123; log.Println(\"Recived fragemented frame,not support\") return nil,errors.New(\"not suppeort fragmented message\") &#125; //数据帧类型 /* *1 0 0 0 0 0 0 1 * &amp; *0 0 0 0 1 1 1 1 *0 0 0 0 0 0 0 1 * =&gt; 1 这样就可以直接获取到类型了 */ frameType := int(b[0] &amp; 0xf) //如果 关闭类型，则关闭连接 if frameType == CloseMessage &#123; c.conn.Close() log.Println(\"Recived closed message,connection will be closed\") return nil,errors.New(\"recived closed message\") &#125; //只实现了文本格式的传输,编码utf-8 if frameType != TextMessage &#123; return nil,errors.New(\"only support text message\") &#125; //检查数据帧是否被掩码处理 //maskBit =&gt; 1 0 0 0 0 0 0 0 任何与他 要么为0 要么为 128 mask := b[1] &amp; maskBit != 0 //数据长度 payloadLen := int64(b[1] &amp; 0x7F)//0 1 1 1 1 1 1 1 1 127 dataLen := int64(payloadLen) //根据payload length 判断数据的真实长度 switch payloadLen &#123; case 126://扩展2字节 if _,err := c.conn.Read(b[:2]);err != nil &#123; return nil,err &#125; //获取扩展二字节的真实数据长度 dataLen = int64(binary.BigEndian.Uint16(b[:2])) case 127 : if _,err := c.conn.Read(b[:8]);err != nil &#123; return nil,err &#125; dataLen = int64(binary.BigEndian.Uint64(b[:8])) &#125; log.Printf(\"Read data length :%d,payload length %d\",payloadLen,dataLen) //读取mask key if mask &#123;//如果需要掩码处理的话 需要取出key //maskKey 是 4 字节 32位 if _,err := c.conn.Read(c.maskKey[:]);err != nil &#123; return nil ,err &#125; &#125; //读取数据内容 p := make([]byte,dataLen) if _,err := c.conn.Read(p);err != nil &#123; return nil,err &#125; if mask &#123; maskBytes(c.maskKey,p)//进行解码 &#125; return p,nil&#125; http 头部检查12345678910111213141516171819202122232425262728293031323334353637import ( \"crypto/sha1\" \"encoding/base64\" \"strings\" \"net/http\")var KeyGUID = []byte(\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\")//握手阶段使用 加密key返回 进行握手func computeAcceptKey(challengeKey string)string&#123; h := sha1.New() h.Write([]byte(challengeKey)) h.Write(KeyGUID) return base64.StdEncoding.EncodeToString(h.Sum(nil))&#125;//解码func maskBytes(key [4]byte,b []byte)&#123; pos := 0 for i := range b &#123; b[i] ^= key[pos &amp; 3] pos ++ &#125;&#125;// 检查http 头部字段中是否包含指定的值func tokenListContainsValue(header http.Header, name string, value string)bool&#123; for _,v := range header[name] &#123; for _, s := range strings.Split(v,\",\")&#123; if strings.EqualFold(value,strings.TrimSpace(s)) &#123; return true &#125; &#125; &#125; return false&#125;","tags":[{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"golang","slug":"golang","permalink":"http://blog.huido.site/tags/golang/"},{"name":"websocket","slug":"websocket","permalink":"http://blog.huido.site/tags/websocket/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"2.应用层","slug":"net-protocol/2-应用层","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/"},{"name":"websocket","slug":"net-protocol/2-应用层/websocket","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/websocket/"}]},{"title":"websocket协议解析","date":"2019-10-21T13:28:59.000Z","path":"wiki/net-protocol/2.应用层/websocket/1.websocket协议解析/","text":"websocket 协议报文websocket协议也是基于tcp协议，和http不同的是，tcp接受的数据包为二进制帧，而http为字符串数据包。并且websocket协议在连接阶段会触发一个http请求进行websocket协议校验。校验成功后才会接管tcp通讯流程不会断开该http连接 1234567891011121314151617181920websocket 数据帧报文 0 1 2 3 4 0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+ WebSocket协议详解WebSocket 协议解决了浏览器和服务器之间的全双工通信问题。在 WebSocket 出现之前，浏览器如果需要从服务器及时获得更新，则需要不停的对服务器主动发起请求，也就是 Web 中常用的poll技术。这样的操作非常低效，这是因为每发起一次新的 HTTP 请求，就需要单独开启一个新的 TCP 链接，同时 HTTP 协议本身也是一种开销非常大的协议。为了解决这些问题，所以出现了 WebSocket 协议。WebSocket 使得浏览器和服务器之间能通过一个持久的 TCP 链接就能完成数据的双向通信。关于 WebSocket 的 RFC 提案，可以参看RFC6455。 WebSocket 和 HTTP 协议一般情况下都工作在浏览器中，但 WebSocket 是一种完全不同于 HTTP 的协议。尽管，浏览器需要通过 HTTP 协议的GET请求，将 HTTP 协议升级为 WebSocket 协议。升级的过程被称为握手(handshake)。当浏览器和服务器成功握手后，则可以开始根据 WebSocket 定义的通信帧格式开始通信了。像其他各种协议一样，WebSocket 协议的通信帧也分为控制数据帧和普通数据帧，前者用于控制 WebSocket 链接状态，后者用于承载数据。下面我们将一一分析 WebSocket 协议的握手过程以及通信帧格式。 一、websocket握手握手的过程也就是将HTTP协议升级为WebSocket协议的过程，握手开始首先由浏览器端发送一个GET请求，该请求的HTTP头部信息如下:12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protcol: chat, superchatSec-WebSocket-Version: 13 当服务器端，成功验证了以上信息后，则会返回一个形如以下的响应：12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat 可以看到，浏览器发送端HTTP请求中，增加了一些新端字段，其作用如下所示： Upgrade: 规定必需的字段，其值必需为 websocket, 如果不是则握手失败； Connection: 规定必需的字段，值必需为 Upgrade, 如果不是则握手失败；Sec-WebSocket-Key: 必需字段，一个随机的字符串；Sec-WebSocket-Protocol: 可选字段，可以用于标识应用层的协议；Sec-WebSocket-Version: 必需字段，代表了 WebSocket 协议版本，值必需是 13, 否则握手失败；返回端响应中，如果握手成功会返回状态码101的HTTP响应，同时其他字段说明如下： Upgrade: 规定必需的字段，其值必需为 websocket, 如果不是则握手失败； Connection: 规定必需的字段，值必需为 Upgrade, 如果不是则握手失败； Sec-WebSocket-Accept: 规定必需的字段，该字段的值是通过固定字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11加上请求中Sec-WebSocket-Key字段的值，然后再对其结果通过 SHA1 哈希算法求出的结果。 Sec-WebSocket-Protocol: 对应于请求中的 Sec-WebSocket-Protocol 字段；当浏览器和服务端成功握手后，就可以传递数据了，传送数据是按照WebSocket的数据格式生成的二、WebSocket协议数据帧数据帧的定义类似与TCP/IP的格式定义，具体看下图：123456789101112131415161718 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len | Extended payload length ||I|S|S|S| (4) |A| (7) | (16/64) ||N|V|V|V| |S| | (if payload len==126/127) || |1|2|3| |K| | |+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +| Extended payload length continued, if payload len == 127 |+ - - - - - - - - - - - - - - - +-------------------------------+| |Masking-key, if MASK set to 1 |+-------------------------------+-------------------------------+| Masking-key (continued) | Payload Data |+-------------------------------- - - - - - - - - - - - - - - - +: Payload Data continued ... :+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +| Payload Data continued ... |+---------------------------------------------------------------+ 以上这张图，一行代表32bit（位），也就是4bytes（字节），总体上包含两份，帧头部和数据内容。每个从WebSocket链接中接受到的数据帧，都要按照以上格式进行解析，这样才能知道该数据帧是用于控制的还是用于传送数据的，关于以上数据帧的各个比特位的解释如下： FIN:1bit,当该比特位值为%x0时，表示后面还有更多的数据帧，%x1时表示这是最后一个数据帧； RSV1,RSV2,RSV3:各占1个比特位。一般情况下全为0，当客户端、服务端协商采用WebSocket扩展时，这三个标识位可以非0，且值当含义由扩展进行定义，如果出现非0当值，且没有采用WebSocket扩展，则链接出错 opcode:4 bit,用于表明数据帧当类型，一共可以表示16种帧类型，如下所示： %x0:表示这是一个分片当帧，它属于前面帧当后续帧； %x1:表示该数据帧携带的数据类型是文本类型，且编码utf-8 %x2 : 表示携带的是二进制数据； %x3-7 : 保留未使用； %x8 : 表示该帧用于关闭 WebSocket 链接； %x9 : 表示该帧代表了 ping 操作； %xA : 表示该帧代表了 pong 回应； %xB-F : 保留未使用； MASK:1 bit,%x0表示数据帧没有经过掩码计算，而%x1则表示数据帧已经经过掩码计算，得到真正当数据需要解码，一般情况下，只有浏览器发送给服务端当数据帧才需要进行掩码计算； Payload len:7 bit,表示了数据帧携带当数据长度，7 bit 的值根据三种情况，帧的解析有所不同： %x0 - 7D : 也就是从 0 到 125，表示数据长度, 数据总长度也就是 7 bit 代表的长度； %x7E : 7 bit 的值是 126 时，则后续的 2 个字节（16 bit)表示的一个 16 位无符号数，这个数用来表示数据的长度； %x7F : 7 bit 的值是 127 时，则后续的 8 个字节（64 bit)表示的一个 64 位无符号数，这个数用来表示数据的长度； Masking-key: 32 bit, 表示了用于解码的 key，只有当 MASK 比特位的值为 %x1 是，才有该数据； Payload Data: 余下的比特位用于存储具体的数据；通过以上分析可以看出，WebSocket 协议数据帧的最大头部为 2 + 8 + 4 = 14 bytes 也就是 14 个字节。同时我们要实现 WebSocket 协议，最主要的工作就是实现对数据帧的解析。","tags":[{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"golang","slug":"golang","permalink":"http://blog.huido.site/tags/golang/"},{"name":"websocket","slug":"websocket","permalink":"http://blog.huido.site/tags/websocket/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"2.应用层","slug":"net-protocol/2-应用层","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/"},{"name":"websocket","slug":"net-protocol/2-应用层/websocket","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/websocket/"}]},{"title":"websocket算法","date":"2019-10-21T13:28:59.000Z","path":"wiki/net-protocol/2.应用层/websocket/2.websocket算法/","text":"websocket协议中的一些算法在分析 WebSocket 协议握手过程和数据帧格式过程中，我们讲到了一些算法，下面我们讲解下具体实现。 Sec-WebSocket-Accept的计算方法从上面的分析中，我们知道字段的值是通过固定字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11加上请求中Sec-WebSocket-Key字段的值，然后再对其结果通过 SHA1 哈希算法求出的结果。可以通过以下 golang 代码实现：1234567var keyGUID = []byte(\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\")func computeAcceptKey(challengeKey string) string &#123; h := sha1.New() h.Write([]byte(challengeKey)) h.Write(keyGUID) return base64.StdEncoding.EncodeToString(h.Sum(nil))&#125; 掩码处理浏览器发送给服务器的数据帧是经过掩码处理的，那怎么样对数据进行解码呢？以下是来自RFC6455文档的解释具体的流程是：将传输的数据按字节 byte 处理，同时将 Masking-key 代表的值也按字节处理。假如 data-byte-i 代表的是数据的第 i 个字节，那么 j = i MOD 4，然后从Maksing-key中(一共有 4 个字节）取出第 j 个字节 mask-key-byte-j，然后将 data-byte-i 和 mask-key-byte-j 代表的字节进行异或操作，取得结果就是最终的结果。该操作可以用如下 golang 代码实现：1234567func maskBytes(key [4]byte,pos int,b[]byte)int&#123; for i := range b&#123; b[i] ^= key[pos &amp; 3] pos++ &#125; return pos &amp; 3&#125; 注意以上的操作，pos &amp; 3这里代表的操作是pos%4,因为 a % (2 ^ n) 等价于 a &amp; (2^n -1),在这里使用按位与操作更加高效","tags":[{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"golang","slug":"golang","permalink":"http://blog.huido.site/tags/golang/"},{"name":"websocket","slug":"websocket","permalink":"http://blog.huido.site/tags/websocket/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"2.应用层","slug":"net-protocol/2-应用层","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/"},{"name":"websocket","slug":"net-protocol/2-应用层/websocket","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/websocket/"}]},{"title":"http协议解析","date":"2019-10-18T13:28:59.000Z","path":"wiki/net-protocol/2.应用层/http/1.http协议解析/","text":"http协议报文这是一个典型的http请求的报文样例，可以看出是一个websocket升级前的http请求。该字符报文完全基于tcp协议，协议报文内容为tcp数据包，也就是tcp进行recv调用获取的数据内容。如下报文表示已经接受完http报文数据。 解析http报文的源码为application/http/request.go中123456789http 协议报文GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protcol: chat, superchatSec-WebSocket-Version: 13 @请求方法解析tcp数据包第一行数据，遇到空格就拆分，则获取到请求方法 @uri解析tcp数据包第一行数据，遇到空格就拆分，则获取到uri路径 @header头部接下来都是一些头部信息的keyvalue，每次读取一行，然后根据:分隔符进行拆分，获取header头部请求键值对","tags":[{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"},{"name":"golang","slug":"golang","permalink":"http://blog.huido.site/tags/golang/"},{"name":"http","slug":"http","permalink":"http://blog.huido.site/tags/http/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"2.应用层","slug":"net-protocol/2-应用层","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/"},{"name":"http","slug":"net-protocol/2-应用层/http","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/http/"}]},{"title":"应用层前世今生","date":"2019-10-17T13:28:59.000Z","path":"wiki/net-protocol/2.应用层/应用层前世今生/","text":"应用层的作用对传输层协议对再次封装，例如对tcp进行封装对http、websocket协议等，以及http3协议基于udp协议的封装等 http协议报文123456789http 协议报文GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protcol: chat, superchatSec-WebSocket-Version: 13 websocket 协议报文1234567891011121314151617181920websocket 数据帧报文 0 1 2 3 4 0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+","tags":[{"name":"go","slug":"go","permalink":"http://blog.huido.site/tags/go/"},{"name":"protocol","slug":"protocol","permalink":"http://blog.huido.site/tags/protocol/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"2.应用层","slug":"net-protocol/2-应用层","permalink":"http://blog.huido.site/categories/net-protocol/2-应用层/"}]},{"title":"快速开始","date":"2019-10-16T13:28:59.000Z","path":"wiki/net-protocol/1.前言/1.快速开始/","text":"demo案例cmd:该目录下为各协议的实现demo，提供api调用实现以及测试","tags":[{"name":"Go","slug":"Go","permalink":"http://blog.huido.site/tags/Go/"},{"name":"Protocol","slug":"Protocol","permalink":"http://blog.huido.site/tags/Protocol/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"},{"name":"1.前言","slug":"net-protocol/1-前言","permalink":"http://blog.huido.site/categories/net-protocol/1-前言/"}]},{"title":"GO标准库和算法应用","date":"2017-10-24T13:28:59.000Z","path":"wiki/go-stl/GO标准库和算法应用/","text":"go-stltodo..","tags":[{"name":"Go","slug":"Go","permalink":"http://blog.huido.site/tags/Go/"}],"categories":[{"name":"go-stl","slug":"go-stl","permalink":"http://blog.huido.site/categories/go-stl/"}]},{"title":"微服务应用","date":"2017-10-24T13:28:59.000Z","path":"wiki/swoft-im/微服务应用/","text":"","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.huido.site/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://blog.huido.site/tags/Swoole/"},{"name":"IM","slug":"IM","permalink":"http://blog.huido.site/tags/IM/"}],"categories":[{"name":"swoft-im","slug":"swoft-im","permalink":"http://blog.huido.site/categories/swoft-im/"}]},{"title":"index","date":"2017-10-24T13:28:59.000Z","path":"wiki/net-protocol/index/","text":"net-protocol基于go 实现链路层、网络层、传输层、应用层 网络协议栈 ，使用虚拟网卡实现 @docs1相关md文档在cmd目录下，以及相关协议的demo测试 ./cmd/*.md @application 应用层 http docs websocket docs @transport 传输层 tcp docs udp docs port 端口机制 @network 网络层 icmp ipv4 ipv6 @link 链路层 arp docs ethernet @物理层 tun tap 虚拟网卡的实现 协议相关api1.应用层相关协议应用层暂时只实现了http、websocket等文本协议。都基于tcp、对tcp等进行二次封装 http api :http-api.md123456789http 协议报文GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protcol: chat, superchatSec-WebSocket-Version: 13 websocket api : websocket-api.md1234567891011121314151617181920websocket 数据帧报文 0 1 2 3 4 0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+ 2.传输层相关协议传输层实现了upd、tcp、灯协议，并实现了主要接口 tcp api:tcp-api.md 1234567891011121314151617181920 tcp 首部协议报文0 1 2 3 40 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source Port | Destination Port |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Sequence Number |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Acknowledgment Number |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Data | |U|A|P|R|S|F| || Offset| Reserved |R|C|S|S|Y|I| Window || | |G|K|H|T|N|N| |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Checksum | Urgent Pointer |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Options | Padding |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| data |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ udp-api:./udp-api.md1udp 协议报文 端口机制 3.网络层相关协议ip:ipv4-api.md123456789101112131415161718 ip头部协议报文0 1 2 3 40 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|Version| LHL | Type of Service | Total Length |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Identification(fragment Id) |Flags| Fragment Offset || 16 bits |R|D|M| 13 bits |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Time-To-Live | Protocol | Header Checksum || ttl(8 bits) | 8 bits | 16 bits |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source IP Address (32 bits) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Destination Ip Address (32 bits) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Options (*** bits) | Padding |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+","tags":[{"name":"Go","slug":"Go","permalink":"http://blog.huido.site/tags/Go/"},{"name":"Protocol","slug":"Protocol","permalink":"http://blog.huido.site/tags/Protocol/"}],"categories":[{"name":"net-protocol","slug":"net-protocol","permalink":"http://blog.huido.site/categories/net-protocol/"}]},{"title":"分布式推送中间件","date":"2017-10-24T13:28:59.000Z","path":"wiki/im-cloud/分布式推送中间件/","text":"im-cloud","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.huido.site/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://blog.huido.site/tags/Swoole/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://blog.huido.site/tags/RabbitMQ/"}],"categories":[{"name":"im-cloud","slug":"im-cloud","permalink":"http://blog.huido.site/categories/im-cloud/"}]},{"title":"Welcome Brewlin's Wiki Site","date":"2017-01-21T17:55:57.000Z","path":"wiki/index/","text":"@net-protocol基于go模拟内核协议栈 实现链路层、网络层、传输层、应用层 网络协议栈 ，使用虚拟网卡实现 @go-stlGolang Standard Template Library @im-cloud原生swoole4 全协程化分布式中间件、多节点扩容、多节点服务 @swoft-im基于swoft-cloud的微服务架构，最小化拆分粒度，PHP7、多进程、协程、异步任务、mysql连接池、redi连接池、rpc连接池、服务治理、服务注册与发现、Aop切面、全注解 http://chat.huido.site","tags":[],"categories":[]}]}