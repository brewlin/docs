<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>glusterfs-客户端源码分析 | Brewlin&#39;s Wiki</title><meta name="keywords" content="linux,c,gluster,glusterfs"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="glusterfs也属于典型的cs结构，有client端,server端，通过rpc调用通信 主要的进程有:  glusterd: 管理进程，管理所有的配置、版本信息 glusterfsd: server进程，处理所有的文件处理请求并进行落盘 glusterfs|api: client端，将所有文件的相关操作代理到server端去处理，核心是根据hash算法计算出需要和哪个server端进行通信"><meta name="keywords" content="linux,c,gluster,glusterfs"><meta property="og:type" content="article"><meta property="og:title" content="glusterfs-客户端源码分析"><meta property="og:url" content="http://wiki.brewlin.com/wiki/middlewares/glusterfs/1.glusterfs-客户端源码分析/index.html"><meta property="og:site_name" content="Brewlin&#39;s Wiki"><meta property="og:description" content="glusterfs也属于典型的cs结构，有client端,server端，通过rpc调用通信 主要的进程有:  glusterd: 管理进程，管理所有的配置、版本信息 glusterfsd: server进程，处理所有的文件处理请求并进行落盘 glusterfs|api: client端，将所有文件的相关操作代理到server端去处理，核心是根据hash算法计算出需要和哪个server端进行通信"><meta property="og:locale" content="en"><meta property="og:image" content="http://wiki.brewlin.com/images/middlewares/gluster/client_gluster1.png"><meta property="og:image" content="http://wiki.brewlin.com/images/middlewares/gluster/client_gluster2.png"><meta property="og:image" content="http://wiki.brewlin.com/images/middlewares/gluster/client_gluster3.png"><meta property="og:updated_time" content="2022-06-30T08:06:37.448Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="glusterfs-客户端源码分析"><meta name="twitter:description" content="glusterfs也属于典型的cs结构，有client端,server端，通过rpc调用通信 主要的进程有:  glusterd: 管理进程，管理所有的配置、版本信息 glusterfsd: server进程，处理所有的文件处理请求并进行落盘 glusterfs|api: client端，将所有文件的相关操作代理到server端去处理，核心是根据hash算法计算出需要和哪个server端进行通信"><meta name="twitter:image" content="http://wiki.brewlin.com/images/middlewares/gluster/client_gluster1.png"><link rel="alternate" href="/atom.xml" title="Brewlin&#39;s Wiki" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/libs/open-sans/styles.css"><link rel="stylesheet" href="/libs/source-code-pro/styles.css"><link rel="stylesheet" href="/css/style.css"><script src="/libs/jquery/2.1.3/jquery.min.js"></script><script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script><link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css"><link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head></html><body><div id="container"><header id="header"><div id="header-main" class="header-inner"><div class="outer"><a href="/" id="logo"><i class="logo"></i> <span class="site-title">Brewlin&#39;s Wiki</span></a><nav id="main-nav"> <a class="main-nav-link" href="/">首页</a> <a class="main-nav-link" href="/archives">归档</a> <a class="main-nav-link" href="/categories">分类</a> <a class="main-nav-link" href="/tags">标签</a> <a class="main-nav-link" href="/about">关于</a></nav><div id="search-form-wrap"><form class="search-form"> <input type="text" class="ins-search-input search-form-input" placeholder="Search"> <button type="submit" class="search-form-submit"></button></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"> <input type="text" class="ins-search-input" placeholder="Type something..."><span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script></div></div></div><div id="main-nav-mobile" class="header-sub header-inner"><table class="menu outer"><tr><td><a class="main-nav-link" href="/">首页</a></td><td><a class="main-nav-link" href="/archives">归档</a></td><td><a class="main-nav-link" href="/categories">分类</a></td><td><a class="main-nav-link" href="/tags">标签</a></td><td><a class="main-nav-link" href="/about">关于</a></td><td><div class="search-form"> <input type="text" class="ins-search-input search-form-input" placeholder="Search"></div></td></tr></table></div></header><div class="outer"><aside id="sidebar"><div class="widget-wrap" id="categories"><h3 class="widget-title"> <span>categories</span> &nbsp;<a id="allExpand" href="#"><i class="fa fa-angle-double-down fa-2x"></i></a></h3><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; algorithm</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; gc-learning</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/algorithm/gc-learning/前言/1.什么是roots/">什么是Root</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/前言/2.什么是heaps/">什么是Heap</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 算法实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/1.标记清除算法/">标记清除算法</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/2.标记清除-多链表法/">标记清除-多链表法</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/3.引用计数/">引用计数</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/4.GC复制/">GC复制</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/6.压缩算法-lisp2/">压缩算法-lisp2</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/7.压缩算法-two-finger/">压缩算法-two-finger</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/8.保守式gc/">关于保守式GC</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/10.三色标记清除/">三色标记清除</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/5.GC复制-标记清除/">GC复制-标记清除</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/9.分代回收算法/">分代回收算法</a></li></ul></li><li class="file"><a href="/wiki/algorithm/gc-learning/GC算法分析与实现/">GC算法分析与实现</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; graph</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/algorithm/graph/dijkstra/">Dijkstra最短路径</a></li><li class="file"><a href="/wiki/algorithm/graph/最小生成树/">最小生成树</a></li><li class="file"><a href="/wiki/algorithm/graph/稀疏图-寻路/">稀疏图-寻路</a></li><li class="file"><a href="/wiki/algorithm/graph/稀疏图-连通分量-bfs-dfs/">稀疏图-连通分量-bfs-dfs</a></li><li class="file"><a href="/wiki/algorithm/graph/稀疏图-邻接表/">稀疏图-邻接表</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; compiler</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/compiler/php_offset/">php_offset</a></li><li class="file"><a href="/wiki/compiler/php_引用计数与GC/">php_引用计数与gc</a></li><li class="file"><a href="/wiki/compiler/rust协程_调度器实现/">rust_无栈协程&调度器实现</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; github</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; c-ext</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; coroutine</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/c-ext/coroutine/协程/">协程</a></li><li class="file"><a href="/wiki/github/c-ext/coroutine/协程socket/">协程socket</a></li><li class="file"><a href="/wiki/github/c-ext/coroutine/协程tcp服务/">协程tcp服务</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; event</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/c-ext/event/event/">event</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; hook</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/c-ext/hook/runtime/">runtime</a></li><li class="file"><a href="/wiki/github/c-ext/hook/sleep/">sleep</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; memory</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/c-ext/memory/共享内存/">共享内存</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; process</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/c-ext/process/进程管理/">进程管理</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; thread</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/c-ext/thread/线程池/">线程池</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; timer</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/c-ext/timer/定时器/">定时器</a></li></ul></li><li class="file"><a href="/wiki/github/c-ext/index/">c扩展</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; go-stl</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; graph</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/go-stl/graph/图论/">图论算法</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; hash</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/go-stl/hash/hash_code/">哈希Code生成</a></li><li class="file"><a href="/wiki/github/go-stl/hash/hash_list/">哈希链表</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; queue</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/go-stl/queue/list/">LIST</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; raft</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/go-stl/raft/raft分布式一致性原理(一)/">raft分布式一致性原理(一)</a></li><li class="file"><a href="/wiki/github/go-stl/raft/raft分布式一致性原理(二)/">raft分布式一致性原理(二)</a></li><li class="file"><a href="/wiki/github/go-stl/raft/相关资料/">相关资料</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; tree</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/go-stl/tree/binary-search/">二分搜索树</a></li><li class="file"><a href="/wiki/github/go-stl/tree/reds-black-tree/">红黑树</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; trie</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/go-stl/trie/trie/">字典树</a></li></ul></li><li class="file"><a href="/wiki/github/go-stl/index/">GO标准库和算法应用</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; goos</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/goos/Goos-多线程协程实现简要/">Goos-多线程协程实现简要</a></li><li class="file"><a href="/wiki/github/goos/Goos-底层协程实现(三)/">Goos-底层协程实现(三)</a></li><li class="file"><a href="/wiki/github/goos/Goos-底层协程实现(一)/">Goos-底层协程实现(一)</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; im-cloud</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 1.前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/1.前言/1.安装部署/">安装部署</a></li><li class="file"><a href="/wiki/github/im-cloud/1.前言/2.并发压测对比/">并发压测对比</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 2.版本</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/2.版本/1.版本兼容/">版本兼容</a></li><li class="file"><a href="/wiki/github/im-cloud/2.版本/2.单进程全协程化版/">单线程全协程化版</a></li><li class="file"><a href="/wiki/github/im-cloud/2.版本/3.多进程worker版/">多进程worker版本</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 3.相关组件</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; core</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/core/core/">core</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; database</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/database/db/">db</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; discovery</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/discovery/discovery/">discovery</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; grpc</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/grpc/grpc/">grpc</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; log</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/log/log/">log</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; memeory</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/memeory/memeory/">memory</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; process</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/process/process/">process</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; queue</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/queue/queue/">queue</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; redis</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/redis/redis/">redis</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; task</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/task/task/">task</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 4.开放接口</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/4.开放接口/logic开放接口/">Logic 节点开放接口</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 5.相关实现</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 1.底层实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/5.相关实现/1.底层实现/1.im-cloud/">im-cloud</a></li><li class="file"><a href="/wiki/github/im-cloud/5.相关实现/1.底层实现/2.通讯协议/">通讯协议</a></li><li class="file"><a href="/wiki/github/im-cloud/5.相关实现/1.底层实现/4.job节点/">job节点实现</a></li><li class="file"><a href="/wiki/github/im-cloud/5.相关实现/1.底层实现/5.logic节点/">logic节点实现</a></li><li class="file"><a href="/wiki/github/im-cloud/5.相关实现/1.底层实现/3.cloud节点/">cloud节点实现</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 2.应用实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/5.相关实现/2.应用实现/1.推送实现/">推送实现</a></li><li class="file"><a href="/wiki/github/im-cloud/5.相关实现/2.应用实现/2.服务发现/">服务发现</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 3.组件实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/5.相关实现/3.组件实现/1.连接池实现/">连接池实现</a></li></ul></li></ul></li><li class="file"><a href="/wiki/github/im-cloud/index/">im-cloud 分布式推送中间件</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; net-protocol</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 1.前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/1.前言/1.快速开始/">快速开始</a></li><li class="file"><a href="/wiki/github/net-protocol/1.前言/2.协议分层模型/">协议分层模型</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 2.应用层</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; dns</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/2.应用层/dns/1.dns协议简介/">dns协议简介</a></li><li class="file"><a href="/wiki/github/net-protocol/2.应用层/dns/2.dns协议实现/">dns协议实现</a></li><li class="file"><a href="/wiki/github/net-protocol/2.应用层/dns/3.dns协议api/">dns协议api</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; http</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/2.应用层/http/1.http协议解析/">http协议解析</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; websocket</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/2.应用层/websocket/2.websocket算法/">websocket算法</a></li><li class="file"><a href="/wiki/github/net-protocol/2.应用层/websocket/1.websocket协议解析/">websocket协议解析</a></li><li class="file"><a href="/wiki/github/net-protocol/2.应用层/websocket/3.websocket实现/">websocket实现</a></li></ul></li><li class="file"><a href="/wiki/github/net-protocol/2.应用层/应用层前世今生/">应用层前世今生</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 3.传输层</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; tcp</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/3.传输层/tcp/2.流量控制/">tcp流量控制</a></li><li class="file"><a href="/wiki/github/net-protocol/3.传输层/tcp/3.可靠性机制/">tcp可靠性机制</a></li><li class="file"><a href="/wiki/github/net-protocol/3.传输层/tcp/4.连接状态/">连接状态</a></li><li class="file"><a href="/wiki/github/net-protocol/3.传输层/tcp/1.头部/">tcp头部</a></li><li class="file"><a href="/wiki/github/net-protocol/3.传输层/tcp/5.流量控制的实现-滑动窗口/">流量控制-滑动窗口</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; udp</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/3.传输层/udp/1.协议/">udp协议</a></li><li class="file"><a href="/wiki/github/net-protocol/3.传输层/udp/2.检验和计算/">校验和计算</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 4.网络层</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/4.网络层/arp协议/">arp协议</a></li><li class="file"><a href="/wiki/github/net-protocol/4.网络层/协议_icmp/">icmp协议</a></li><li class="file"><a href="/wiki/github/net-protocol/4.网络层/协议_端口/">端口机制</a></li><li class="file"><a href="/wiki/github/net-protocol/4.网络层/跨子网arp查询&子网arp查询/">arp子网查询&跨子网查询</a></li><li class="file"><a href="/wiki/github/net-protocol/4.网络层/协议_ip/">ip协议</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 5.链路层</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/5.链路层/1.以太网协议/">以太网协议</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 6.物理层</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/6.物理层/tap/">tap</a></li><li class="file"><a href="/wiki/github/net-protocol/6.物理层/tool/">tool</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 7.客户端</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/7.客户端/dns-客户端/">dns-客户端</a></li><li class="file"><a href="/wiki/github/net-protocol/7.客户端/http-客户端/">http-客户端</a></li><li class="file"><a href="/wiki/github/net-protocol/7.客户端/tcp-客户端/">tcp-客户端</a></li><li class="file"><a href="/wiki/github/net-protocol/7.客户端/udp-客户端/">udp-客户端</a></li><li class="file"><a href="/wiki/github/net-protocol/7.客户端/websocekt-客户端/">websocket-客户端</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 8.问题反馈</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/8.问题反馈/tun_tap/">Tun/Tap虚拟网卡外网通讯</a></li></ul></li><li class="file"><a href="/wiki/github/net-protocol/index/">index</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; swoole-im</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/swoole-im/前言/业务说明/">业务说明</a></li></ul></li><li class="file"><a href="/wiki/github/swoole-im/index/">微服务应用</a></li></ul></li></ul></li><li class="directory open"><a href="#" data-role="directory"><i class="fa fa-folder-open"></i> &nbsp; middlewares</a><ul class="unstyled" id="tree"><li class="directory open"><a href="#" data-role="directory"><i class="fa fa-folder-open"></i> &nbsp; glusterfs</a><ul class="unstyled" id="tree"><li class="file active"><a href="/wiki/middlewares/glusterfs/1.glusterfs-客户端源码分析/">glusterfs-客户端源码分析</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; nginx</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; mini_ngx</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/middlewares/nginx/mini_ngx/1.mini_ngx_实现一-简述/">mini_ngx_实现一-简述</a></li><li class="file"><a href="/wiki/middlewares/nginx/mini_ngx/2.mini_ngx_实现二-core模块/">mini_ngx_实现二-core模块</a></li><li class="file"><a href="/wiki/middlewares/nginx/mini_ngx/3.mini_ngx_实现三-http模块/">mini_ngx_实现三-http模块</a></li><li class="file"><a href="/wiki/middlewares/nginx/mini_ngx/4.mini_ngx_实现四-event模块/">mini_ngx_实现四-event模块</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; sharmem</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/middlewares/nginx/sharmem/shamem.c/">shamem.c</a></li><li class="file"><a href="/wiki/middlewares/nginx/sharmem/shamem.h/">shamem.h</a></li><li class="file"><a href="/wiki/middlewares/nginx/sharmem/共享内存/">共享内存的实现</a></li></ul></li><li class="file"><a href="/wiki/middlewares/nginx/1.ngx_连接池与事件封装(一)/">ngx_连接池与事件封装(一)</a></li><li class="file"><a href="/wiki/middlewares/nginx/2.ngx_连接池与事件封装(二)/">ngx_连接池与事件封装(二)</a></li><li class="file"><a href="/wiki/middlewares/nginx/http_模块开发的步骤（一）/">http_模块开发的步骤</a></li><li class="file"><a href="/wiki/middlewares/nginx/nginx_内存池封装/">ngx_内存池封装</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; read</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/read/read/">read</a></li></ul></li><li class="file"><a href="/wiki/index/">Welcome Brewlin's Wiki Site</a></li></ul></div><script>$(document).ready(function(){var r="fa-folder-open",i="fa-folder",l="fa-angle-double-down",d="fa-angle-double-up";$(document).on("click",'#categories a[data-role="directory"]',function(a){a.preventDefault();var e=$(this).children(".fa"),s=e.hasClass(r),l=$(this).siblings("ul");e.removeClass(r).removeClass(i),s?(void 0!==l&&l.slideUp({duration:100}),e.addClass(i)):(void 0!==l&&l.slideDown({duration:100}),e.addClass(r))}),$('#categories a[data-role="directory"]').bind("contextmenu",function(a){a.preventDefault();var e=$(this).children(".fa"),s=e.hasClass(r),l=$(this).siblings("ul"),d=$.merge(l.find("li ul"),l),o=$.merge(l.find(".fa"),e);o.removeClass(r).removeClass(i),s?(d.slideUp({duration:100}),o.addClass(i)):(d.slideDown({duration:100}),o.addClass(r))}),$(document).on("click","#allExpand",function(a){a.preventDefault();var e=$(this).children(".fa"),s=e.hasClass(l);e.removeClass(l).removeClass(d),s?($("#sidebar .fa.fa-folder").removeClass("fa-folder").addClass("fa-folder-open"),$("#categories li ul").slideDown({duration:100}),e.addClass(d)):($("#sidebar .fa.fa-folder-open").removeClass("fa-folder-open").addClass("fa-folder"),$("#categories li ul").slideUp({duration:100}),e.addClass(l))})})</script><div id="toTop" class="fa fa-angle-up"></div></aside><section id="main"><article id="post-middlewares/glusterfs/1.glusterfs-客户端源码分析" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><div class="article-meta"><div class="article-category"><i class="fa fa-folder"></i> <a class="article-category-link" href="/categories/middlewares/">middlewares</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/middlewares/glusterfs/">glusterfs</a></div><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/c/">c</a>, <a class="tag-link" href="/tags/gluster/">gluster</a>, <a class="tag-link" href="/tags/glusterfs/">glusterfs</a>, <a class="tag-link" href="/tags/linux/">linux</a></div><div class="article-date"><i class="fa fa-calendar"></i> <a href="/wiki/middlewares/glusterfs/1.glusterfs-客户端源码分析/"><time datetime="2022-06-30T13:28:59.000Z" itemprop="datePublished">2022-06-30</time></a></div><i class="fa fa-bar-chart"></i><span id="busuanzi_container_site_pv"><span id="busuanzi_value_page_pv"></span></span><div class="article-meta-button"> <a href="https://github.com/brewlin/docs/raw/master/source/_posts/middlewares/glusterfs/1.glusterfs-客户端源码分析.md">Source</a></div><div class="article-meta-button"> <a href="https://github.com/brewlin/docs/edit/master/source/_posts/middlewares/glusterfs/1.glusterfs-客户端源码分析.md">Edit</a></div><div class="article-meta-button"> <a href="https://github.com/brewlin/docs/commits/master/source/_posts/middlewares/glusterfs/1.glusterfs-客户端源码分析.md">History</a></div></div><h1 class="article-title" itemprop="name"> glusterfs-客户端源码分析</h1></header><div class="article-entry" itemprop="articleBody"><div id="toc" class="toc-article"> <strong class="toc-title">Catalogue</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、client端架构流程图"><span class="toc-number">1.</span> <span class="toc-text">一、client端架构流程图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-volume-配置语言"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 volume 配置语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-关键字-volume-amp-end-volume-amp-subvolumes"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.2 关键字: volume&amp;end-volume&amp;subvolumes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-关键字-type-amp-option"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.3 关键字: type&amp;option</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-client端功能设计"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 client端功能设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-volume配置获取"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 volume配置获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-volume配置解析"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 volume配置解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、xlator"><span class="toc-number">2.</span> <span class="toc-text">二、xlator</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-xlator实现"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 xlator实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-xlator兼容性"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 xlator兼容性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-核心xlator"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 核心xlator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-io-threads-线程池"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 io-threads: 线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-read-ahead-预读"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 read-ahead: 预读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-write-behind-合并"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3 write-behind: 合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-distribute-分布式hash"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.2.4 distribute: 分布式hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-replicate-副本"><span class="toc-number">2.2.5.</span> <span class="toc-text">2.2.5 replicate: 副本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-6-client-最后一个模块"><span class="toc-number">2.2.6.</span> <span class="toc-text">2.2.6 client: 最后一个模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、一次write的生命周期"><span class="toc-number">3.</span> <span class="toc-text">三、一次write的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-gfapi-so-sdk入口"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 gfapi.so: sdk入口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-将write操作通过xlator树传递下去"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 将write操作通过xlator树传递下去</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-阻塞等待整颗树处理完"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 阻塞等待整颗树处理完</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-meta-autoload-so"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 meta_autoload.so</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-io-stats-so"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 io-stats.so</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-io-threads-so-线程池"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.4 io-threads.so 线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-open-behind-so"><span class="toc-number">3.4.</span> <span class="toc-text">3.5 open-behind.so</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-quick-read-so-快速读"><span class="toc-number">3.5.</span> <span class="toc-text">3.6 quick-read.so 快速读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-dht-writev-核心-分布式hash"><span class="toc-number">3.6.</span> <span class="toc-text">3.7 dht_writev: 核心-分布式hash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-replicate-so-副本机制"><span class="toc-number">3.7.</span> <span class="toc-text">3.8 replicate.so: 副本机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-1-开启事务，提交rpc数据到client-so"><span class="toc-number">3.7.1.</span> <span class="toc-text">3.8.1 开启事务，提交rpc数据到client.so</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-client-so-rpc-client"><span class="toc-number">3.8.</span> <span class="toc-text">3.9 client.so: rpc client</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-1-提交rpc数据到glusterfsd"><span class="toc-number">3.8.1.</span> <span class="toc-text">3.9.1 提交rpc数据到glusterfsd</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、概述"><span class="toc-number">4.</span> <span class="toc-text">四、概述</span></a></li></ol></div><p>glusterfs也属于典型的cs结构，有client端,server端，通过rpc调用通信</p><p>主要的进程有:</p><ul><li>glusterd: 管理进程，管理所有的配置、版本信息</li><li>glusterfsd: server进程，处理所有的文件处理请求并进行落盘</li><li>glusterfs|api: client端，将所有文件的相关操作代理到server端去处理，核心是根据hash算法计算出需要和哪个server端进行通信</li></ul><h1 id="一、client端架构流程图"><a href="#一、client端架构流程图" class="headerlink" title="一、client端架构流程图"></a>一、client端架构流程图</h1><p><img src="/images/middlewares/gluster/client_gluster1.png" alt="image"></p><p>从<code>sdk(client)</code>层就可以看出，所有的功能都进行了分类，并拆分为大量的so动态库实现，最后通过<code>配置</code>将so动态库串联起来组成了sdk的逻辑</p><p>上面所述的<code>配置</code>:可以用通过json、xml、yaml等等来实现，只要能表达关系即可，但在glsuter中通过yacc,lex(./libglusterfs/src/graph.l |graph.y)等词法工具自己实现了一个类似xml的配置语法:<code>volume</code></p><p>来看看上图中sdk对应的volume配置吧,这个配置是通过glusterd获取的，一般glusterd也是保存在本地配置中的（/var/lib/glusterd/vols//trusted*.vol）</p><h2 id="1-1-volume-配置语言"><a href="#1-1-volume-配置语言" class="headerlink" title="1.1 volume 配置语言"></a>1.1 volume 配置语言</h2><p>下面就是一个完整的client端volume配置文件，该文件对应的是一个3副本的配置<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">volume vol1-dr-client-0</span><br><span class="line">    type protocol/client</span><br><span class="line">    option remote-subvolume /replica/brick0</span><br><span class="line">    option remote-host 192.168.1.34</span><br><span class="line">    //省略了很多 option参数</span><br><span class="line">end-volume</span><br><span class="line">volume vol1-dr-client-1</span><br><span class="line">    type protocol/client</span><br><span class="line">    option remote-subvolume /replica/brick1</span><br><span class="line">    option remote-host 192.168.1.34</span><br><span class="line">    //省略很多option参数</span><br><span class="line">end-volume</span><br><span class="line">volume vol1-dr-client-2</span><br><span class="line">    type protocol/client</span><br><span class="line">    option remote-subvolume /replica/brick2</span><br><span class="line">    option remote-host 192.168.1.34</span><br><span class="line">    //省略很多option参数</span><br><span class="line">end-volume</span><br><span class="line">volume vol1-dr-replicate-0</span><br><span class="line">    type cluster/replicate</span><br><span class="line">    //省略很多option参数</span><br><span class="line">    subvolumes vol1-dr-client-0 vol1-dr-client-1 vol1-dr-client-2</span><br><span class="line">end-volume</span><br><span class="line">volume vol1-dr-dht</span><br><span class="line">    type cluster/distribute</span><br><span class="line">    subvolumes vol1-dr-replicate-0</span><br><span class="line">end-volume</span><br><span class="line">volume vol1-dr-write-behind</span><br><span class="line">    type performance/write-behind</span><br><span class="line">    subvolumes vol1-dr-dht</span><br><span class="line">end-volume</span><br><span class="line">volume vol1-dr-read-ahead</span><br><span class="line">    type performance/read-ahead</span><br><span class="line">    subvolumes vol1-dr-write-behind</span><br><span class="line">end-volume</span><br><span class="line">volume vol1-dr-quick-read</span><br><span class="line">    type performance/quick-read</span><br><span class="line">    subvolumes vol1-dr-io-cache</span><br><span class="line">end-volume</span><br><span class="line">volume vol1-dr-open-behind</span><br><span class="line">    type performance/open-behind</span><br><span class="line">    subvolumes vol1-dr-quick-read</span><br><span class="line">end-volume</span><br><span class="line">volume vol1-io-threads</span><br><span class="line">    type performance/io-threads</span><br><span class="line">    subvolumes vol0-open-behind</span><br><span class="line">end-volume</span><br><span class="line">volume vol1-dr</span><br><span class="line">    type debug/io-stats</span><br><span class="line">    subvolumes vol1-io-threads</span><br><span class="line">end-volume</span><br></pre></td></tr></table></figure><p></p><h3 id="1-1-2-关键字-volume-amp-end-volume-amp-subvolumes"><a href="#1-1-2-关键字-volume-amp-end-volume-amp-subvolumes" class="headerlink" title="1.1.2 关键字: volume&amp;end-volume&amp;subvolumes"></a>1.1.2 关键字: volume&amp;end-volume&amp;subvolumes</h3><p>整个配置语法非常简单，就是<code>以volume</code>开头以<code>end-volume</code>结尾的一段被作为一个组件，代码里对应每一个xlator</p><p>多个组件通过<code>subvolumes</code>连接起来</p><p>比如这段<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">volume vol1-io-threads</span><br><span class="line">    type performance/io-threads</span><br><span class="line">    subvolumes vol0-open-behind</span><br><span class="line">end-volume</span><br><span class="line">volume vol1-dr</span><br><span class="line">    type debug/io-stats</span><br><span class="line">    subvolumes vol1-io-threads</span><br><span class="line">end-volume</span><br></pre></td></tr></table></figure><p></p><p>说明 io-threads是io-stats的子节点，整个配置内容会自动被词法解析器(yacc)自动串联为一颗树: 因为subvolumes 可以对应多个子节点</p><p>但实际情况是串联起来后前面是一个链表，只有最后的叶子结点(protocol/client,cluster/replicate)会存在多个<br><img src="/images/middlewares/gluster/client_gluster2.png" alt="image"></p><h3 id="1-1-3-关键字-type-amp-option"><a href="#1-1-3-关键字-type-amp-option" class="headerlink" title="1.1.3 关键字: type&amp;option"></a>1.1.3 关键字: type&amp;option</h3><p>type关键字表明当前是一个什么组件(动态库),比如<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type performance/io-threads</span><br></pre></td></tr></table></figure><p></p><p>代表这个组件是一个 performances/io-threads.so动态库，源代码是在<code>./xlators/performance/io-threads/src</code>下</p><p>不一定这个路径一定是按照源代码目录拆分的，但总体相差不大</p><p>option关键字代表的是参数，因为每个volume对应的是每个单独的动态库组件，他们全部都有统一的<code>init</code>函数，都需要初始化，所以option用于定义默认的初始化参数</p><p>例如:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">volume vol1-dr-client-0</span><br><span class="line">    type protocol/client</span><br><span class="line">    option remote-subvolume /replica/brick0</span><br><span class="line">    option remote-host 192.168.1.34</span><br><span class="line">    //省略了很多 option参数</span><br><span class="line">end-volume</span><br></pre></td></tr></table></figure><p></p><p>代表<code>protocol/client.so</code>动态库需要和server端连接的host为<code>192.168.1.34</code>,需要连接的brick是<code>/replica/brick0</code></p><p>当client.so初始化的时候会经过如下流程</p><ol><li>向glusterd(默认24007端口)查询(/replica/brick0)的配置（服务端口信息）</li><li>拿到brick的端口后，开始建立tcp连接</li><li>后续的读写都通过brick(glusterfsd)进行rpc通信</li></ol><h2 id="1-2-client端功能设计"><a href="#1-2-client端功能设计" class="headerlink" title="1.2 client端功能设计"></a>1.2 client端功能设计</h2><p>整个client的功能完全依赖上面的volume配置，如上图的流程图可得客户端的io流程如下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">io-stats.so -&gt; io-thread.so -&gt; open-behind.so -&gt; quick-read.so -&gt; read-ahead.so </span><br><span class="line">                                                                                |</span><br><span class="line">                                                                                V</span><br><span class="line">&#123; client.so client.so client.so&#125; &lt;- distribute.so &lt;- write-behind.so &lt;-</span><br></pre></td></tr></table></figure><p></p><p>整个io流程还是比较长的，但非常灵活和清晰，你可以很方便的自定义插件插入到整个流程中，或者去除某些节点，只需要更改上面的volume配置即可</p><p><strong>整体设计和nginx的模块化思想差不多，nginx的所有模块都保存在一个数组中，所以io顺序是和数组的索引顺序有关，而gluster的所有模块是根据配置串联为一个树，就这里不同</strong></p><h3 id="1-2-1-volume配置获取"><a href="#1-2-1-volume配置获取" class="headerlink" title="1.2.1 volume配置获取"></a>1.2.1 volume配置获取</h3><p>glusterd服务核心是作为配置管理的服务，当client需要挂载brick时需要通过glusterd获取volume配置，<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//glusterfs/api/src/glfs.c</span><br><span class="line">int glfs_volumes_init (struct glfs *fs)</span><br><span class="line">&#123;  </span><br><span class="line">    //省略</span><br><span class="line">	if (cmd_args-&gt;volfile_server) &#123;</span><br><span class="line">                //去glusterd获取卷信息</span><br><span class="line">		ret = glfs_mgmt_init (fs);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line">    //已经知道卷信息了，直接打开</span><br><span class="line">	fp = get_volfp (fs);</span><br><span class="line">	//..省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ol><li>gfapi.so： sdk初始化的时候，你可以指定volume配置，也可以走默认的通过glusterd获取卷信息</li><li>手动提供volume配置就是上面将的那个demo，接下来看看通过glusterd获取的情况</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//glusterfs/api/src/glfs-mgmt.c  初始化</span><br><span class="line"></span><br><span class="line">int glfs_mgmt_init (struct glfs *fs)</span><br><span class="line">&#123;</span><br><span class="line">    //...省略参数初始化</span><br><span class="line">    </span><br><span class="line">    //创建rpc客户端，基本上所有的cli rpc客户端都是一样的逻辑，</span><br><span class="line">    //1. socket.so -&gt; connect</span><br><span class="line">    //2. request glusterd 查询  volume 信息</span><br><span class="line">	rpc = rpc_clnt_new (options, THIS, THIS-&gt;name, 8);</span><br><span class="line">	if (!rpc) &#123;</span><br><span class="line">		ret = -1;</span><br><span class="line">		gf_msg (THIS-&gt;name, GF_LOG_WARNING, 0,</span><br><span class="line">                        API_MSG_CREATE_RPC_CLIENT_FAILED,</span><br><span class="line">			&quot;failed to create rpc clnt&quot;);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line">    //注册回调函数，然后，socket.so::event_dispatch_handler会一层一层的传送到这里</span><br><span class="line">	ret = rpc_clnt_register_notify (rpc, mgmt_rpc_notify, THIS);</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		gf_msg (THIS-&gt;name, GF_LOG_WARNING, 0,</span><br><span class="line">                        API_MSG_REG_NOTIFY_FUNC_FAILED,</span><br><span class="line">			&quot;failed to register notify function&quot;);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line">    //...省略一些默认逻辑</span><br><span class="line">    </span><br><span class="line">    //开始connect tcp glsterd</span><br><span class="line">	ret = rpc_clnt_start (rpc);</span><br><span class="line">out:</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和glusterd的tcp连接成功后，会在单独的event线程里通过<code>epoll_wait</code>拿到事件后回调<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">mgmt_rpc_notify (struct rpc_clnt *rpc, void *mydata, rpc_clnt_event_t event,</span><br><span class="line">		 void *data)</span><br><span class="line">&#123;</span><br><span class="line">    //省略无关核心内容</span><br><span class="line"></span><br><span class="line">	switch (event) &#123;</span><br><span class="line">	case RPC_CLNT_DISCONNECT: //断开连接</span><br><span class="line">        //省略。。        </span><br><span class="line">             </span><br><span class="line">	case RPC_CLNT_CONNECT: //连接成功了</span><br><span class="line">		rpc_clnt_set_connected (&amp;((struct rpc_clnt*)ctx-&gt;mgmt)-&gt;conn);</span><br><span class="line">        //向glusterd 发起rpc请求去 查 volfile 信息，在以前的老版本都是自己本地配volfile文件的</span><br><span class="line">        //现在的版本都是统一向glusterd去拿</span><br><span class="line">		ret = glfs_volfile_fetch (fs);</span><br><span class="line">		if (ret &amp;&amp; (ctx-&gt;active == NULL)) &#123;</span><br><span class="line">                break;</span><br><span class="line">	default:</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过glfs_volfile_fetch向glusterd发送rpc查询volume配置</p><h3 id="1-2-2-volume配置解析"><a href="#1-2-2-volume配置解析" class="headerlink" title="1.2.2 volume配置解析"></a>1.2.2 volume配置解析</h3><p>sdk（client)的功能取决于volume的配置组合，接下来看看如何初始化的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">glfs_process_volfp (struct glfs *fs, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">	glusterfs_graph_t  *graph = NULL;</span><br><span class="line">	int		    ret = -1;</span><br><span class="line">	xlator_t	   *trav = NULL;</span><br><span class="line">	glusterfs_ctx_t	   *ctx = NULL;</span><br><span class="line"></span><br><span class="line">	ctx = fs-&gt;ctx;</span><br><span class="line">	graph = glusterfs_graph_construct (fp); //通过yacc，lex 词法工具自动解析内容生成一颗树</span><br><span class="line">	if (!graph) &#123;</span><br><span class="line">		gf_msg (&quot;glfs&quot;, GF_LOG_ERROR, errno,</span><br><span class="line">                        API_MSG_GRAPH_CONSTRUCT_FAILED,</span><br><span class="line">                        &quot;failed to construct the graph&quot;);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (trav = graph-&gt;first; trav; trav = trav-&gt;next) &#123;</span><br><span class="line">		if (strcmp (trav-&gt;type, &quot;mount/api&quot;) == 0) &#123;</span><br><span class="line">			gf_msg (&quot;glfs&quot;, GF_LOG_ERROR, EINVAL,</span><br><span class="line">                                API_MSG_API_XLATOR_ERROR,</span><br><span class="line">				&quot;api master xlator cannot be specified &quot;</span><br><span class="line">				&quot;in volume file&quot;);</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = glusterfs_graph_prepare (graph, ctx, fs-&gt;volname);</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		glusterfs_graph_destroy (graph);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = glusterfs_graph_activate (graph, ctx);</span><br><span class="line"></span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		glusterfs_graph_destroy (graph);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        gf_log_dump_graph (fp, graph);</span><br><span class="line"></span><br><span class="line">	ret = 0;</span><br><span class="line">out:</span><br><span class="line">	if (fp)</span><br><span class="line">		fclose (fp);</span><br><span class="line"></span><br><span class="line">	if (!ctx-&gt;active) &#123;</span><br><span class="line">		ret = -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说是通过<code>glusterfs_graph_construct</code>yacc生成的词法解析函数，直接帮你生成了一棵树<code>graph</code><br>在这个过程中，就会为每个xaltor去寻找对应的动态库并加载到内存中绑定对应的对方法和变量<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int xlator_dynload (xlator_t *xl)</span><br><span class="line">&#123;</span><br><span class="line">        //设置动态库所在的路径</span><br><span class="line">        //比如type protocol/client来说</span><br><span class="line">        //name = &quot;/lib64/glusterfs/3.12.15/xlator&quot; + &quot;protocol/client.so&quot;</span><br><span class="line">        //加载动态库</span><br><span class="line">        handle = dlopen (name, RTLD_NOW|RTLD_GLOBAL);</span><br><span class="line">        if (!handle) &#123;</span><br><span class="line">                goto out;</span><br><span class="line">        &#125;</span><br><span class="line">        xl-&gt;dlhandle = handle;</span><br><span class="line">        //获取fops这个符号的地址，可能是函数也可能是全局变量</span><br><span class="line">        if (!(xl-&gt;fops = dlsym (handle, &quot;fops&quot;))) &#123;</span><br><span class="line">                goto out;</span><br><span class="line">        &#125;</span><br><span class="line">        //获取cbks回调函数</span><br><span class="line">        if (!(xl-&gt;cbks = dlsym (handle, &quot;cbks&quot;))) &#123;</span><br><span class="line">                goto out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //class_methods是个变量，所以可以直接加载对应的成员实现</span><br><span class="line">        vtbl = dlsym(handle,&quot;class_methods&quot;);</span><br><span class="line">        if (vtbl) &#123;</span><br><span class="line">                xl-&gt;init        = vtbl-&gt;init;</span><br><span class="line">                xl-&gt;fini        = vtbl-&gt;fini;</span><br><span class="line">                xl-&gt;reconfigure = vtbl-&gt;reconfigure;</span><br><span class="line">                xl-&gt;notify      = vtbl-&gt;notify;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //忽略初始化init不走</span><br><span class="line">        &#125;</span><br><span class="line">        //忽略非重要逻辑</span><br><span class="line"></span><br><span class="line">        //这里比较重要，填充默认函数，设置默认的fop回调函数，fop都是相关文件的操作 create,open,mkdir.touch ....等等</span><br><span class="line">        fill_defaults (xl);</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接下来就是挨个遍历整个树，然后初始化各个xlator<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int glusterfs_graph_activate (glusterfs_graph_t *graph, glusterfs_ctx_t *ctx)</span><br><span class="line">&#123;</span><br><span class="line">        //忽略参数初始化</span><br><span class="line"></span><br><span class="line">        /* XXX: perform init () */</span><br><span class="line">        //调用每个xlator.init() 初始化</span><br><span class="line">        ret = glusterfs_graph_init (graph);</span><br><span class="line">        if (ret) &#123;</span><br><span class="line">                return ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //忽略无关逻辑。。。</span><br><span class="line">        </span><br><span class="line">        //通知父节点，也就是 mount/api.so 所有的xlator已经初始化完毕</span><br><span class="line">        ret = glusterfs_graph_parent_up (graph);</span><br><span class="line">        if (ret) &#123;</span><br><span class="line">                return ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>挨个初始化所有的xaltor<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">glusterfs_graph_init (glusterfs_graph_t *graph)</span><br><span class="line">&#123;</span><br><span class="line">        xlator_t           *trav = NULL;</span><br><span class="line">        int                 ret = -1;</span><br><span class="line"></span><br><span class="line">        trav = graph-&gt;first;</span><br><span class="line">        //对每个xlator进行初始化</span><br><span class="line">        while (trav) &#123;</span><br><span class="line">                ret = xlator_init (trav);</span><br><span class="line">                if (ret) &#123;</span><br><span class="line">                        return ret;</span><br><span class="line">                &#125;</span><br><span class="line">                trav = trav-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>最后就是依次调用每个xlator.init()方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">xlator_init (xlator_t *xl)</span><br><span class="line">&#123;</span><br><span class="line">        int32_t ret = -1;</span><br><span class="line"></span><br><span class="line">        GF_VALIDATE_OR_GOTO (&quot;xlator&quot;, xl, out);</span><br><span class="line"></span><br><span class="line">        if (xl-&gt;mem_acct_init)</span><br><span class="line">                xl-&gt;mem_acct_init (xl);</span><br><span class="line"></span><br><span class="line">        xl-&gt;instance_name = NULL;</span><br><span class="line">        ret = __xlator_init (xl);</span><br><span class="line">        //忽略。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="二、xlator"><a href="#二、xlator" class="headerlink" title="二、xlator"></a>二、xlator</h1><p>gluster将大量的功能进行模块化，每个模块都是单独的动态库，并通过配置将相关模块关联起来提功完整的功能，和这种架构设计相同的还有熟知的nginx，nginx也是想相关功能都拆分为单独的模块，然后最后将相关模块存放到一个数组中，每个http请求过来都会一次顺序的变量整个数组，层层将处理传递个所有的模块</p><p>gluster也是这样，相比nginx，gluster的模块关联要智能一些，它自定义了一种配置语言<code>volume</code>，可以方便的将所有模块关联为一个树，整颗树的的每个节点都能决定改继续传递处理给子节点还是直接终止</p><p>虽说整个关联关系是一颗树，但不是一颗完全平衡的多叉树，更像是一个链表<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                                         -&gt; replicate -&gt; client</span><br><span class="line">                                         |</span><br><span class="line">io-stats -&gt;  io-thread -&gt; ...-&gt; distribute</span><br><span class="line">                                         |</span><br><span class="line">                                         -&gt; replicate -&gt; client</span><br></pre></td></tr></table></figure><p></p><p>每个文件的读写流程依次通过各个xlator传递下去，最终到达client节点，通过rpc和glusterfsd（server)提交操作</p><h2 id="2-1-xlator实现"><a href="#2-1-xlator实现" class="headerlink" title="2.1 xlator实现"></a>2.1 xlator实现</h2><p>接下来分析下xlator的结构<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">xlator</span> &#123;</span></span><br><span class="line">        <span class="comment">/* Built during parsing */</span></span><br><span class="line">        <span class="keyword">char</span>          *name;</span><br><span class="line">        <span class="keyword">char</span>          *type;</span><br><span class="line">        <span class="keyword">char</span>          *instance_name;  <span class="comment">/* Used for multi NFSd */</span></span><br><span class="line">        <span class="keyword">xlator_t</span>      *next; <span class="comment">//下一个节点</span></span><br><span class="line">        <span class="keyword">xlator_t</span>      *prev; <span class="comment">//上一个节点</span></span><br><span class="line">        <span class="keyword">xlator_list_t</span> *parents; <span class="comment">//父节点</span></span><br><span class="line">        <span class="keyword">xlator_list_t</span> *children; <span class="comment">//孩子节点</span></span><br><span class="line">        <span class="keyword">dict_t</span>        *options; <span class="comment">//配置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set after doing dlopen() */</span></span><br><span class="line">        <span class="keyword">void</span>                  *dlhandle; <span class="comment">//动态库</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">xlator_fops</span>    *<span class="title">fops</span>;</span> <span class="comment">//成员函数</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">xlator_cbks</span>    *<span class="title">cbks</span>;</span> <span class="comment">//成员回调</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">xlator_dumpops</span> *<span class="title">dumpops</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>       <span class="title">volume_options</span>;</span>  <span class="comment">/* list of volume_option_t */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span>              (*fini) (<span class="keyword">xlator_t</span> *<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">int32_t</span>           (*init) (<span class="keyword">xlator_t</span> *<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">int32_t</span>           (*reconfigure) (<span class="keyword">xlator_t</span> *<span class="keyword">this</span>, <span class="keyword">dict_t</span> *options);</span><br><span class="line">	    <span class="keyword">int32_t</span>           (*mem_acct_init) (<span class="keyword">xlator_t</span> *<span class="keyword">this</span>);</span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">void</span>               *<span class="keyword">private</span>;</span><br><span class="line">        <span class="comment">//忽略非xlator本身字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>核心的就是dlhandle,fops,cbks,private</p><ul><li>dlhandle: 动态库的句柄</li><li>fops: 动态库里fops变量的地址</li><li>cbks: 动态库里cbks</li><li>private: 当前xlator的私有配置</li></ul><p>总的来说看起来就像是一个对象类型语言中的class结构，将动态库里的函数绑定到xlator的函数指针成员中，动态绑定，在volume配置通过yacc词法解析器解析的时候就会加载对应的动态库并绑定对应的函数或者成员变量到当前xlator(this)成员中</p><p>后续调用当前xlator对应方法如:<code>xlator-&gt;fops-&gt;write(...)</code>实际调用的是对应动态库fops中的成员函数</p><h3 id="2-1-1-xlator兼容性"><a href="#2-1-1-xlator兼容性" class="headerlink" title="2.1.1 xlator兼容性"></a>2.1.1 xlator兼容性</h3><p>来看看标准的一个动态库基本结构,以<code>protocol/client.so</code>为例<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//./xlators/protocol/client/src/client.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span> <span class="params">(<span class="keyword">xlator_t</span> *<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xlator_cbks</span> <span class="title">cbks</span> = &#123;</span></span><br><span class="line">        .forget     = client_forget,</span><br><span class="line">        .release    = client_release,</span><br><span class="line">        .releasedir = client_releasedir</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xlator_fops</span> <span class="title">fops</span> = &#123;</span></span><br><span class="line">        .stat        = client_stat,</span><br><span class="line">        .readlink    = client_readlink,</span><br><span class="line">        .mknod       = client_mknod,</span><br><span class="line">        .mkdir       = client_mkdir,</span><br><span class="line">        .unlink      = client_unlink,</span><br><span class="line">        .rmdir       = client_rmdir,</span><br><span class="line">        .symlink     = client_symlink,</span><br><span class="line">        .rename      = client_rename,</span><br><span class="line">        .link        = client_link,</span><br><span class="line">        .truncate    = client_truncate,</span><br><span class="line">        .open        = client_open,</span><br><span class="line">        .readv       = client_readv,</span><br><span class="line">        .writev      = client_writev,</span><br><span class="line">        <span class="comment">//...太多了省略一些</span></span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xlator_dumpops</span> <span class="title">dumpops</span> = &#123;</span></span><br><span class="line">        .priv      =  client_priv_dump,</span><br><span class="line">        .inodectx  =  client_inodectx_dump,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>每个xlator都基本要有这些函数和变量，最重要的就是<code>fops</code>变量，里面保存了大量的函数指针，指向了大量的文件接口，如果当前xlator不处理相关操作可以不实现对应的方法，在xlator初始化的时候会为他填充一个默认的方法，默认的方法啥也不做，就是将当前操作继续代理给下一个子类节点<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int32_t</span><br><span class="line">default_mkdir (</span><br><span class="line">	call_frame_t *frame,</span><br><span class="line">	xlator_t *this,</span><br><span class="line">	loc_t * loc,</span><br><span class="line">	mode_t mode,</span><br><span class="line">	mode_t umask,</span><br><span class="line">	dict_t * xdata)</span><br><span class="line">&#123;</span><br><span class="line">    //啥也不干，继续传递给下一个节点</span><br><span class="line">	STACK_WIND_TAIL (frame,</span><br><span class="line">			 FIRST_CHILD(this), FIRST_CHILD(this)-&gt;fops-&gt;mkdir,</span><br><span class="line">			 loc, mode, umask, xdata);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="2-2-核心xlator"><a href="#2-2-核心xlator" class="headerlink" title="2.2 核心xlator"></a>2.2 核心xlator</h2><p>接下来分析一下重要的xlator实现，这里只做一个简介，会有专门章节去细细分析每个xlator的具体实现</p><p>接下来就按着处理流程顺序把重要的xlator概述一下</p><h3 id="2-2-1-io-threads-线程池"><a href="#2-2-1-io-threads-线程池" class="headerlink" title="2.2.1 io-threads: 线程池"></a>2.2.1 io-threads: 线程池</h3><p>每个glfs客户端都会默认初始化一个线程池，最小线程为1个，所有读写请求都会丢到线程队列里等待多线程消费<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define IOT_MIN_THREADS         1</span><br><span class="line">#define IOT_DEFAULT_THREADS     16</span><br><span class="line">#define IOT_MAX_THREADS         64</span><br></pre></td></tr></table></figure><p></p><h3 id="2-2-2-read-ahead-预读"><a href="#2-2-2-read-ahead-预读" class="headerlink" title="2.2.2 read-ahead: 预读"></a>2.2.2 read-ahead: 预读</h3><p>预先读取下一块顺序的内存，提高读取效率,将大量的、零散的读取操作集合成少量的、大一些的读操作，这样，减小了网络和磁盘的负载。page-size 描述了块的大小。page-count 描述了预读块的总数量</p><h3 id="2-2-3-write-behind-合并"><a href="#2-2-3-write-behind-合并" class="headerlink" title="2.2.3 write-behind: 合并"></a>2.2.3 write-behind: 合并</h3><p>就是一个aggregator器，会将大量小的写操作合并起来组合成一个更大的写操作后统一提交到glusterfsd 服务端进行落盘，优化并发写操作</p><h3 id="2-2-4-distribute-分布式hash"><a href="#2-2-4-distribute-分布式hash" class="headerlink" title="2.2.4 distribute: 分布式hash"></a>2.2.4 distribute: 分布式hash</h3><p>所有分布式的逻辑靠这个模块实现，也就是分布式的逻辑是靠客户端实现，当前模块会根据文件名进行hash然后进行匹配落到某一个子卷，后续的操作都在该子卷上操作</p><ol><li>子卷是一个副本，那么会将后续的读写请求提交到这个副本模块(replicate)</li><li>子卷是一个brick，那么会将后续的读写请求提交到client模块</li></ol><h3 id="2-2-5-replicate-副本"><a href="#2-2-5-replicate-副本" class="headerlink" title="2.2.5 replicate: 副本"></a>2.2.5 replicate: 副本</h3><p>这里的逻辑也相对简单，会遍历子节点,子节点必定是<code>protocol/client.so</code>模块，依次将对应的操作提交到子节点去</p><h3 id="2-2-6-client-最后一个模块"><a href="#2-2-6-client-最后一个模块" class="headerlink" title="2.2.6 client: 最后一个模块"></a>2.2.6 client: 最后一个模块</h3><p>最后的节点就是一个rpc客户端，和对应的brick（glusterd)保持长链接，将第一</p><h1 id="三、一次write的生命周期"><a href="#三、一次write的生命周期" class="headerlink" title="三、一次write的生命周期"></a>三、一次write的生命周期</h1><p><img src="/images/middlewares/gluster/client_gluster3.png" alt="image"></p><p>其实一次write调用主要分为两个大的操作</p><ul><li><ol><li>lookup: 查找文件是否存在，并基于hash初始化对应文件所在的卷等一些环境初始化</li></ol></li><li><ol start="2"><li>write: 实现文件write</li></ol></li></ul><p>两种操作都是基于xlator整颗树层层传递下去，这里只分析write的过程，两种过程的逻辑差不多</p><h2 id="3-1-gfapi-so-sdk入口"><a href="#3-1-gfapi-so-sdk入口" class="headerlink" title="3.1 gfapi.so: sdk入口"></a>3.1 gfapi.so: sdk入口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//glusterfs/api/src/glfs-fops.c</span><br><span class="line">ssize_t pub_glfs_write (struct glfs_fd *glfd, const void *buf, size_t count, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;mount/api.so glfs_write: \n&quot;);</span><br><span class="line">	struct iovec iov = &#123;0, &#125;;</span><br><span class="line">	ssize_t      ret = 0;</span><br><span class="line"></span><br><span class="line">	iov.iov_base = (void *) buf;</span><br><span class="line">	iov.iov_len = count;</span><br><span class="line"></span><br><span class="line">	ret = pub_glfs_pwritev (glfd, &amp;iov, 1, glfd-&gt;offset, flags);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到xlator的root节点，也就是 meta_autoload.so,这个动态库啥也没干，就是个代理<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ssize_t</span><br><span class="line">pub_glfs_pwritev (struct glfs_fd *glfd, const struct iovec *iovec, int iovcnt,</span><br><span class="line">                  off_t offset, int flags)</span><br><span class="line">&#123;</span><br><span class="line">    //..忽略参数初始化</span><br><span class="line">	//meta_autoload xlator</span><br><span class="line">	subvol = glfs_active_subvol (glfd-&gt;fs);</span><br><span class="line">	if (!subvol) &#123;</span><br><span class="line">		ret = -1;</span><br><span class="line">		errno = EIO;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line">    //这里比较重要，是一个分支，用于解析这个文件是否存在，并初始化一些环境</span><br><span class="line">	fd = glfs_resolve_fd (glfd-&gt;fs, subvol, glfd);</span><br><span class="line">	if (!fd) &#123;</span><br><span class="line">		ret = -1;</span><br><span class="line">		errno = EBADFD;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line">    //准备数据</span><br><span class="line">    ret = glfs_buf_copy (subvol, iovec, iovcnt, &amp;iobref, &amp;iobuf, &amp;iov);</span><br><span class="line">    if (ret)</span><br><span class="line">            goto out;</span><br><span class="line">    //开始准备通过xlator树传递操作</span><br><span class="line">	ret = syncop_writev (subvol, fd, &amp;iov, 1, offset, iobref, flags, NULL,</span><br><span class="line">                             NULL);</span><br><span class="line">        DECODE_SYNCOP_ERR (ret);</span><br><span class="line">    //省略一些收尾操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="3-1-1-将write操作通过xlator树传递下去"><a href="#3-1-1-将write操作通过xlator树传递下去" class="headerlink" title="3.1.1 将write操作通过xlator树传递下去"></a>3.1.1 将write操作通过xlator树传递下去</h3><p>开始将请求通过xlator这颗树进行传递<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">syncop_writev (xlator_t *subvol, fd_t *fd, const struct iovec *vector,</span><br><span class="line">               int32_t count, off_t offset, struct iobref *iobref,</span><br><span class="line">               uint32_t flags, dict_t *xdata_in, dict_t **xdata_out)</span><br><span class="line">&#123;</span><br><span class="line">        struct syncargs args = &#123;0, &#125;;</span><br><span class="line"></span><br><span class="line">        //开始写入数据</span><br><span class="line">        //subvol root(meta-autoload) -&gt; vol2 -&gt; .... vol2client </span><br><span class="line">        //args参数</span><br><span class="line">        //syncop_writev_cbk 回调参数</span><br><span class="line"></span><br><span class="line">        //其实就是执行 subvol-&gt;fops-&gt;writev()函数</span><br><span class="line">        SYNCOP (subvol, (&amp;args), syncop_writev_cbk, subvol-&gt;fops-&gt;writev,</span><br><span class="line">                fd, (struct iovec *) vector, count, offset, flags, iobref,</span><br><span class="line">                xdata_in);</span><br><span class="line"></span><br><span class="line">        //省略参数收尾</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>subvol是meta_autoload.so,接下来就要调用meta_autoload.fops.writev（） 函数,也就是<code>meta_writev</code>函数</p><h3 id="3-1-2-阻塞等待整颗树处理完"><a href="#3-1-2-阻塞等待整颗树处理完" class="headerlink" title="3.1.2 阻塞等待整颗树处理完"></a>3.1.2 阻塞等待整颗树处理完</h3><p>上文用了宏<code>SYNCOP</code>进行xlaotr函数调用，这个会阻塞等待子节点处理完毕在返回<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#define SYNCOP(subvol, stb, cbk, op, params ...) do &#123;                   \</span><br><span class="line">                struct  synctask        *task = NULL;                   \</span><br><span class="line">                call_frame_t            *frame = NULL;                  \</span><br><span class="line">                                                                        \</span><br><span class="line">                task = synctask_get ();                                 \</span><br><span class="line">                stb-&gt;task = task;                                       \</span><br><span class="line">                if (task)                                               \</span><br><span class="line">                        frame = task-&gt;opframe;                          \</span><br><span class="line">                else                                                    \</span><br><span class="line">                        frame = syncop_create_frame (THIS);		\</span><br><span class="line">                                                                        \</span><br><span class="line">                if (task) &#123;                                             \</span><br><span class="line">                        frame-&gt;root-&gt;uid = task-&gt;uid;                   \</span><br><span class="line">                        frame-&gt;root-&gt;gid = task-&gt;gid;                   \</span><br><span class="line">                &#125;                                                       \</span><br><span class="line">                                                                        \</span><br><span class="line">                __yawn (stb);                                           \</span><br><span class="line">                                                                        \</span><br><span class="line">                STACK_WIND_COOKIE (frame, cbk, (void *)stb, subvol,     \</span><br><span class="line">                                   op, params);                         \</span><br><span class="line">                                                                        \</span><br><span class="line">                __yield (stb);                                          \</span><br><span class="line">                if (task)                                               \</span><br><span class="line">                        STACK_RESET (frame-&gt;root);                      \</span><br><span class="line">                else                                                    \</span><br><span class="line">                        STACK_DESTROY (frame-&gt;root);                    \</span><br><span class="line">        &#125; while (0)</span><br></pre></td></tr></table></figure><p></p><p>因为客户端逻辑非synctask模式，只有server端菜会走synctask<br>协程模式，所以客户端需要阻塞<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define __yield(args) do &#123;						\</span><br><span class="line">	if (args-&gt;task) &#123;                                                \</span><br><span class="line">		synctask_yield (args-&gt;task);				\</span><br><span class="line">	&#125; else &#123;                                                        \</span><br><span class="line">		pthread_mutex_lock (&amp;args-&gt;mutex);			\</span><br><span class="line">		&#123;							\</span><br><span class="line">			while (!args-&gt;done)&#123;				\</span><br><span class="line">				pthread_cond_wait (&amp;args-&gt;cond,		\</span><br><span class="line">						   &amp;args-&gt;mutex);	\</span><br><span class="line">                        &#125;   \</span><br><span class="line">		&#125;							\</span><br><span class="line">		pthread_mutex_unlock (&amp;args-&gt;mutex);			\</span><br><span class="line">		pthread_mutex_destroy (&amp;args-&gt;mutex);			\</span><br><span class="line">		pthread_cond_destroy (&amp;args-&gt;cond);			\</span><br><span class="line">	&#125;								\</span><br><span class="line">	&#125; while (0)</span><br></pre></td></tr></table></figure><p></p><p>直接sleep(mutex+cond)，等待异步处理完后唤醒</p><h2 id="3-2-meta-autoload-so"><a href="#3-2-meta-autoload-so" class="headerlink" title="3.2 meta_autoload.so"></a>3.2 meta_autoload.so</h2><p>meta_autoload.so是在volume配置解析的时候手动加上的，所以在配置里是看不到的,手动加入后是作为root节点<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volume vol2-meta_autoload</span><br><span class="line">    type meta/autoload</span><br><span class="line">    subvolumes vol2-io-stats</span><br><span class="line">end-volume</span><br></pre></td></tr></table></figure><p></p><p>子节点是io-stats.so模块<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">meta_writev (call_frame_t *frame, xlator_t *this, fd_t *fd, struct iovec *iov,</span><br><span class="line">	     int count, off_t offset, uint32_t flags, struct iobref *iobref,</span><br><span class="line">	     dict_t *xdata)</span><br><span class="line">&#123;</span><br><span class="line">	//写入文件</span><br><span class="line">	printf(&quot;meta_autoload.so meta_writev\n&quot;);</span><br><span class="line">	//this 是一个xlator，也就是当前的 meta.so 动态库,作为所有xlator的top节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	struct xlator_fops *_fops = NULL;	</span><br><span class="line">	//这里一般都是获取到默认的meta_fops</span><br><span class="line">	//meta_fops 默认的方法都是一个代理，默认代理到xlator的第一个child去执行</span><br><span class="line">	_fops = meta_fops_get (fd-&gt;inode, this);		</span><br><span class="line">	//默认方法在 /libglusterfs/src/default.c 中实现</span><br><span class="line">	_fops-&gt;writev (frame, this, fd,iov,count,offset,flags,iobref,xdata);		</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>meta模块没有对逻辑做处理，实际是调用default的方法继续传递给下一个节点<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//glusterfs/libglusterfs/src/defaults.c</span><br><span class="line">int32_t</span><br><span class="line">default_writev (</span><br><span class="line">	call_frame_t *frame,</span><br><span class="line">	xlator_t *this,</span><br><span class="line">	fd_t * fd,</span><br><span class="line">	struct iovec * vector,</span><br><span class="line">	int32_t count,</span><br><span class="line">	off_t off,</span><br><span class="line">	uint32_t flags,</span><br><span class="line">	struct iobref * iobref,</span><br><span class="line">	dict_t * xdata)</span><br><span class="line">&#123;</span><br><span class="line">	//直接调用第一个child节点 xlator-&gt;chilid-&gt;fops-&gt;writev 方法</span><br><span class="line">	STACK_WIND_TAIL (frame,</span><br><span class="line">			 FIRST_CHILD(this), FIRST_CHILD(this)-&gt;fops-&gt;writev,</span><br><span class="line">			 fd, vector, count, off, flags, iobref, xdata);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>FIRST_CHILD(this) = io-stats.so, 接下来就是调用<code>io-stats-&gt;fops-&gt;writev(io_stats_writev)</code>函数</p><h2 id="3-3-io-stats-so"><a href="#3-3-io-stats-so" class="headerlink" title="3.3 io-stats.so"></a>3.3 io-stats.so</h2><p>这个就是个debug模块，也是啥都没干，继续传递给下一个节点<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//glusterfs/xlators/debug/io-stats/src/io-stats.c</span><br><span class="line">int</span><br><span class="line">io_stats_writev (call_frame_t *frame, xlator_t *this,</span><br><span class="line">                 fd_t *fd, struct iovec *vector,</span><br><span class="line">                 int32_t count, off_t offset,</span><br><span class="line">                 uint32_t flags, struct iobref *iobref, dict_t *xdata)</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;debug/io-stats.so: io_stats_writev\n&quot;);</span><br><span class="line">        int                 len = 0;</span><br><span class="line">        //找到fd</span><br><span class="line">        if (fd-&gt;inode)</span><br><span class="line">                frame-&gt;local = fd-&gt;inode;</span><br><span class="line">        //获取数据长度</span><br><span class="line">        len = iov_length (vector, count);</span><br><span class="line"></span><br><span class="line">        ios_bump_write (this, fd, len);</span><br><span class="line">        START_FOP_LATENCY (frame);</span><br><span class="line"></span><br><span class="line">        //开始调用下一个节点</span><br><span class="line">        STACK_WIND (frame, io_stats_writev_cbk,</span><br><span class="line">                    FIRST_CHILD(this),</span><br><span class="line">                    FIRST_CHILD(this)-&gt;fops-&gt;writev,</span><br><span class="line">                    fd, vector, count, offset, flags, iobref, xdata);</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>FIRST_CHILD(this) == xlators(io-threads.so) ，子节点就是<code>io-threads</code></p><p>接下来就是调用io-threads.so::iot_writev 方法</p><h3 id="3-4-io-threads-so-线程池"><a href="#3-4-io-threads-so-线程池" class="headerlink" title="3.4 io-threads.so 线程池"></a>3.4 io-threads.so 线程池</h3><p>这边会将操作提交到worker线程异步去执行<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//glusterfs/xlators/performance/io-threads/src/io-threads.c</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">iot_writev (call_frame_t *frame, xlator_t *this, fd_t *fd,</span><br><span class="line">            struct iovec *vector, int32_t count, off_t offset,</span><br><span class="line">            uint32_t flags, struct iobref *iobref, dict_t *xdata)</span><br><span class="line">&#123;</span><br><span class="line">        call_stub_t     *__stub     = NULL;                            </span><br><span class="line">        int              __ret      = -1;                              </span><br><span class="line">        //将stub投递到io-thread 线程池中去，真正执行的是 default_writev_resume                                            </span><br><span class="line">        __stub = fop_writev_stub(frame, default_writev_resume, fd,vector,count,offset,flags,iobref,xdata);  </span><br><span class="line">        if (!__stub) &#123;                                                 </span><br><span class="line">                __ret = -ENOMEM;                                       </span><br><span class="line">                goto out;                                              </span><br><span class="line">        &#125;                                                              </span><br><span class="line">                                                                        </span><br><span class="line">        __ret = iot_schedule (frame, this, __stub);                    </span><br><span class="line">                                                                        </span><br><span class="line">out:                                                                   </span><br><span class="line">        if (__ret &lt; 0) &#123;                                               </span><br><span class="line">                default_writev_failure_cbk (frame, -__ret);          </span><br><span class="line">                if (__stub != NULL) &#123;                                  </span><br><span class="line">                        call_stub_destroy (__stub);                    </span><br><span class="line">                &#125;                                                      </span><br><span class="line">        &#125;                                                              </span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>worker接收到任务后开始执行default_writev_resume ，继续调用下一个子节点<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//glusterfs/libglusterfs/src/defaults.c</span><br><span class="line"></span><br><span class="line">int32_t default_writev_resume (call_frame_t *frame, xlator_t *this, fd_t * fd,</span><br><span class="line">	struct iovec * vector,</span><br><span class="line">	int32_t count,</span><br><span class="line">	off_t off,</span><br><span class="line">	uint32_t flags,</span><br><span class="line">	struct iobref * iobref,</span><br><span class="line">	dict_t * xdata)</span><br><span class="line">&#123;</span><br><span class="line">	//独立线程开始调用 xlator的子节点</span><br><span class="line">	STACK_WIND (frame, default_writev_cbk,</span><br><span class="line">		    FIRST_CHILD(this), FIRST_CHILD(this)-&gt;fops-&gt;writev,</span><br><span class="line">		    fd, vector, count, off, flags, iobref, xdata);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>io-thread节点的子节点依然只有一个<code>open-behind.so</code>, 子节点的方法FIRST_CHILD(this)-&gt;fops-&gt;writev == ob_writev</p><h2 id="3-5-open-behind-so"><a href="#3-5-open-behind-so" class="headerlink" title="3.5 open-behind.so"></a>3.5 open-behind.so</h2><p>对于写请求基本上等于啥也没干，就是个代理节点<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//glusterfs/xlators/performance/open-behind/src/open-behind.c</span><br><span class="line"></span><br><span class="line">int ob_writev (call_frame_t *frame, xlator_t *this, fd_t *fd, struct iovec *iov,</span><br><span class="line">	   int count, off_t offset, uint32_t flags, struct iobref *iobref,</span><br><span class="line">	   dict_t *xdata)</span><br><span class="line">&#123;</span><br><span class="line">	call_stub_t  *stub = NULL;</span><br><span class="line">	//meta-autoload.so  io-thread.so  open-behind.so 啥事没干，代理了一下后直接调用default_writev_resume 继续传递给下一个child节点</span><br><span class="line">	stub = fop_writev_stub (frame, default_writev_resume, fd, iov, count,</span><br><span class="line">				offset, flags, iobref, xdata);</span><br><span class="line">	if (!stub)</span><br><span class="line">		goto err;</span><br><span class="line">	open_and_resume (this, fd, stub);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">err:</span><br><span class="line">	STACK_UNWIND_STRICT (writev, frame, -1, ENOMEM, 0, 0, 0);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>继续代理到子节点去处理<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//glusterfs/libglusterfs/src/defaults.c</span><br><span class="line">int32_t</span><br><span class="line">default_writev_resume (call_frame_t *frame, xlator_t *this, fd_t * fd,</span><br><span class="line">	struct iovec * vector,</span><br><span class="line">	int32_t count,</span><br><span class="line">	off_t off,</span><br><span class="line">	uint32_t flags,</span><br><span class="line">	struct iobref * iobref,</span><br><span class="line">	dict_t * xdata)</span><br><span class="line">&#123;</span><br><span class="line">	//独立线程池开始调用 xlator的子节点</span><br><span class="line">	STACK_WIND (frame, default_writev_cbk,</span><br><span class="line">		    FIRST_CHILD(this), FIRST_CHILD(this)-&gt;fops-&gt;writev,</span><br><span class="line">		    fd, vector, count, off, flags, iobref, xdata);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>子节点是quick-read.so，FIRST_CHILD(this)-&gt;Fops-&gt;writev == qr_writev()</p><h2 id="3-6-quick-read-so-快速读"><a href="#3-6-quick-read-so-快速读" class="headerlink" title="3.6 quick-read.so 快速读"></a>3.6 quick-read.so 快速读</h2><p>当前组件相当于一个缓存层，为了加速读的效率，会带有缓存，那么写入的时候必然导致不一致，需要清除缓存<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//glusterfs/xlators/performance/quick-read/src/quick-read.c</span><br><span class="line">int</span><br><span class="line">qr_writev (call_frame_t *frame, xlator_t *this, fd_t *fd, struct iovec *iov,</span><br><span class="line">	   int count, off_t offset, uint32_t flags, struct iobref *iobref,</span><br><span class="line">	   dict_t *xdata)</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;performance/quick-read.so: qr_writev\n&quot;); </span><br><span class="line">	qr_inode_prune (this, fd-&gt;inode);</span><br><span class="line">        //继续调用下面一层 performance/io-cache.so</span><br><span class="line">	STACK_WIND (frame, default_writev_cbk,</span><br><span class="line">		    FIRST_CHILD (this), FIRST_CHILD (this)-&gt;fops-&gt;writev,</span><br><span class="line">		    fd, iov, count, offset, flags, iobref, xdata);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ol><li>清理缓存</li><li>将请求继续代理到下一个子节点</li><li>子节点是: readdir-ahead.so</li></ol><p>因为readdir-ahead没有实现writev函数，所以用的默认的default函数，所以跳过这里的介绍，直接去下一个节点 distribute.so,对应的方法是dht_writev</p><h2 id="3-7-dht-writev-核心-分布式hash"><a href="#3-7-dht-writev-核心-分布式hash" class="headerlink" title="3.7 dht_writev: 核心-分布式hash"></a>3.7 dht_writev: 核心-分布式hash</h2><p>在这里会决定当前文件写入到那个子卷，对应的哪些brick副本</p><p>为了专注写流程的生命周期，distribute.so的核心实现会另起文章分析，这里只需要知道，在调用dht_writev前，有一个lookup过程，就已经缓存好当前文件对应的是哪个子卷(xlator)</p><p>所以这里通过<code>local-&gt;cached_subvol</code>，直接就拿到了对应的子卷,不用在去临时计算hash分布找出对应的子卷</p><p>备注： 上面说的子卷就是replicate.so 或者不是副本的情况下就是 client.so<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">dht_writev (call_frame_t *frame, xlator_t *this, fd_t *fd,</span><br><span class="line">            struct iovec *vector, int count, off_t off, uint32_t flags,</span><br><span class="line">            struct iobref *iobref, dict_t *xdata)</span><br><span class="line">&#123;</span><br><span class="line">        xlator_t     *subvol   = NULL;</span><br><span class="line">        int           op_errno = -1;</span><br><span class="line">        dht_local_t  *local    = NULL;</span><br><span class="line"></span><br><span class="line">        VALIDATE_OR_GOTO (frame, err);</span><br><span class="line">        VALIDATE_OR_GOTO (this, err);</span><br><span class="line">        VALIDATE_OR_GOTO (fd, err);</span><br><span class="line">        //这里比较奇葩</span><br><span class="line">        //this-&gt;child 就是protocol/client xlator</span><br><span class="line">        //但是没有和其他组件那样直接就去调用this-&gt;child-&gt;fops-&gt;writev() 而是有一个缓存</span><br><span class="line">        //从缓存中拿到 subvol 是 哪个protocol/client </span><br><span class="line">        local = dht_local_init (frame, NULL, fd, GF_FOP_WRITE);</span><br><span class="line">        if (!local) &#123;</span><br><span class="line"></span><br><span class="line">                op_errno = ENOMEM;</span><br><span class="line">                goto err;</span><br><span class="line">        &#125;</span><br><span class="line">        //缓存的子卷信息</span><br><span class="line">        subvol = local-&gt;cached_subvol;</span><br><span class="line">        if (!subvol) &#123;</span><br><span class="line">                gf_msg_debug (this-&gt;name, 0,</span><br><span class="line">                              &quot;no cached subvolume for fd=%p&quot;, fd);</span><br><span class="line">                op_errno = EINVAL;</span><br><span class="line">                goto err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (xdata)</span><br><span class="line">                local-&gt;xattr_req = dict_ref (xdata);</span><br><span class="line"></span><br><span class="line">        local-&gt;rebalance.vector = iov_dup (vector, count);</span><br><span class="line">        local-&gt;rebalance.offset = off;</span><br><span class="line">        local-&gt;rebalance.count = count;</span><br><span class="line">        local-&gt;rebalance.flags = flags;</span><br><span class="line">        local-&gt;rebalance.iobref = iobref_ref (iobref);</span><br><span class="line">        local-&gt;call_cnt = 1;</span><br><span class="line">        //1. 当replica=3  brick = 6 ，说明有两个子卷</span><br><span class="line">        //2. 说明当前distribute组件的作用就是随机分布选取一个子卷存储</span><br><span class="line">        //3. 子卷里需要循环将文件写入到3个brick节点落盘</span><br><span class="line"></span><br><span class="line">        //开始调用子卷的writev操作</span><br><span class="line">        STACK_WIND_COOKIE (frame, dht_writev_cbk, subvol, subvol,</span><br><span class="line">                           subvol-&gt;fops-&gt;writev, fd,</span><br><span class="line">                           local-&gt;rebalance.vector,</span><br><span class="line">                           local-&gt;rebalance.count,</span><br><span class="line">                           local-&gt;rebalance.offset,</span><br><span class="line">                           local-&gt;rebalance.flags,</span><br><span class="line">                           local-&gt;rebalance.iobref, local-&gt;xattr_req);</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">        op_errno = (op_errno == -1) ? errno : op_errno;</span><br><span class="line">        DHT_STACK_UNWIND (writev, frame, -1, op_errno, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>因为我们当前的测试是一个三副本，所以下一个节点是一个replicate.so子卷,对应的方法是<code>afr_writev</code></p><h2 id="3-8-replicate-so-副本机制"><a href="#3-8-replicate-so-副本机制" class="headerlink" title="3.8 replicate.so: 副本机制"></a>3.8 replicate.so: 副本机制</h2><p>因为我们当前的测试时基于三副本，所以当前的replicate的子节点有3个client.so,分别对应连接这3个glusterfsd(brick) 进程</p><p>当需要写入文件时，需要同时写入到3个client.so，最终落盘到三个brick</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//glusterfs/xlators/cluster/afr/src/afr-inode-write.c</span><br><span class="line">int</span><br><span class="line">afr_writev (call_frame_t *frame, xlator_t *this, fd_t *fd,</span><br><span class="line">            struct iovec *vector, int32_t count, off_t offset,</span><br><span class="line">            uint32_t flags, struct iobref *iobref, dict_t *xdata)</span><br><span class="line">&#123;</span><br><span class="line">    //忽略参数的组装</span><br><span class="line"></span><br><span class="line">	local-&gt;append_write = _gf_true;</span><br><span class="line"></span><br><span class="line">	local-&gt;stable_write = !!((fd-&gt;flags|flags)&amp;(O_SYNC|O_DSYNC));</span><br><span class="line"></span><br><span class="line">        afr_fix_open (fd, this);</span><br><span class="line"></span><br><span class="line">        afr_do_writev (frame, this);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">out:</span><br><span class="line">	AFR_STACK_UNWIND (writev, frame, -1, op_errno, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-1-开启事务，提交rpc数据到client-so"><a href="#3-8-1-开启事务，提交rpc数据到client-so" class="headerlink" title="3.8.1 开启事务，提交rpc数据到client.so"></a>3.8.1 开启事务，提交rpc数据到client.so</h3><p>开始遍历三个client.so，将数据通过rpc，提交到三个glsuterfsd server去，最终落盘<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//glusterfs/xlators/cluster/afr/src/afr-inode-write.c</span><br><span class="line">int</span><br><span class="line">afr_do_writev (call_frame_t *frame, xlator_t *this)</span><br><span class="line">&#123;</span><br><span class="line">        //忽略参数初始化</span><br><span class="line"></span><br><span class="line">        local-&gt;op = GF_FOP_WRITE;</span><br><span class="line"></span><br><span class="line">        local-&gt;transaction.wind   = afr_writev_wind;</span><br><span class="line">        local-&gt;transaction.fop    = __afr_txn_write_fop;</span><br><span class="line">        local-&gt;transaction.done   = __afr_txn_write_done;</span><br><span class="line">        local-&gt;transaction.unwind = afr_transaction_writev_unwind;</span><br><span class="line"></span><br><span class="line">        //忽略参数准备</span><br><span class="line">        //开始事务</span><br><span class="line">        ret = afr_transaction (transaction_frame, this, AFR_DATA_TRANSACTION);</span><br><span class="line">        //忽略错误处理，</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">__afr_txn_write_fop (call_frame_t *frame, xlator_t *this)</span><br><span class="line">&#123;</span><br><span class="line">        //忽略参数初始化</span><br><span class="line"></span><br><span class="line">        //开始遍历三个client.so，写入数据</span><br><span class="line">        local-&gt;call_count = call_count;</span><br><span class="line">        for (i = 0; i &lt; priv-&gt;child_count; i++) &#123;</span><br><span class="line">                if (local-&gt;transaction.pre_op[i] &amp;&amp; !failed_subvols[i]) &#123;</span><br><span class="line">			local-&gt;transaction.wind (frame, this, i);</span><br><span class="line"></span><br><span class="line">                        if (!--call_count)</span><br><span class="line">                                break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="3-9-client-so-rpc-client"><a href="#3-9-client-so-rpc-client" class="headerlink" title="3.9 client.so: rpc client"></a>3.9 client.so: rpc client</h2><p>找到对应的rpc方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int32_t</span><br><span class="line">client_writev (call_frame_t *frame, xlator_t *this, fd_t *fd,</span><br><span class="line">               struct iovec *vector, int32_t count, off_t off,</span><br><span class="line">               uint32_t flags, struct iobref *iobref, dict_t *xdata)</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;protocol/client.so: client_writev\n&quot;);</span><br><span class="line">        int          ret  = -1;</span><br><span class="line">        clnt_conf_t *conf = NULL;</span><br><span class="line">        rpc_clnt_procedure_t *proc = NULL;</span><br><span class="line">        clnt_args_t  args = &#123;0,&#125;;</span><br><span class="line">        //私有配置</span><br><span class="line">        conf = this-&gt;private;</span><br><span class="line">        if (!conf || !conf-&gt;fops)</span><br><span class="line">                goto out;</span><br><span class="line"></span><br><span class="line">        args.fd     = fd;</span><br><span class="line">        args.vector = vector;</span><br><span class="line">        args.count  = count;</span><br><span class="line">        args.offset = off;</span><br><span class="line">        args.size   = iov_length (vector, count);</span><br><span class="line">        args.flags  = flags;</span><br><span class="line">        args.iobref = iobref;</span><br><span class="line">        args.xdata = xdata;</span><br><span class="line"></span><br><span class="line">        client_filter_o_direct (conf, &amp;args.flags);</span><br><span class="line">        //拿到rpc wirte的 路由信息</span><br><span class="line">        proc = &amp;conf-&gt;fops-&gt;proctable[GF_FOP_WRITE];</span><br><span class="line">        if (proc-&gt;fn)</span><br><span class="line">                ret = proc-&gt;fn (frame, this, &amp;args);</span><br><span class="line">out:</span><br><span class="line">        if (ret)</span><br><span class="line">                STACK_UNWIND_STRICT (writev, frame, -1, ENOTCONN, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="3-9-1-提交rpc数据到glusterfsd"><a href="#3-9-1-提交rpc数据到glusterfsd" class="headerlink" title="3.9.1 提交rpc数据到glusterfsd"></a>3.9.1 提交rpc数据到glusterfsd</h3><p>核心rpc处理逻辑<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int32_t</span><br><span class="line">client3_3_writev (call_frame_t *frame, xlator_t *this, void *data)</span><br><span class="line">&#123;</span><br><span class="line">        clnt_args_t    *args     = NULL;</span><br><span class="line">        clnt_conf_t    *conf     = NULL;</span><br><span class="line">        gfs3_write_req  req      = &#123;&#123;0,&#125;,&#125;;</span><br><span class="line">        int             op_errno = ESTALE;</span><br><span class="line">        int             ret      = 0;</span><br><span class="line"></span><br><span class="line">        if (!frame || !this || !data)</span><br><span class="line">                goto unwind;</span><br><span class="line"></span><br><span class="line">        args = data;</span><br><span class="line">        conf = this-&gt;private;</span><br><span class="line">        //预处理 ，准备写入的数据包</span><br><span class="line">        ret = client_pre_writev (this, &amp;req, args-&gt;fd, args-&gt;size,</span><br><span class="line">                                 args-&gt;offset, args-&gt;flags, &amp;args-&gt;xdata);</span><br><span class="line"></span><br><span class="line">        if (ret) &#123;</span><br><span class="line">                op_errno = -ret;</span><br><span class="line">                goto unwind;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = client_fd_fop_prepare_local (frame, args-&gt;fd, req.fd);</span><br><span class="line">        if (ret) &#123;</span><br><span class="line">                op_errno = -ret;</span><br><span class="line">                goto unwind;</span><br><span class="line">        &#125;</span><br><span class="line">        //开始发送写入数据的请求 到远程 glusterd rpc server处理</span><br><span class="line">        ret = client_submit_vec_request (this, &amp;req, frame, conf-&gt;fops,</span><br><span class="line">                                         GFS3_OP_WRITE, client3_3_writev_cbk,</span><br><span class="line">                                         args-&gt;vector, args-&gt;count,</span><br><span class="line">                                         args-&gt;iobref,</span><br><span class="line">                                         (xdrproc_t)xdr_gfs3_write_req);</span><br><span class="line">        if (ret) &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * If the lower layers fail to submit a request, they&apos;ll also</span><br><span class="line">                 * do the unwind for us (see rpc_clnt_submit), so don&apos;t unwind</span><br><span class="line">                 * here in such cases.</span><br><span class="line">                 */</span><br><span class="line">                gf_msg (this-&gt;name, GF_LOG_WARNING, 0, PC_MSG_FOP_SEND_FAILED,</span><br><span class="line">                        &quot;failed to send the fop&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //发送到远程后 释放客户端内存</span><br><span class="line">        GF_FREE (req.xdata.xdata_val);</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">unwind:</span><br><span class="line">        CLIENT_STACK_UNWIND (writev, frame, -1, op_errno, NULL, NULL, NULL);</span><br><span class="line">        GF_FREE (req.xdata.xdata_val);</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="四、概述"><a href="#四、概述" class="headerlink" title="四、概述"></a>四、概述</h1><p>到这里总共分析了有</p><ol><li>volume配置语言: 基于lex,bison简单的实现了一个类xml的配置</li><li>volume配置中每个节点对应的xlator作用</li><li>sdk整体逻辑需要依赖volume配置的依赖关系</li><li>最终通过一个write的io流程讲解整个client端的主功能</li></ol><p>像nginx一样，如果你要自定义一个插件介入到api的生命周期中，你只需要自己实现一个xlator，然后加入到配置中即可</p><p>总结出核心的副本，hash，分布式整个逻辑都是放到client端的，server端(glusterfsd)基本上只负责将文件高效的落盘到linux文件系统对应路径上</p><p>当然当前文章只进行了整体的概括，细节需要单独的文章分析，比如ddistribute.so核心实现，event调度器实现，server端的协程调度器实现。。等等后续在单独写文章分析了</p></div><footer class="article-footer"></footer></div></article><nav id="article-nav"> <a href="/wiki/compiler/rust协程_调度器实现/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">rust_无栈协程&amp;调度器实现</div></a></nav><script type="text/javascript">!function(){var e=window.location.href,r=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var o="//api.share.baidu.com/s.gif";r?(o+="?r="+encodeURIComponent(document.referrer),e&&(o+="&l="+e)):e&&(o+="?l="+e),(new Image).src=o}}(window)</script></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"> brewlin &copy; 2022 <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a><br> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten">wikitten</a><br><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> |<span id="busuanzi_container_site_pv"><i class="fa fa-user"><span id="busuanzi_value_site_uv"></span></i></span></div></div></footer><script src="/libs/lightgallery/js/lightgallery.min.js"></script><script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script><script src="/libs/lightgallery/js/lg-pager.min.js"></script><script src="/libs/lightgallery/js/lg-autoplay.min.js"></script><script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script><script src="/libs/lightgallery/js/lg-zoom.min.js"></script><script src="/libs/lightgallery/js/lg-hash.min.js"></script><script src="/libs/lightgallery/js/lg-share.min.js"></script><script src="/libs/lightgallery/js/lg-video.min.js"></script><script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/main.js"></script></div></body>