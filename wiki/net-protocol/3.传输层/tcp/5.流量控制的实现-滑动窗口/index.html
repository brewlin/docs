<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>流量控制-滑动窗口 | Brewlin&#39;s Wiki</title><meta name="keywords" content="go,tcp,protocol"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="接收端在给发送端回 ACK 中会汇报自己的 AdvertisedWindow，而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。要明确的是滑动窗口分为两个窗口，接收窗口和发送窗口 @接受窗口接收窗口不仅可以限制发送端发送的速率，还可以提高效率，因为接收窗口的机制，可以允许发送端一次多发送几个片段，而不必等候 ACK，而且可以允许等待一定情况下的乱序， 比如说先缓存提前到的数据，然后"><meta name="keywords" content="go,tcp,protocol"><meta property="og:type" content="article"><meta property="og:title" content="流量控制-滑动窗口"><meta property="og:url" content="http://blog.huido.site/wiki/net-protocol/3.传输层/tcp/5.流量控制的实现-滑动窗口/index.html"><meta property="og:site_name" content="Brewlin&#39;s Wiki"><meta property="og:description" content="接收端在给发送端回 ACK 中会汇报自己的 AdvertisedWindow，而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。要明确的是滑动窗口分为两个窗口，接收窗口和发送窗口 @接受窗口接收窗口不仅可以限制发送端发送的速率，还可以提高效率，因为接收窗口的机制，可以允许发送端一次多发送几个片段，而不必等候 ACK，而且可以允许等待一定情况下的乱序， 比如说先缓存提前到的数据，然后"><meta property="og:locale" content="en"><meta property="og:updated_time" content="2020-01-05T12:15:41.203Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="流量控制-滑动窗口"><meta name="twitter:description" content="接收端在给发送端回 ACK 中会汇报自己的 AdvertisedWindow，而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。要明确的是滑动窗口分为两个窗口，接收窗口和发送窗口 @接受窗口接收窗口不仅可以限制发送端发送的速率，还可以提高效率，因为接收窗口的机制，可以允许发送端一次多发送几个片段，而不必等候 ACK，而且可以允许等待一定情况下的乱序， 比如说先缓存提前到的数据，然后"><link rel="alternate" href="/atom.xml" title="Brewlin&#39;s Wiki" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/libs/open-sans/styles.css"><link rel="stylesheet" href="/libs/source-code-pro/styles.css"><link rel="stylesheet" href="/css/style.css"><script src="/libs/jquery/2.1.3/jquery.min.js"></script><script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script><link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css"><link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head></html><body><div id="container"><header id="header"><div id="header-main" class="header-inner"><div class="outer"><a href="/" id="logo"><i class="logo"></i> <span class="site-title">Brewlin&#39;s Wiki</span></a><nav id="main-nav"> <a class="main-nav-link" href="/">首页</a> <a class="main-nav-link" href="/archives">归档</a> <a class="main-nav-link" href="/categories">分类</a> <a class="main-nav-link" href="/tags">标签</a> <a class="main-nav-link" href="/about">关于</a></nav><div id="search-form-wrap"><form class="search-form"> <input type="text" class="ins-search-input search-form-input" placeholder="Search"> <button type="submit" class="search-form-submit"></button></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"> <input type="text" class="ins-search-input" placeholder="Type something..."><span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script></div></div></div><div id="main-nav-mobile" class="header-sub header-inner"><table class="menu outer"><tr><td><a class="main-nav-link" href="/">首页</a></td><td><a class="main-nav-link" href="/archives">归档</a></td><td><a class="main-nav-link" href="/categories">分类</a></td><td><a class="main-nav-link" href="/tags">标签</a></td><td><a class="main-nav-link" href="/about">关于</a></td><td><div class="search-form"> <input type="text" class="ins-search-input search-form-input" placeholder="Search"></div></td></tr></table></div></header><div class="outer"><aside id="sidebar"><div class="widget-wrap" id="categories"><h3 class="widget-title"> <span>categories</span> &nbsp;<a id="allExpand" href="#"><i class="fa fa-angle-double-down fa-2x"></i></a></h3><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; c-ext</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; coroutine</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/coroutine/协程/">协程</a></li><li class="file"><a href="/wiki/c-ext/coroutine/协程tcp服务/">协程tcp服务</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; memory</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/memory/共享内存/">共享内存</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; process</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/process/进程管理/">进程管理</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; timer</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/timer/定时器/">定时器</a></li></ul></li><li class="file"><a href="/wiki/c-ext/index/">c扩展</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; go-stl</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; graph</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/graph/图论/">图论算法</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; hash</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/hash/hash_code/">哈希Code生成</a></li><li class="file"><a href="/wiki/go-stl/hash/hash_list/">哈希链表</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; queue</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/queue/list/">LIST</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; raft</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/raft/raft分布式一致性原理(一)/">raft分布式一致性原理(一)</a></li><li class="file"><a href="/wiki/go-stl/raft/raft分布式一致性原理(二)/">raft分布式一致性原理(二)</a></li><li class="file"><a href="/wiki/go-stl/raft/相关资料/">相关资料</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; tree</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/tree/binary-search/">二分搜索树</a></li><li class="file"><a href="/wiki/go-stl/tree/reds-black-tree/">红黑树</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; trie</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/trie/trie/">字典树</a></li></ul></li><li class="file"><a href="/wiki/go-stl/index/">GO标准库和算法应用</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; im-cloud</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 1.前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/1.前言/1.安装部署/">安装部署</a></li><li class="file"><a href="/wiki/im-cloud/1.前言/2.并发压测对比/">并发压测对比</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 2.版本</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/2.版本/1.版本兼容/">版本兼容</a></li><li class="file"><a href="/wiki/im-cloud/2.版本/2.单进程全协程化版/">单线程全协程化版</a></li><li class="file"><a href="/wiki/im-cloud/2.版本/3.多进程worker版/">多进程worker版本</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 3.底层实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.底层实现/1.im-cloud/">im-cloud</a></li><li class="file"><a href="/wiki/im-cloud/3.底层实现/2.通讯协议/">通讯协议</a></li><li class="file"><a href="/wiki/im-cloud/3.底层实现/4.job节点/">job节点实现</a></li><li class="file"><a href="/wiki/im-cloud/3.底层实现/5.logic节点/">logic节点实现</a></li><li class="file"><a href="/wiki/im-cloud/3.底层实现/3.cloud节点/">cloud节点实现</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 4.应用实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/4.应用实现/1.推送实现/">推送实现</a></li><li class="file"><a href="/wiki/im-cloud/4.应用实现/2.服务发现/">服务发现</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 5.组件实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/5.组件实现/1.连接池实现/">连接池实现</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 6.开放接口</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/6.开放接口/logic开放接口/">Logic 节点开放接口</a></li></ul></li><li class="file"><a href="/wiki/im-cloud/index/">im-cloud 分布式推送中间件</a></li></ul></li><li class="directory open"><a href="#" data-role="directory"><i class="fa fa-folder-open"></i> &nbsp; net-protocol</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 1.前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/1.前言/1.快速开始/">快速开始</a></li><li class="file"><a href="/wiki/net-protocol/1.前言/2.协议分层模型/">协议分层模型</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 2.应用层</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; http</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/2.应用层/http/1.http协议解析/">http协议解析</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; websocket</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/2.应用层/websocket/2.websocket算法/">websocket算法</a></li><li class="file"><a href="/wiki/net-protocol/2.应用层/websocket/1.websocket协议解析/">websocket协议解析</a></li><li class="file"><a href="/wiki/net-protocol/2.应用层/websocket/3.websocket实现/">websocket实现</a></li></ul></li><li class="file"><a href="/wiki/net-protocol/2.应用层/应用层前世今生/">应用层前世今生</a></li></ul></li><li class="directory open"><a href="#" data-role="directory"><i class="fa fa-folder-open"></i> &nbsp; 3.传输层</a><ul class="unstyled" id="tree"><li class="directory open"><a href="#" data-role="directory"><i class="fa fa-folder-open"></i> &nbsp; tcp</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/3.传输层/tcp/2.流量控制/">tcp流量控制</a></li><li class="file"><a href="/wiki/net-protocol/3.传输层/tcp/3.可靠性机制/">tcp可靠性机制</a></li><li class="file"><a href="/wiki/net-protocol/3.传输层/tcp/4.连接状态/">连接状态</a></li><li class="file"><a href="/wiki/net-protocol/3.传输层/tcp/1.头部/">tcp头部</a></li><li class="file active"><a href="/wiki/net-protocol/3.传输层/tcp/5.流量控制的实现-滑动窗口/">流量控制-滑动窗口</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; udp</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/3.传输层/udp/1.协议/">udp协议</a></li><li class="file"><a href="/wiki/net-protocol/3.传输层/udp/2.检验和计算/">校验和计算</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 4.网络层</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/4.网络层/arp协议/">arp协议</a></li><li class="file"><a href="/wiki/net-protocol/4.网络层/协议_icmp/">icmp协议</a></li><li class="file"><a href="/wiki/net-protocol/4.网络层/协议_端口/">端口机制</a></li><li class="file"><a href="/wiki/net-protocol/4.网络层/跨子网arp查询&子网arp查询/">arp子网查询&跨子网查询</a></li><li class="file"><a href="/wiki/net-protocol/4.网络层/协议_ip/">ip协议</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 5.链路层</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/5.链路层/1.以太网协议/">以太网协议</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 6.物理层</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/6.物理层/tap/"></a></li><li class="file"><a href="/wiki/net-protocol/6.物理层/tool/">tool</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 7.客户端</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/7.客户端/http-客户端/">http-客户端</a></li><li class="file"><a href="/wiki/net-protocol/7.客户端/tcp-客户端/">tcp-客户端</a></li><li class="file"><a href="/wiki/net-protocol/7.客户端/websocekt-客户端/">websocket-客户端</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 8.问题反馈</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/8.问题反馈/tun_tap/">Tun/Tap虚拟网卡外网通讯</a></li></ul></li><li class="file"><a href="/wiki/net-protocol/index/">index</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; other</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; share-mem</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/other/share-mem/shamem.c/">shamem.c</a></li><li class="file"><a href="/wiki/other/share-mem/shamem.h/">shamem.h</a></li><li class="file"><a href="/wiki/other/share-mem/共享内存/">共享内存的实现</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; swoft-im</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/swoft-im/前言/业务说明/">业务说明</a></li></ul></li><li class="file"><a href="/wiki/swoft-im/index/">微服务应用</a></li></ul></li><li class="file"><a href="/wiki/index/">Welcome Brewlin's Wiki Site</a></li></ul></div><script>$(document).ready(function(){var r="fa-folder-open",i="fa-folder",l="fa-angle-double-down",d="fa-angle-double-up";$(document).on("click",'#categories a[data-role="directory"]',function(a){a.preventDefault();var e=$(this).children(".fa"),s=e.hasClass(r),l=$(this).siblings("ul");e.removeClass(r).removeClass(i),s?(void 0!==l&&l.slideUp({duration:100}),e.addClass(i)):(void 0!==l&&l.slideDown({duration:100}),e.addClass(r))}),$('#categories a[data-role="directory"]').bind("contextmenu",function(a){a.preventDefault();var e=$(this).children(".fa"),s=e.hasClass(r),l=$(this).siblings("ul"),d=$.merge(l.find("li ul"),l),o=$.merge(l.find(".fa"),e);o.removeClass(r).removeClass(i),s?(d.slideUp({duration:100}),o.addClass(i)):(d.slideDown({duration:100}),o.addClass(r))}),$(document).on("click","#allExpand",function(a){a.preventDefault();var e=$(this).children(".fa"),s=e.hasClass(l);e.removeClass(l).removeClass(d),s?($("#sidebar .fa.fa-folder").removeClass("fa-folder").addClass("fa-folder-open"),$("#categories li ul").slideDown({duration:100}),e.addClass(d)):($("#sidebar .fa.fa-folder-open").removeClass("fa-folder-open").addClass("fa-folder"),$("#categories li ul").slideUp({duration:100}),e.addClass(l))})})</script><div id="toTop" class="fa fa-angle-up"></div></aside><section id="main"><article id="post-net-protocol/3.传输层/tcp/5.流量控制的实现-滑动窗口" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><div class="article-meta"><div class="article-category"><i class="fa fa-folder"></i> <a class="article-category-link" href="/categories/net-protocol/">net-protocol</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/net-protocol/3-传输层/">3.传输层</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/net-protocol/3-传输层/tcp/">tcp</a></div><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/go/">go</a>, <a class="tag-link" href="/tags/protocol/">protocol</a>, <a class="tag-link" href="/tags/tcp/">tcp</a></div><div class="article-date"><i class="fa fa-calendar"></i> <a href="/wiki/net-protocol/3.传输层/tcp/5.流量控制的实现-滑动窗口/"><time datetime="2019-11-05T12:20:20.000Z" itemprop="datePublished">2019-11-05</time></a></div><i class="fa fa-bar-chart"></i><span id="busuanzi_container_site_pv"><span id="busuanzi_value_page_pv"></span></span><div class="article-meta-button"> <a href="https://github.com/brewlin/docs/raw/master/source/_posts/net-protocol/3.传输层/tcp/5.流量控制的实现-滑动窗口.md">Source</a></div><div class="article-meta-button"> <a href="https://github.com/brewlin/docs/edit/master/source/_posts/net-protocol/3.传输层/tcp/5.流量控制的实现-滑动窗口.md">Edit</a></div><div class="article-meta-button"> <a href="https://github.com/brewlin/docs/commits/master/source/_posts/net-protocol/3.传输层/tcp/5.流量控制的实现-滑动窗口.md">History</a></div></div><h1 class="article-title" itemprop="name"> 流量控制-滑动窗口</h1></header><div class="article-entry" itemprop="articleBody"><div id="toc" class="toc-article"> <strong class="toc-title">Catalogue</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#接受窗口"><span class="toc-number">1.</span> <span class="toc-text">@接受窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发送窗口"><span class="toc-number">2.</span> <span class="toc-text">@发送窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Silly-Window-Syndrome"><span class="toc-number">3.</span> <span class="toc-text">@Silly Window Syndrome</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发送窗口的维护"><span class="toc-number">4.</span> <span class="toc-text">@发送窗口的维护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接受窗口的维护"><span class="toc-number">5.</span> <span class="toc-text">@接受窗口的维护</span></a></li></ol></div><p>接收端在给发送端回 ACK 中会汇报自己的 AdvertisedWindow，而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。<br>要明确的是滑动窗口分为两个窗口，接收窗口和发送窗口</p><h2 id="接受窗口"><a href="#接受窗口" class="headerlink" title="@接受窗口"></a>@接受窗口</h2><p>接收窗口不仅可以限制发送端发送的速率，还可以提高效率，因为接收窗口的机制，可以允许发送端一次多发送几个片段，而不必等候 ACK，而且可以允许等待一定情况下的乱序， 比如说先缓存提前到的数据，然后去等待需要的数据。</p><p>接收的窗口可以分为四段：</p><ul><li>数据已经被 tcp 确认，但用户程序还未读取数据内容</li><li>中间还有些数据没有到达</li><li>数据已经接收到，但 tcp 未确认</li><li>通告窗口，也就是接收端在给发送端回 ACK 中会汇报自己的窗口大小</li></ul><p>当接收端接收到数据包时，会判断该数据包的序列号是不是在接收窗口內，如果不在窗口內会立即回一个 ack 给发送端， 且丢弃该报文。<br>滑动： 当用户程序读取接收窗口的内容后，窗口向右滑行</p><h2 id="发送窗口"><a href="#发送窗口" class="headerlink" title="@发送窗口"></a>@发送窗口</h2><p>发送窗口的值是由接收窗口和拥塞窗口一起决定的，发送窗口的大小也决定了发送的速率。</p><p>发送窗口的上限值 = Min [rwnd, cwnd]，cwnd 拥塞窗口</p><p>f发送窗口可以分成四段:</p><ul><li>已收到 ack 确认的数据</li><li>已经发送，但还没收到 ack 的数据</li><li>在窗口中还没有发出的（接收方还有空间）</li><li>窗口以外的数据（接收方没空间）<br>滑动： 当发送端收到数据 ack 确认时，窗口向右滑</li></ul><p>如果一个处理缓慢的 Server（接收端）是怎么把 Client（发送端）的TCP Sliding Window给降成 0 的。此时，你一定会问，如果 Window 变成 0 了，TCP 会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿 Window size 可用了，怎么通知发送端呢？</p><p>1.当接收方的应用程序读取了接收缓冲区中的数据以后，接收方会发送一个 ACK，通过通告窗口字段告诉发送方自己又可以接收数据了，发送方收到这个 ACK 之后，就知道自己可以继续发送数据了。</p><p>2.同时发送端使用了Zero Window Probe技术，缩写为 ZWP，当接收方的接收窗口为 0 时，每隔一段时间，发送方会主动发送探测包，迫使对端响应来得知其接收窗口有无打开。</p><p>既然接收端会主动通知发送端，为何还需要发送端定时探测？</p><h2 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="@Silly Window Syndrome"></a>@Silly Window Syndrome</h2><p>Silly Window Syndrome翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走 Receive Windows 里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的 window，而我们的发送方会义无反顾地发送这几个字节。</p><p>要知道，我们的 TCP+IP 头有 40 个字节，为了几个字节，要达上这么大的开销，这太不经济了。</p><p>所以，Silly Windows Syndrome这个现像就像是你本来可以坐 200 人的飞机里只做了一两个人。要解决这个问题也不难，就是避免对小的 window size 做出响应，直到有足够大的 window size 再响应，这个思路可以同时实现在 sender 和 receiver 两端。</p><p>如果这个问题是由 Receiver 端引起的，那么就会使用David D Clark’s方案。在 receiver 端，如果收到的数据导致window size小于某个值，可以直接 ack(0)回 sender，这样就把 window 给关闭了，也阻止了 sender 再发数据过来，等到 receiver 端处理了一些数据后windows size大于等于了 MSS，或者，receiver buffer有一半为空，就可以把 window 打开让 sender 发送数据过来。</p><p>如果这个问题是由 Sender 端引起的，那么就会使用著名的Nagle’s algorithm。这个算法的思路也是延时处理，他有两个主要的条件：</p><p>要等到 Window Size &gt;= MSS 或是 Data Size &gt;= MSS<br>收到之前发送数据的 ack 回包，他才会发数据，否则就是在攒数据</p><h2 id="发送窗口的维护"><a href="#发送窗口的维护" class="headerlink" title="@发送窗口的维护"></a>@发送窗口的维护</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                     +-------&gt; sndWnd &lt;-------+</span><br><span class="line">                     |                          |</span><br><span class="line">---------------------+-------------+----------+--------------------</span><br><span class="line">|      acked         | * * * * * * | # # # # #|   unable send</span><br><span class="line">---------------------+-------------+----------+--------------------</span><br><span class="line">                     ^             ^</span><br><span class="line">                     |               |</span><br><span class="line">                   sndUna        sndNxt</span><br><span class="line">***** in flight data</span><br><span class="line">##### able send date</span><br></pre></td></tr></table></figure><p>发送窗口主要维护这些变量，sndBufSize、sndBufUsed、sndUna、sndNxt 和 sndWnd。sndUna 表示是下一个未确认的序列号，sndNxt 是要发送的下一个段的序列号，sndWnd 是接受端通告的窗口大小。 首先是处理接收方的窗口通告，当收到报文时，一定会带接收窗口和确认号，此时先更新发送器的发送窗口大小为接收窗口大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write writes data to the endpoint's peer.</span></span><br><span class="line"><span class="comment">// 接收上层的数，通过tcp连接发送到对端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">Write</span><span class="params">(p tcpip.Payload, opts tcpip.WriteOptions)</span> <span class="params">(<span class="keyword">uintptr</span>, &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, *tcpip.Error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Linux completely ignores any address passed to sendto(2) for TCP sockets</span></span><br><span class="line">    <span class="comment">// (without the MSG_FASTOPEN flag). Corking is unimplemented, so opts.More</span></span><br><span class="line">    <span class="comment">// and opts.EndOfRecord are also ignored.</span></span><br><span class="line"></span><br><span class="line">    e.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> e.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The endpoint cannot be written to if it's not connected.</span></span><br><span class="line">    <span class="comment">// 判断tcp状态，必须已经建立了连接才能发送数据</span></span><br><span class="line">    <span class="keyword">if</span> e.state != stateConnected &#123;</span><br><span class="line">        <span class="keyword">switch</span> e.state &#123;</span><br><span class="line">        <span class="keyword">case</span> stateError:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, e.hardError</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, tcpip.ErrClosedForSend</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Nothing to do if the buffer is empty.</span></span><br><span class="line">    <span class="comment">// 检查负载的长度，如果为0，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> p.Size() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e.sndBufMu.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the connection has already been closed for sends.</span></span><br><span class="line">    <span class="keyword">if</span> e.sndClosed &#123;</span><br><span class="line">        e.sndBufMu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, tcpip.ErrClosedForSend</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against the limit.</span></span><br><span class="line">    <span class="comment">// tcp流量控制：未被占用发送缓存还剩多少，如果发送缓存已经被用光了，返回 ErrWouldBlock</span></span><br><span class="line">    avail := e.sndBufSize - e.sndBufUsed</span><br><span class="line">    <span class="keyword">if</span> avail &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        e.sndBufMu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, tcpip.ErrWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v, perr := p.Get(avail)</span><br><span class="line">    <span class="keyword">if</span> perr != <span class="literal">nil</span> &#123;</span><br><span class="line">        e.sndBufMu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, perr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> err *tcpip.Error</span><br><span class="line">    <span class="keyword">if</span> p.Size() &gt; avail &#123;</span><br><span class="line">        err = tcpip.ErrWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line">    l := <span class="built_in">len</span>(v)</span><br><span class="line">    s := newSegmentFromView(&amp;e.route, e.id, v)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add data to the send queue.</span></span><br><span class="line">    <span class="comment">// 插入发送队列</span></span><br><span class="line">    e.sndBufUsed += l</span><br><span class="line">    e.sndBufInQueue += seqnum.Size(l)</span><br><span class="line">    e.sndQueue.PushBack(s)</span><br><span class="line"></span><br><span class="line">    e.sndBufMu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据，最终会调用 sender sendData 来发送数据。</span></span><br><span class="line">    <span class="keyword">if</span> e.workMu.TryLock() &#123;</span><br><span class="line">        <span class="comment">// Do the work inline.</span></span><br><span class="line">        e.handleWrite()</span><br><span class="line">        e.workMu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Let the protocol goroutine do the work.</span></span><br><span class="line">        e.sndWaker.Assert()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">uintptr</span>(l), <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到tcp段时调用 handleRcvdSegment; 它负责更新与发送相关的状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sender)</span> <span class="title">handleRcvdSegment</span><span class="params">(seg *segment)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放当前窗口大小。</span></span><br><span class="line">    s.sndWnd = seg.window</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取确认号</span></span><br><span class="line">    ack := seg.ackNumber</span><br><span class="line">    <span class="comment">// 如果ack在最小未确认的seq和下一seg的seq之间</span></span><br><span class="line">    <span class="keyword">if</span> (ack - <span class="number">1</span>).InRange(s.sndUna, s.sndNxt) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Remove all acknowledged data from the write list.</span></span><br><span class="line">        acked := s.sndUna.Size(ack)</span><br><span class="line">        s.sndUna = ack</span><br><span class="line"></span><br><span class="line">        ackLeft := acked</span><br><span class="line">        originalOutstanding := s.outstanding</span><br><span class="line">        <span class="keyword">for</span> ackLeft &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// We use logicalLen here because we can have FIN</span></span><br><span class="line">            <span class="comment">// segments (which are always at the end of list) that</span></span><br><span class="line">            <span class="comment">// have no data, but do consume a sequence number.</span></span><br><span class="line">            seg := s.writeList.Front()</span><br><span class="line">            datalen := seg.logicalLen()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> datalen &gt; ackLeft &#123;</span><br><span class="line">                seg.data.TrimFront(<span class="keyword">int</span>(ackLeft))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> s.writeNext == seg &#123;</span><br><span class="line">                s.writeNext = seg.Next()</span><br><span class="line">            &#125;</span><br><span class="line">            s.writeList.Remove(seg)</span><br><span class="line">            s.outstanding--</span><br><span class="line">            seg.decRef()</span><br><span class="line">            ackLeft -= datalen</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the send buffer usage and notify potential waiters.</span></span><br><span class="line">        s.ep.updateSndBufferUsage(<span class="keyword">int</span>(acked))</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接受窗口的维护"><a href="#接受窗口的维护" class="headerlink" title="@接受窗口的维护"></a>@接受窗口的维护</h2><p>接收窗口主要维护这几个变量，rcvBufSize、rcvBufUsed、rcvNxt 和 rcvAcc，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tcp流量控制：计算未被占用的接收缓存大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">receiveBufferAvailable</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    e.rcvListMu.Lock()</span><br><span class="line">    size := e.rcvBufSize</span><br><span class="line">    used := e.rcvBufUsed</span><br><span class="line">    e.rcvListMu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We may use more bytes than the buffer size when the receive buffer</span></span><br><span class="line">    <span class="comment">// shrinks.</span></span><br><span class="line">    <span class="keyword">if</span> used &gt;= size &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size - used</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">receiveBufferSize</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    e.rcvListMu.Lock()</span><br><span class="line">    size := e.rcvBufSize</span><br><span class="line">    e.rcvListMu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zeroReceiveWindow 根据可用缓冲区的数量和接收窗口缩放，检查现在要宣布的接收窗口是否为零。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">zeroReceiveWindow</span><span class="params">(scale <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e.rcvBufUsed &gt;= e.rcvBufSize &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((e.rcvBufSize - e.rcvBufUsed) &gt;&gt; scale) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tcp流量控制：判断 segSeq 在窗口內</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *receiver)</span> <span class="title">acceptable</span><span class="params">(segSeq seqnum.Value, segLen seqnum.Size)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    rcvWnd := r.rcvNxt.Size(r.rcvAcc)</span><br><span class="line">    <span class="keyword">if</span> rcvWnd == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> segLen == <span class="number">0</span> &amp;&amp; segSeq == r.rcvNxt</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> segSeq.InWindow(r.rcvNxt, rcvWnd) ||</span><br><span class="line">        seqnum.Overlap(r.rcvNxt, rcvWnd, segSeq, segLen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tcp流量控制：当接收窗口从零增长到非零时，调用 nonZeroWindow;在这种情况下，</span></span><br><span class="line"><span class="comment">// 我们可能需要发送一个 ack，以便向对端表明它可以恢复发送数据。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *receiver)</span> <span class="title">nonZeroWindow</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (r.rcvAcc-r.rcvNxt)&gt;&gt;r.rcvWndScale != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// We never got around to announcing a zero window size, so we</span></span><br><span class="line">        <span class="comment">// don't need to immediately announce a nonzero one.</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Immediately send an ack.</span></span><br><span class="line">    r.ep.snd.sendAck()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从tcp的接收队列中读取数据，并从接收队列中删除已读数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">readLocked</span><span class="params">()</span> <span class="params">(buffer.View, *tcpip.Error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e.rcvBufUsed == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.rcvClosed || e.state != stateConnected &#123;</span><br><span class="line">            <span class="keyword">return</span> buffer.View&#123;&#125;, tcpip.ErrClosedForReceive</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.View&#123;&#125;, tcpip.ErrWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s := e.rcvList.Front()</span><br><span class="line">    views := s.data.Views()</span><br><span class="line">    v := views[s.viewToDeliver]</span><br><span class="line">    s.viewToDeliver++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s.viewToDeliver &gt;= <span class="built_in">len</span>(views) &#123;</span><br><span class="line">        e.rcvList.Remove(s)</span><br><span class="line">        s.decRef()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scale := e.rcv.rcvWndScale</span><br><span class="line">    <span class="comment">// tcp流量控制：检测接收窗口是否为0</span></span><br><span class="line">    wasZero := e.zeroReceiveWindow(scale)</span><br><span class="line">    e.rcvBufUsed -= <span class="built_in">len</span>(v)</span><br><span class="line">    <span class="comment">// 检测糊涂窗口，主动发送窗口不为0的通告给对方</span></span><br><span class="line">    <span class="keyword">if</span> wasZero &amp;&amp; !e.zeroReceiveWindow(scale) &#123;</span><br><span class="line">        e.notifyProtocolGoroutine(notifyNonZeroReceiveWindow)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="article-footer"></footer></div></article><nav id="article-nav"> <a href="/wiki/net-protocol/7.客户端/tcp-客户端/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title"> tcp-客户端</div></a> <a href="/wiki/net-protocol/3.传输层/tcp/4.连接状态/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">连接状态</div></a></nav><script type="text/javascript">!function(){var e=window.location.href,r=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var o="//api.share.baidu.com/s.gif";r?(o+="?r="+encodeURIComponent(document.referrer),e&&(o+="&l="+e)):e&&(o+="?l="+e),(new Image).src=o}}(window)</script></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"> brewlin &copy; 2020 <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a><br> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten">wikitten</a><br><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> |<span id="busuanzi_container_site_pv"><i class="fa fa-user"><span id="busuanzi_value_site_uv"></span></i></span></div></div></footer><script src="/libs/lightgallery/js/lightgallery.min.js"></script><script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script><script src="/libs/lightgallery/js/lg-pager.min.js"></script><script src="/libs/lightgallery/js/lg-autoplay.min.js"></script><script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script><script src="/libs/lightgallery/js/lg-zoom.min.js"></script><script src="/libs/lightgallery/js/lg-hash.min.js"></script><script src="/libs/lightgallery/js/lg-share.min.js"></script><script src="/libs/lightgallery/js/lg-video.min.js"></script><script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/main.js"></script></div></body>