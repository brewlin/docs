<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>rust_无栈协程&amp;调度器实现 | Brewlin&#39;s Wiki</title><meta name="keywords" content="linux,c,golang,rust,coroutine,scheduler"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="本次文章专注于分析rust的协程实现，并提前介绍它与其他语言的协程有什么区别 接下来我们就从有栈和无栈切入了解协程在内存方面的布局，典型的有栈协程就是golang，这里的有栈其实是一个潜台词，代表的是需要单独申请堆内存作为栈的意思 那么有栈协程对应的就是=&amp;gt;需要独立申请一份内存作为代码指令运行的栈 关于栈的解析典型的就是c语言的栈，来看看c语言的运行栈的情况吧12345678910void"><meta name="keywords" content="linux,c,golang,rust,coroutine,scheduler"><meta property="og:type" content="article"><meta property="og:title" content="rust_无栈协程&amp;调度器实现"><meta property="og:url" content="http://wiki.brewlin.com/wiki/compiler/rust协程_调度器实现/index.html"><meta property="og:site_name" content="Brewlin&#39;s Wiki"><meta property="og:description" content="本次文章专注于分析rust的协程实现，并提前介绍它与其他语言的协程有什么区别 接下来我们就从有栈和无栈切入了解协程在内存方面的布局，典型的有栈协程就是golang，这里的有栈其实是一个潜台词，代表的是需要单独申请堆内存作为栈的意思 那么有栈协程对应的就是=&amp;gt;需要独立申请一份内存作为代码指令运行的栈 关于栈的解析典型的就是c语言的栈，来看看c语言的运行栈的情况吧12345678910void"><meta property="og:locale" content="en"><meta property="og:image" content="http://wiki.brewlin.com/images/blog/rust/golang-stack.png"><meta property="og:updated_time" content="2022-06-30T08:06:37.444Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="rust_无栈协程&amp;调度器实现"><meta name="twitter:description" content="本次文章专注于分析rust的协程实现，并提前介绍它与其他语言的协程有什么区别 接下来我们就从有栈和无栈切入了解协程在内存方面的布局，典型的有栈协程就是golang，这里的有栈其实是一个潜台词，代表的是需要单独申请堆内存作为栈的意思 那么有栈协程对应的就是=&amp;gt;需要独立申请一份内存作为代码指令运行的栈 关于栈的解析典型的就是c语言的栈，来看看c语言的运行栈的情况吧12345678910void"><meta name="twitter:image" content="http://wiki.brewlin.com/images/blog/rust/golang-stack.png"><link rel="alternate" href="/atom.xml" title="Brewlin&#39;s Wiki" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/libs/open-sans/styles.css"><link rel="stylesheet" href="/libs/source-code-pro/styles.css"><link rel="stylesheet" href="/css/style.css"><script src="/libs/jquery/2.1.3/jquery.min.js"></script><script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script><link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css"><link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head></html><body><div id="container"><header id="header"><div id="header-main" class="header-inner"><div class="outer"><a href="/" id="logo"><i class="logo"></i> <span class="site-title">Brewlin&#39;s Wiki</span></a><nav id="main-nav"> <a class="main-nav-link" href="/">首页</a> <a class="main-nav-link" href="/archives">归档</a> <a class="main-nav-link" href="/categories">分类</a> <a class="main-nav-link" href="/tags">标签</a> <a class="main-nav-link" href="/about">关于</a></nav><div id="search-form-wrap"><form class="search-form"> <input type="text" class="ins-search-input search-form-input" placeholder="Search"> <button type="submit" class="search-form-submit"></button></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"> <input type="text" class="ins-search-input" placeholder="Type something..."><span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script></div></div></div><div id="main-nav-mobile" class="header-sub header-inner"><table class="menu outer"><tr><td><a class="main-nav-link" href="/">首页</a></td><td><a class="main-nav-link" href="/archives">归档</a></td><td><a class="main-nav-link" href="/categories">分类</a></td><td><a class="main-nav-link" href="/tags">标签</a></td><td><a class="main-nav-link" href="/about">关于</a></td><td><div class="search-form"> <input type="text" class="ins-search-input search-form-input" placeholder="Search"></div></td></tr></table></div></header><div class="outer"><aside id="sidebar"><div class="widget-wrap" id="categories"><h3 class="widget-title"> <span>categories</span> &nbsp;<a id="allExpand" href="#"><i class="fa fa-angle-double-down fa-2x"></i></a></h3><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; algorithm</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; gc-learning</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/algorithm/gc-learning/前言/1.什么是roots/">什么是Root</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/前言/2.什么是heaps/">什么是Heap</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 算法实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/1.标记清除算法/">标记清除算法</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/2.标记清除-多链表法/">标记清除-多链表法</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/3.引用计数/">引用计数</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/4.GC复制/">GC复制</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/6.压缩算法-lisp2/">压缩算法-lisp2</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/7.压缩算法-two-finger/">压缩算法-two-finger</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/8.保守式gc/">关于保守式GC</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/10.三色标记清除/">三色标记清除</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/5.GC复制-标记清除/">GC复制-标记清除</a></li><li class="file"><a href="/wiki/algorithm/gc-learning/算法实现/9.分代回收算法/">分代回收算法</a></li></ul></li><li class="file"><a href="/wiki/algorithm/gc-learning/GC算法分析与实现/">GC算法分析与实现</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; graph</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/algorithm/graph/dijkstra/">Dijkstra最短路径</a></li><li class="file"><a href="/wiki/algorithm/graph/最小生成树/">最小生成树</a></li><li class="file"><a href="/wiki/algorithm/graph/稀疏图-寻路/">稀疏图-寻路</a></li><li class="file"><a href="/wiki/algorithm/graph/稀疏图-连通分量-bfs-dfs/">稀疏图-连通分量-bfs-dfs</a></li><li class="file"><a href="/wiki/algorithm/graph/稀疏图-邻接表/">稀疏图-邻接表</a></li></ul></li></ul></li><li class="directory open"><a href="#" data-role="directory"><i class="fa fa-folder-open"></i> &nbsp; compiler</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/compiler/php_offset/">php_offset</a></li><li class="file"><a href="/wiki/compiler/php_引用计数与GC/">php_引用计数与gc</a></li><li class="file active"><a href="/wiki/compiler/rust协程_调度器实现/">rust_无栈协程&调度器实现</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; github</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; c-ext</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; coroutine</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/c-ext/coroutine/协程/">协程</a></li><li class="file"><a href="/wiki/github/c-ext/coroutine/协程socket/">协程socket</a></li><li class="file"><a href="/wiki/github/c-ext/coroutine/协程tcp服务/">协程tcp服务</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; event</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/c-ext/event/event/">event</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; hook</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/c-ext/hook/runtime/">runtime</a></li><li class="file"><a href="/wiki/github/c-ext/hook/sleep/">sleep</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; memory</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/c-ext/memory/共享内存/">共享内存</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; process</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/c-ext/process/进程管理/">进程管理</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; thread</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/c-ext/thread/线程池/">线程池</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; timer</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/c-ext/timer/定时器/">定时器</a></li></ul></li><li class="file"><a href="/wiki/github/c-ext/index/">c扩展</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; go-stl</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; graph</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/go-stl/graph/图论/">图论算法</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; hash</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/go-stl/hash/hash_code/">哈希Code生成</a></li><li class="file"><a href="/wiki/github/go-stl/hash/hash_list/">哈希链表</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; queue</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/go-stl/queue/list/">LIST</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; raft</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/go-stl/raft/raft分布式一致性原理(一)/">raft分布式一致性原理(一)</a></li><li class="file"><a href="/wiki/github/go-stl/raft/raft分布式一致性原理(二)/">raft分布式一致性原理(二)</a></li><li class="file"><a href="/wiki/github/go-stl/raft/相关资料/">相关资料</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; tree</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/go-stl/tree/binary-search/">二分搜索树</a></li><li class="file"><a href="/wiki/github/go-stl/tree/reds-black-tree/">红黑树</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; trie</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/go-stl/trie/trie/">字典树</a></li></ul></li><li class="file"><a href="/wiki/github/go-stl/index/">GO标准库和算法应用</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; goos</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/goos/Goos-多线程协程实现简要/">Goos-多线程协程实现简要</a></li><li class="file"><a href="/wiki/github/goos/Goos-底层协程实现(三)/">Goos-底层协程实现(三)</a></li><li class="file"><a href="/wiki/github/goos/Goos-底层协程实现(一)/">Goos-底层协程实现(一)</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; im-cloud</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 1.前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/1.前言/1.安装部署/">安装部署</a></li><li class="file"><a href="/wiki/github/im-cloud/1.前言/2.并发压测对比/">并发压测对比</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 2.版本</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/2.版本/1.版本兼容/">版本兼容</a></li><li class="file"><a href="/wiki/github/im-cloud/2.版本/2.单进程全协程化版/">单线程全协程化版</a></li><li class="file"><a href="/wiki/github/im-cloud/2.版本/3.多进程worker版/">多进程worker版本</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 3.相关组件</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; core</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/core/core/">core</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; database</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/database/db/">db</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; discovery</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/discovery/discovery/">discovery</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; grpc</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/grpc/grpc/">grpc</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; log</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/log/log/">log</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; memeory</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/memeory/memeory/">memory</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; process</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/process/process/">process</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; queue</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/queue/queue/">queue</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; redis</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/redis/redis/">redis</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; task</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/3.相关组件/task/task/">task</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 4.开放接口</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/4.开放接口/logic开放接口/">Logic 节点开放接口</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 5.相关实现</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 1.底层实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/5.相关实现/1.底层实现/1.im-cloud/">im-cloud</a></li><li class="file"><a href="/wiki/github/im-cloud/5.相关实现/1.底层实现/2.通讯协议/">通讯协议</a></li><li class="file"><a href="/wiki/github/im-cloud/5.相关实现/1.底层实现/4.job节点/">job节点实现</a></li><li class="file"><a href="/wiki/github/im-cloud/5.相关实现/1.底层实现/5.logic节点/">logic节点实现</a></li><li class="file"><a href="/wiki/github/im-cloud/5.相关实现/1.底层实现/3.cloud节点/">cloud节点实现</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 2.应用实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/5.相关实现/2.应用实现/1.推送实现/">推送实现</a></li><li class="file"><a href="/wiki/github/im-cloud/5.相关实现/2.应用实现/2.服务发现/">服务发现</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 3.组件实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/im-cloud/5.相关实现/3.组件实现/1.连接池实现/">连接池实现</a></li></ul></li></ul></li><li class="file"><a href="/wiki/github/im-cloud/index/">im-cloud 分布式推送中间件</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; net-protocol</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 1.前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/1.前言/1.快速开始/">快速开始</a></li><li class="file"><a href="/wiki/github/net-protocol/1.前言/2.协议分层模型/">协议分层模型</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 2.应用层</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; dns</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/2.应用层/dns/1.dns协议简介/">dns协议简介</a></li><li class="file"><a href="/wiki/github/net-protocol/2.应用层/dns/2.dns协议实现/">dns协议实现</a></li><li class="file"><a href="/wiki/github/net-protocol/2.应用层/dns/3.dns协议api/">dns协议api</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; http</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/2.应用层/http/1.http协议解析/">http协议解析</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; websocket</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/2.应用层/websocket/2.websocket算法/">websocket算法</a></li><li class="file"><a href="/wiki/github/net-protocol/2.应用层/websocket/1.websocket协议解析/">websocket协议解析</a></li><li class="file"><a href="/wiki/github/net-protocol/2.应用层/websocket/3.websocket实现/">websocket实现</a></li></ul></li><li class="file"><a href="/wiki/github/net-protocol/2.应用层/应用层前世今生/">应用层前世今生</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 3.传输层</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; tcp</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/3.传输层/tcp/2.流量控制/">tcp流量控制</a></li><li class="file"><a href="/wiki/github/net-protocol/3.传输层/tcp/3.可靠性机制/">tcp可靠性机制</a></li><li class="file"><a href="/wiki/github/net-protocol/3.传输层/tcp/4.连接状态/">连接状态</a></li><li class="file"><a href="/wiki/github/net-protocol/3.传输层/tcp/1.头部/">tcp头部</a></li><li class="file"><a href="/wiki/github/net-protocol/3.传输层/tcp/5.流量控制的实现-滑动窗口/">流量控制-滑动窗口</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; udp</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/3.传输层/udp/1.协议/">udp协议</a></li><li class="file"><a href="/wiki/github/net-protocol/3.传输层/udp/2.检验和计算/">校验和计算</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 4.网络层</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/4.网络层/arp协议/">arp协议</a></li><li class="file"><a href="/wiki/github/net-protocol/4.网络层/协议_icmp/">icmp协议</a></li><li class="file"><a href="/wiki/github/net-protocol/4.网络层/协议_端口/">端口机制</a></li><li class="file"><a href="/wiki/github/net-protocol/4.网络层/跨子网arp查询&子网arp查询/">arp子网查询&跨子网查询</a></li><li class="file"><a href="/wiki/github/net-protocol/4.网络层/协议_ip/">ip协议</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 5.链路层</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/5.链路层/1.以太网协议/">以太网协议</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 6.物理层</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/6.物理层/tap/">tap</a></li><li class="file"><a href="/wiki/github/net-protocol/6.物理层/tool/">tool</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 7.客户端</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/7.客户端/dns-客户端/">dns-客户端</a></li><li class="file"><a href="/wiki/github/net-protocol/7.客户端/http-客户端/">http-客户端</a></li><li class="file"><a href="/wiki/github/net-protocol/7.客户端/tcp-客户端/">tcp-客户端</a></li><li class="file"><a href="/wiki/github/net-protocol/7.客户端/udp-客户端/">udp-客户端</a></li><li class="file"><a href="/wiki/github/net-protocol/7.客户端/websocekt-客户端/">websocket-客户端</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 8.问题反馈</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/net-protocol/8.问题反馈/tun_tap/">Tun/Tap虚拟网卡外网通讯</a></li></ul></li><li class="file"><a href="/wiki/github/net-protocol/index/">index</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; swoole-im</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/github/swoole-im/前言/业务说明/">业务说明</a></li></ul></li><li class="file"><a href="/wiki/github/swoole-im/index/">微服务应用</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; middlewares</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; glusterfs</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/middlewares/glusterfs/1.glusterfs-客户端源码分析/">glusterfs-客户端源码分析</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; nginx</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; mini_ngx</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/middlewares/nginx/mini_ngx/1.mini_ngx_实现一-简述/">mini_ngx_实现一-简述</a></li><li class="file"><a href="/wiki/middlewares/nginx/mini_ngx/2.mini_ngx_实现二-core模块/">mini_ngx_实现二-core模块</a></li><li class="file"><a href="/wiki/middlewares/nginx/mini_ngx/3.mini_ngx_实现三-http模块/">mini_ngx_实现三-http模块</a></li><li class="file"><a href="/wiki/middlewares/nginx/mini_ngx/4.mini_ngx_实现四-event模块/">mini_ngx_实现四-event模块</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; sharmem</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/middlewares/nginx/sharmem/shamem.c/">shamem.c</a></li><li class="file"><a href="/wiki/middlewares/nginx/sharmem/shamem.h/">shamem.h</a></li><li class="file"><a href="/wiki/middlewares/nginx/sharmem/共享内存/">共享内存的实现</a></li></ul></li><li class="file"><a href="/wiki/middlewares/nginx/1.ngx_连接池与事件封装(一)/">ngx_连接池与事件封装(一)</a></li><li class="file"><a href="/wiki/middlewares/nginx/2.ngx_连接池与事件封装(二)/">ngx_连接池与事件封装(二)</a></li><li class="file"><a href="/wiki/middlewares/nginx/http_模块开发的步骤（一）/">http_模块开发的步骤</a></li><li class="file"><a href="/wiki/middlewares/nginx/nginx_内存池封装/">ngx_内存池封装</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; read</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/read/read/">read</a></li></ul></li><li class="file"><a href="/wiki/index/">Welcome Brewlin's Wiki Site</a></li></ul></div><script>$(document).ready(function(){var r="fa-folder-open",i="fa-folder",l="fa-angle-double-down",d="fa-angle-double-up";$(document).on("click",'#categories a[data-role="directory"]',function(a){a.preventDefault();var e=$(this).children(".fa"),s=e.hasClass(r),l=$(this).siblings("ul");e.removeClass(r).removeClass(i),s?(void 0!==l&&l.slideUp({duration:100}),e.addClass(i)):(void 0!==l&&l.slideDown({duration:100}),e.addClass(r))}),$('#categories a[data-role="directory"]').bind("contextmenu",function(a){a.preventDefault();var e=$(this).children(".fa"),s=e.hasClass(r),l=$(this).siblings("ul"),d=$.merge(l.find("li ul"),l),o=$.merge(l.find(".fa"),e);o.removeClass(r).removeClass(i),s?(d.slideUp({duration:100}),o.addClass(i)):(d.slideDown({duration:100}),o.addClass(r))}),$(document).on("click","#allExpand",function(a){a.preventDefault();var e=$(this).children(".fa"),s=e.hasClass(l);e.removeClass(l).removeClass(d),s?($("#sidebar .fa.fa-folder").removeClass("fa-folder").addClass("fa-folder-open"),$("#categories li ul").slideDown({duration:100}),e.addClass(d)):($("#sidebar .fa.fa-folder-open").removeClass("fa-folder-open").addClass("fa-folder"),$("#categories li ul").slideUp({duration:100}),e.addClass(l))})})</script><div id="toTop" class="fa fa-angle-up"></div></aside><section id="main"><article id="post-compiler/rust协程_调度器实现" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><div class="article-meta"><div class="article-category"><i class="fa fa-folder"></i> <a class="article-category-link" href="/categories/compiler/">compiler</a></div><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/c/">c</a>, <a class="tag-link" href="/tags/coroutine/">coroutine</a>, <a class="tag-link" href="/tags/golang/">golang</a>, <a class="tag-link" href="/tags/linux/">linux</a>, <a class="tag-link" href="/tags/rust/">rust</a>, <a class="tag-link" href="/tags/scheduler/">scheduler</a></div><div class="article-date"><i class="fa fa-calendar"></i> <a href="/wiki/compiler/rust协程_调度器实现/"><time datetime="2022-04-07T13:28:59.000Z" itemprop="datePublished">2022-04-07</time></a></div><i class="fa fa-bar-chart"></i><span id="busuanzi_container_site_pv"><span id="busuanzi_value_page_pv"></span></span><div class="article-meta-button"> <a href="https://github.com/brewlin/docs/raw/master/source/_posts/compiler/rust协程_调度器实现.md">Source</a></div><div class="article-meta-button"> <a href="https://github.com/brewlin/docs/edit/master/source/_posts/compiler/rust协程_调度器实现.md">Edit</a></div><div class="article-meta-button"> <a href="https://github.com/brewlin/docs/commits/master/source/_posts/compiler/rust协程_调度器实现.md">History</a></div></div><h1 class="article-title" itemprop="name"> rust_无栈协程&amp;调度器实现</h1></header><div class="article-entry" itemprop="articleBody"><div id="toc" class="toc-article"> <strong class="toc-title">Catalogue</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#关于栈的解析"><span class="toc-number">1.</span> <span class="toc-text">关于栈的解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#栈的内存结构"><span class="toc-number">1.1.</span> <span class="toc-text">栈的内存结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈的上下文恢复"><span class="toc-number">1.2.</span> <span class="toc-text">栈的上下文恢复</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#有栈协程-gt-golang"><span class="toc-number">2.</span> <span class="toc-text">有栈协程 -&gt; golang</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#go-创建协程"><span class="toc-number">2.1.</span> <span class="toc-text">go 创建协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分配栈"><span class="toc-number">2.2.</span> <span class="toc-text">分配栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈的上下文"><span class="toc-number">2.3.</span> <span class="toc-text">栈的上下文</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#无栈协程-gt-rust"><span class="toc-number">3.</span> <span class="toc-text">无栈协程-&gt;rust</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#rust-状态机"><span class="toc-number">3.1.</span> <span class="toc-text">rust 状态机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译器生成的状态机代码"><span class="toc-number">3.2.</span> <span class="toc-text">编译器生成的状态机代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协程调度器-tokio-runtime"><span class="toc-number">3.3.</span> <span class="toc-text">协程调度器(tokio runtime)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-启动多线程"><span class="toc-number">3.3.1.</span> <span class="toc-text">1. 启动多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-worker线程调度协程任务"><span class="toc-number">3.3.2.</span> <span class="toc-text">2. worker线程调度协程任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-没有任务时进入事件轮训-epoll-wait"><span class="toc-number">3.3.3.</span> <span class="toc-text">3. 没有任务时进入事件轮训(epoll_wait)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-事件到来后的协程唤醒"><span class="toc-number">3.3.4.</span> <span class="toc-text">4. 事件到来后的协程唤醒</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div><p>本次文章专注于分析rust的协程实现，并提前介绍它与其他语言的协程有什么区别</p><p>接下来我们就从有栈和无栈切入了解协程在内存方面的布局，典型的有栈协程就是golang，这里的<code>有栈</code>其实是一个潜台词，代表的是需要单独申请堆内存作为栈的意思</p><p>那么有栈协程对应的就是=&gt;需要独立申请一份内存作为代码指令运行的栈</p><h1 id="关于栈的解析"><a href="#关于栈的解析" class="headerlink" title="关于栈的解析"></a>关于栈的解析</h1><p>典型的就是c语言的栈，来看看c语言的运行栈的情况吧<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void test1(long  var3,long var4)&#123;</span><br><span class="line">//函数参数也是变量，看看各个编译器的实现</span><br><span class="line">//一般也是存在栈上，所以从下面图片可以看到即时我没有显示定义两个变量，但实际还是占用了栈</span><br><span class="line">&#125;</span><br><span class="line">void test()&#123;</span><br><span class="line">    long var1 = 1; //用long 是因为64位下占8字节方便我下面画图。。。</span><br><span class="line">    long var2 = 2;</span><br><span class="line">    test1();</span><br><span class="line">    var2 = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>当前没有讲解从main函数开始，是因为main函数有点特殊，因为main的参数只有<code>argc,argv</code>。且直接通过<code>(%rsp),8(%rsp),分别就能拿到 argc,argv。不是直接像其他那样通过</code>%rdi,%rsi`拿，为了保持简洁明了，直接用了非main函数其他的函数作为例子讲解</p><h2 id="栈的内存结构"><a href="#栈的内存结构" class="headerlink" title="栈的内存结构"></a>栈的内存结构</h2><p>上文的c语言在编译运行后的系统栈内存使用如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">|    +--------------+   %rbp &lt;---------------------                </span><br><span class="line">|    |   var1       |                             |</span><br><span class="line">|    +--------------+                             |</span><br><span class="line">|    |   var2       |                             |</span><br><span class="line">|    +--------------+                             |</span><br><span class="line">|    |   arg1       |                             |</span><br><span class="line">|    +--------------+                             |</span><br><span class="line">|    |   arg2       |                             |</span><br><span class="line">|    +--------------+                             |</span><br><span class="line">|    |Return address|    test                     |</span><br><span class="line">|    +--------------------------- %rsp            |</span><br><span class="line">|    |   %rbp       |    --------------------------</span><br><span class="line">|    +--------------+    </span><br><span class="line">|    |   var3       |    </span><br><span class="line">|    +--------------+</span><br><span class="line">|    |   var4       |    </span><br><span class="line">|    +--------------+</span><br><span class="line">|    |Return address|    test1</span><br><span class="line">V    +--------------------------- %rsp</span><br></pre></td></tr></table></figure><p></p><ol><li>首先栈是从高地址到低地址发展</li><li>所有的变量会提前在编译阶段就计算好栈中的地址<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test函数内:</span><br><span class="line">//var1的变量</span><br><span class="line">var1 = -8(%rbp);</span><br><span class="line">var2 = -16(%rbp)</span><br><span class="line"></span><br><span class="line">test1函数内:</span><br><span class="line">var3 = -8(%rbp);</span><br><span class="line">var4 = -16(%rbp);</span><br></pre></td></tr></table></figure></li></ol><h2 id="栈的上下文恢复"><a href="#栈的上下文恢复" class="headerlink" title="栈的上下文恢复"></a>栈的上下文恢复</h2><p>从上文我们可以看到，整个程序运行就是各种函数调用，都会不断的追加到栈中，不停的阔栈，整个进程都是复用的同一个栈，所有变量和地址都是依赖于<code>%rbp</code>进行地址定位(依赖于编译器实现，一般都是根据%rbp进行定位)</p><p>那么当<code>test1</code>函数返回后，如何恢复<code>test</code>函数的环境呢？<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 变量的定位需要依赖`%rbp`,所以将(test1.%rbp)恢复到(test.%rbp)即可</span><br><span class="line">2. %rsp指向的栈顶，当test1函数返回后，其实 %rsp = %rbp即可，因为test1函数的基站其实就是test函数的栈顶</span><br><span class="line">3. 当然还要恢复%rip，下一条指令执行的地址，也就是test函数var2=3的地址，也是在test1函数返回时需要恢复的</span><br></pre></td></tr></table></figure><p></p><p><code>rsp,rip,rbp</code>基本上靠这个就组成了整个函数的上下文，这也就理解了c类语言的内存栈布局</p><p>那么就可以非常明了的解释了为什么不能轻松操作栈引用的问题了<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">test1</span><span class="params">(<span class="keyword">int</span> var3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;var3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* var1 = test1(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span>* var2 = test1(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|    +--------------+   %rbp &lt;---------------------                </span><br><span class="line">|    |   var1       |                             |</span><br><span class="line">|    +--------------+                             |</span><br><span class="line">|    |   var2       |                             |</span><br><span class="line">|    +--------------+                             |</span><br><span class="line">|    |   arg1       |                             |</span><br><span class="line">|    +--------------+                             |</span><br><span class="line">|    |   arg2       |                             |</span><br><span class="line">|    +--------------+                             |</span><br><span class="line">|    |Return address|    test                     |</span><br><span class="line">|    +--------------------------- %rsp            |</span><br><span class="line">|    |   %rbp       |    --------------------------</span><br><span class="line">|    +--------------+    </span><br><span class="line">|    |   var3       |    </span><br><span class="line">|    +--------------+</span><br><span class="line">|    |Return address|    test1</span><br><span class="line">V    +--------------------------- %rsp</span><br></pre></td></tr></table></figure><p></p><ol><li>每次调用进入到<code>test1</code>函数时，都返回了<code>lea -8(%rbp)</code>,因为%rbp的值是一样的所以他们引用的地址其实都是一样的</li><li>所以即使<code>*var1</code>第一次调用时的值是 10;</li><li>但是第二次调用时<code>*var1</code>所指向的地址内的值被20替换，导致最后<code>*var1,*var2</code>都是20</li></ol><h1 id="有栈协程-gt-golang"><a href="#有栈协程-gt-golang" class="headerlink" title="有栈协程 -&gt; golang"></a>有栈协程 -&gt; golang</h1><p>上面的栈例子中典型的用了c语言的例子，程序总体同步顺序运行，全部公用一个系统栈，并且随着不断的函数调用、函数返回，这个栈会不断复用</p><p>而有栈协程中的<code>有栈</code>到底是什么意思，这里其实是约定成俗想表达对于每个新创建的协程来说:他们都独立运行与一块新的栈，<code>这块栈是从堆(基于mmap维护了整个内存管理)上面申请的</code>，没用共用系统栈，那么这个协程的生命周期和上下文都能够被完整保存，可以被任意时间和任意线程独立执行</p><h2 id="go-创建协程"><a href="#go-创建协程" class="headerlink" title="go 创建协程"></a>go 创建协程</h2><p>在golang语言中，直接通过<code>go</code>关键字可以轻松创建一个协程，并传递一个待执行的<code>func函数</code>,在此之后整个func和当前主线程再无瓜葛，它会被任意调度到任意线程去执行或多次执行</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"this is a goroutine print!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际在编译后被换成了调用<code>runtime.newproc</code>方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个协程，用来运行传入的带有siz字节参数的函数</span><br><span class="line">// 将协程push到队列里 等待调度运行</span><br><span class="line">// 不能进行栈切分，因为函数参数需要拷贝，如果栈分裂的话可能fn后面的参数不完整了</span><br><span class="line">//go:nosplit</span><br><span class="line">func newproc(siz int32, fn *funcval) &#123;</span><br><span class="line">	//总的来说这里是编译器来调用的newproc方法，第一个参数siz 指明了调用函数fn的参数大小</span><br><span class="line">	//NOTICE: 参数全部是存放在栈上的，所以通过fn后面的偏移量+参数大小就可以完整的拷贝函数参数了</span><br><span class="line">	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">	//stack: [size,fn,arg1,arg2,arg3....] size 指明了arg1..argn的栈范围大小</span><br><span class="line">	gp := getg()</span><br><span class="line">	//获取调用方的下个指令地址，一般用于设置ip寄存器用于表示下一行代码该执行哪</span><br><span class="line">	pc := getcallerpc()</span><br><span class="line">	systemstack(func() &#123;</span><br><span class="line">		newproc1(fn, (*uint8)(argp), siz, gp, pc)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><code>fn</code>就是上文我们传递的闭包函数，待异步执行的函数方法</li><li>如果在创建协程的时候，带上了参数，也能通过栈偏移量获取到函数参数<code>add(unsafe.Pointer(&amp;fn),sys.PtrSize)</code>.需要马上将参数拷贝到协程空间内，因为这些参数仍然是存放在主线程栈上的(go嵌套则不一样)</li></ul><h2 id="分配栈"><a href="#分配栈" class="headerlink" title="分配栈"></a>分配栈</h2><p>这里任然是处于创建协程的收尾部分，主要处理两件事:</p><ol><li>给协程分配2k的内存作为函数运行的占空间(会复用其他已经释放的协程栈)</li><li>将协程丢给全局队列等待释放。在rust.tokio中相当于丢给<code>worker.shared.inject.push(task)</code>全局队列等待调度</li><li>设定<code>exit</code>函数，实现永不返回的循环调度（不同的协程栈之间切换已经没有return的概念了，直接永不停歇的往前走）<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在系统栈、g0栈上创建                                                                                                                                      uu一个协程</span></span><br><span class="line"><span class="comment">// 1. 拷贝参数到协程里</span></span><br><span class="line"><span class="comment">// 2. 初始化基本信息如，调用方的下一行代码地址，ip寄存器</span></span><br><span class="line"><span class="comment">// 3. 将协程推入全局列表等待调度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callergp *g, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//从tls中获取线程对应的协程</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//复用已经被释放了的之前的协程栈</span></span><br><span class="line">	newg := gfget(_p_)</span><br><span class="line">	<span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//立即创建一个协程+ 2k协程栈</span></span><br><span class="line">		newg = malg(_StackMin)</span><br><span class="line">		<span class="comment">//将g转换为dead状态</span></span><br><span class="line">		casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">		<span class="comment">//添加到allg全局队列管理</span></span><br><span class="line">		allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">	sp := newg.stack.hi - totalSize</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">	<span class="comment">//初始化时 记录了协程内当前栈顶 和 基栈</span></span><br><span class="line">	newg.sched.sp = sp</span><br><span class="line">	newg.stktopsp = sp</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">	<span class="comment">//协程内需要执行的代码指令地址，初始化时指向了函数的首地址,而在后面的生命周期中 会不断调度切换后会变化</span></span><br><span class="line">	newg.startpc = fn.fn</span><br><span class="line">    <span class="comment">//协程id</span></span><br><span class="line">	newg.goid = <span class="keyword">int64</span>(_p_.goidcache)</span><br><span class="line">	_p_.goidcache++</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">	<span class="comment">//将协程投递到本地队列或者全局队列等待调度器调度</span></span><br><span class="line">	runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">	<span class="comment">//顺便检查下，如果当前需要抢占则处理抢占</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123; <span class="comment">// restore the preemption request in case we've cleared it in newstack</span></span><br><span class="line">		<span class="comment">//编译器在函数调用的时候会检查是否栈溢出，这里巧妙的利用栈溢出来实现抢占</span></span><br><span class="line">		_g_.stackguard0 = stackPreempt</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="栈的上下文"><a href="#栈的上下文" class="headerlink" title="栈的上下文"></a>栈的上下文</h2><p>理想情况下面的函数在单线程中会顺序调用和执行，那么根据这种情况可以绘制一个理想的栈使用情况<br></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">go1_1</span><span class="params">()</span></span>&#123;<span class="keyword">var</span> var11 <span class="keyword">uint64</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">go1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> var1 <span class="keyword">uint64</span></span><br><span class="line">	go1_1()</span><br><span class="line">	<span class="comment">//go1_e 函数结束的指令地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	runtime.GOMAXPROCS();</span><br><span class="line">	<span class="keyword">go</span> go1()</span><br><span class="line">	<span class="keyword">go</span> go2()</span><br><span class="line">	<span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">go2</span><span class="params">()</span></span>&#123;go2_1()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">go2_1</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="/images/blog/rust/golang-stack.png" alt="image"><br>golang的协程永不return，不停的在协程间切换<br></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// One round of scheduler: find a runnable goroutine and execute it.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在研究调度器的时候会有一个疑问，注释明明写的<code>never returns</code>，但是却没有看到死循环的操作，那么是如何实现永不return的呢</p><p>总的来说可以总结以下几个函数的调用顺序来概览到这种循环机制<br></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">schedule()      g0栈上:开始执行一轮调度,找到需要唤醒的G</span><br><span class="line">execute()       g0栈上:开始唤醒协程G，切换到协程栈</span><br><span class="line">mcall(goexit1)  g栈   :开始切换到g0栈上回收以及结束的G</span><br><span class="line">schedule()      g0栈上:开始执行一轮调度，找到需要唤醒的G</span><br></pre></td></tr></table></figure><p></p><p>主要是三个函数就能描述了整个调度的生命周期，但其实还有一个问题在，上面的循环很像一个递归调用，那可不可能发生爆栈呢</p><p>核心就在于g0栈是复用的,也就是在每次从g0栈切换到g栈的时候是不保存g0栈的，这么就会导致g0栈始终会从默认的地方在下次继续执行<br></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $<span class="number">16</span><span class="number">-8</span></span><br><span class="line">	MOVQ	buf+<span class="number">0</span>(FP), BX		<span class="comment">// bx = gobuf</span></span><br><span class="line">	MOVQ	gobuf_g(BX), DX     <span class="comment">// dx = g</span></span><br><span class="line">	MOVQ	<span class="number">0</span>(DX), CX		<span class="comment">// make sure g != nil</span></span><br><span class="line">	get_tls(CX)</span><br><span class="line">	MOVQ	DX, g(CX)       <span class="comment">// 将目标g 设置为当前线程 tls-&gt;g</span></span><br><span class="line">	MOVQ	gobuf_sp(BX), SP	<span class="comment">// restore SP  恢复sp栈顶指针 $rsp = gobuf.sp 实现栈切换</span></span><br><span class="line">	MOVQ	gobuf_ret(BX), AX  <span class="comment">// ax = gobuf.ret</span></span><br><span class="line">	MOVQ	gobuf_ctxt(BX), DX <span class="comment">// dx = gobuf.ctxt 上下文信息</span></span><br><span class="line">	MOVQ	gobuf_bp(BX), BP    <span class="comment">// 恢复bp寄存器  $rbp = gobuf-&gt;bp 栈基指针 执行当前函数开始位置</span></span><br></pre></td></tr></table></figure><p></p><p>可以看到从g0栈切换到g栈的核心方法<code>gogo</code>中并没有保存当前g0的上下文，也就是说<code>g0-&gt;sched</code>上下文信息始终没有发生变化，在下次通过<code>mcall</code>等切换回g0时不会导致g0栈空间的开辟</p><h1 id="无栈协程-gt-rust"><a href="#无栈协程-gt-rust" class="headerlink" title="无栈协程-&gt;rust"></a>无栈协程-&gt;rust</h1><p>上面描述了两种栈，一种是c的全局系统栈，另外一个就是基于堆的golang协程栈</p><p>可以明显感受到golang的栈会复杂很多，而且开销非常大</p><ol><li>所有的协程都会默认分配2k内存</li><li>随着协程内函数调用的嵌套层级增大，2k栈明显不够用，那么会触发栈的扩容</li><li>栈扩容又会引发一系列引用问题</li></ol><p>但协程的实现又要保存上下文，不依赖单独的栈如何做到呢？。带着这个疑问来分析rust的黑魔法吧</p><p>还是先来感受下golang和rust关于协程的语法区别吧<br></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//golang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">go</span> fun()&#123;</span><br><span class="line">        fmt.Println(<span class="string">"ready to sleep!"</span>)</span><br><span class="line">        time.Sleep(<span class="number">8</span> * time.Second) </span><br><span class="line">        <span class="comment">//会暂停当前函数执行,给其他协程继续执行</span></span><br><span class="line">        <span class="comment">//等待睡眠时间到后重新调度后继续从当前位置向下执行</span></span><br><span class="line">        fmt.Println(<span class="string">"hello world 1!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rust</span></span><br><span class="line">tokio::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"ready to sleep"</span>);</span><br><span class="line">     tokio::time::sleep(time::Duration::from_secs(<span class="number">2</span>)).<span class="keyword">await</span>;</span><br><span class="line">     <span class="comment">//注意： 一定要加await！</span></span><br><span class="line">     <span class="comment">//当前函数会在这里暂停，等待睡眠时间到后继续恢复执行</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"hello world!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>两种语言的协程实现都能表现同样的功能，但rust已经能够感受到需要注意规范是比较多的</p><ol><li>rust没有自带的运行时，所有协程的调度、执行、切换都需要依赖三方实现，比较好的就是<code>tokio</code></li><li>编译器只干了一件事情: <code>在有await语句的地方检测是否ready，否则挂起函数，等待下次运行</code></li></ol><p>既然rust不像golang那样有单独的栈，那他怎么实现上下文保存和栈的重入呢？，比较都是依赖主线程栈，怎么切换呢，不得甚解</p><p>在了解rust通过await实现协程(特别强调await)前来一起看看什么叫做状态机吧</p><h2 id="rust-状态机"><a href="#rust-状态机" class="headerlink" title="rust 状态机"></a>rust 状态机</h2><p>理解协程的核心就是暂停和恢复，rust的协程通过状态机做到这一点，golang通过独立的栈做到这一点。理解这一点很重要</p><p>看个例子:(为了模拟暂停状态，需要自己实现一个future(async语句块))<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span> &#123;</span><br><span class="line">    ready: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> Task &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = <span class="built_in">bool</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ms = <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.get_unchecked_mut() &#125;;</span><br><span class="line">        <span class="keyword">if</span> !ms.ready &#123;</span><br><span class="line">            ms.ready = <span class="literal">true</span>;<span class="comment">//下一次再进来就是true</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"task not ready!"</span>);</span><br><span class="line">            Poll::Pending    </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"task is ready!"</span>);</span><br><span class="line">            Poll::Ready(ms.ready)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> task1 = Task&#123;ready:<span class="literal">false</span>&#125;;</span><br><span class="line">    task1.<span class="keyword">await</span>; <span class="comment">// 发生第一次暂停，因为task1返回了Poll::Pending,当前test也是一个协程，会保存上下文，结束当前函数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"test done!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    tokio::spawn(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ol><li>上面的实例永远只会打印一次<code>task is ready!</code>就结束了test（）函数的执行，下面的<code>test done!</code>永远不会被执行<ul><li>因为对于调度器tokio来说，他永远不知道task会在何时转换为Poll::Ready状态</li><li>所以一般真正的阻塞的需要切换的地方tokio都覆盖完了，比如(网络io，sleep等等api)，都会在发生阻塞的时候切换出去，在唤醒后主动在来调用一次</li><li>那么自己实现的阻塞的方法，那就需要注册唤醒器让tokio有能力重新调度了</li></ul></li><li>假定我们实现了唤醒器,并且将<code>ms.ready=true</code>注释掉`<ul><li>那么依然test函数会被重复调度运行，但用于只会执行 <code>task not ready</code>那段逻辑</li><li>因为：rust在编译阶段做了手脚，通过状态(Pending,Ready)来区分该执行哪段逻辑</li></ul></li></ol><p>现在还是有点晕，状态机到底是个什么东西，那么我们就从编译器的视角来看看上面的rust代码被编译器魔改后到底实际执行的是什么代码吧</p><h2 id="编译器生成的状态机代码"><a href="#编译器生成的状态机代码" class="headerlink" title="编译器生成的状态机代码"></a>编译器生成的状态机代码</h2><p>还是上面的那个例子，让我们来看看编译器最终生成的是什么代码吧(如下伪码)<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//原始代码</span></span><br><span class="line"><span class="comment">async fn test()&#123;</span></span><br><span class="line"><span class="comment">    let task = Task&#123;ready:false&#125;;</span></span><br><span class="line"><span class="comment">    task.await;</span></span><br><span class="line"><span class="comment">    println!("test done!");</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">test</span></span> &#123;</span><br><span class="line">    Enter,</span><br><span class="line">    Yield1 &#123;</span><br><span class="line">        task: Task,</span><br><span class="line">    &#125;,</span><br><span class="line">    Exit,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> test &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">start</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        test::Enter</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">execute</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            test::Enter =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> task = Task&#123;ready:<span class="literal">false</span>&#125;; <span class="comment">//源代码</span></span><br><span class="line">                *<span class="keyword">self</span> = test::Yield1&#123;task:task&#125; <span class="comment">//保存上下文</span></span><br><span class="line">            &#125;</span><br><span class="line">            test::Yield1 &#123;task&#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> task.poll() == Poll::Ready &#123;<span class="comment">//task.await 伪码</span></span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">"test done!"</span>);</span><br><span class="line">                    *<span class="keyword">self</span> = test::Exit; <span class="comment">//await结束 </span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            test::Exit =&gt; <span class="built_in">panic!</span>(<span class="string">"Can't do this again!"</span>),</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> t = test::start();</span><br><span class="line">    <span class="comment">//tokio::spawn(test())</span></span><br><span class="line">    <span class="comment">//背后其实就是多次t.execute()</span></span><br><span class="line">    <span class="comment">//第一次 t.execute() ready false 打印: not ready</span></span><br><span class="line">    <span class="comment">//第二次 t.execute() ready true  打印: test done</span></span><br><span class="line">    <span class="comment">// 如果task.ready状态一直为false，那么会一直执行test::Yield1这个分支</span></span><br><span class="line">    <span class="comment">//编译器将async fn test() 生成一个enum带有状态的状态机，从而实现了直接在系统栈上就能够实现协程的暂停与恢复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ol><li><code>重点</code>: rust编译器会将带有.await的代码快转换为一个enum 状态机，就像上文一下test函数被改成了<code>enum test</code></li><li>对于每个await的代码都实现为一个enum的分支</li><li>每次协程的暂停和恢复只是进入不同的代码分支罢了</li></ol><p>虽然没有了额外的占的开销，但实际上编译器会生成很多指令和分支来支持这个状态机</p><p>不过相比需要额外的栈内存来实现协程，这种方式已经非常棒了</p><h2 id="协程调度器-tokio-runtime"><a href="#协程调度器-tokio-runtime" class="headerlink" title="协程调度器(tokio runtime)"></a>协程调度器(tokio runtime)</h2><p>到上面为止我们只分析到了函数的暂停与恢复（协程的基本要素）。但何时暂停何时恢复这个rust并没有实现</p><p>调度器这种运行时功能目前比较好的三方实现是tokio</p><h3 id="1-启动多线程"><a href="#1-启动多线程" class="headerlink" title="1. 启动多线程"></a>1. 启动多线程</h3><p>初始化一个多线程的tokio运行时<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> rt = tokio::runtime::Builder::new_multi_thread().enable_all().build().unwrap();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>builder会区分是多线程版本还是单线程版本<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tokio/tokio/src/runtime/builder.rs:514</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">build</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; io::<span class="built_in">Result</span>&lt;Runtime&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> &amp;<span class="keyword">self</span>.kind &#123;</span><br><span class="line">        Kind::CurrentThread =&gt; <span class="keyword">self</span>.build_basic_runtime(),</span><br><span class="line">        <span class="meta">#[cfg(feature = <span class="meta-string">"rt-multi-thread"</span>)]</span></span><br><span class="line">        Kind::MultiThread =&gt; <span class="keyword">self</span>.build_threaded_runtime(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>创建系统多线程<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tokio/tokio/src/runtime/builder.rs:663</span></span><br><span class="line">cfg_rt_multi_thread! &#123;</span><br><span class="line">    <span class="keyword">impl</span> Builder &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">build_threaded_runtime</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; io::<span class="built_in">Result</span>&lt;Runtime&gt; &#123;</span><br><span class="line">        <span class="comment">//省略参数初始化。。。</span></span><br><span class="line">                    <span class="comment">// Spawn the thread pool workers</span></span><br><span class="line">        <span class="keyword">let</span> _enter = crate::runtime::context::enter(handle.clone());</span><br><span class="line">        <span class="comment">//开始派生系统线程</span></span><br><span class="line">        launch.launch();</span><br><span class="line">        <span class="literal">Ok</span>(Runtime &#123;</span><br><span class="line">            kind: Kind::ThreadPool(scheduler),</span><br><span class="line">            handle,</span><br><span class="line">            blocking_pool,</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="2-worker线程调度协程任务"><a href="#2-worker线程调度协程任务" class="headerlink" title="2. worker线程调度协程任务"></a>2. worker线程调度协程任务</h3><p>每个worker线程进入轮训模式<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tokio/tokio/src/runtime/thread_pool/worker.rs:382</span></span><br><span class="line"><span class="keyword">impl</span> Context &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>, <span class="keyword">mut</span> core: <span class="built_in">Box</span>&lt;Core&gt;) -&gt; RunResult &#123;</span><br><span class="line">        <span class="keyword">while</span> !core.is_shutdown &#123;</span><br><span class="line">            <span class="comment">// Increment the tick</span></span><br><span class="line">            core.tick();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Run maintenance, if needed</span></span><br><span class="line">            core = <span class="keyword">self</span>.maintenance(core);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// First, check work available to the current worker.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(task) = core.next_task(&amp;<span class="keyword">self</span>.worker) &#123;</span><br><span class="line">                core = <span class="keyword">self</span>.run_task(task, core)?;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// There is no more **local** work to process, try to steal work</span></span><br><span class="line">            <span class="comment">// from other workers.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(task) = core.steal_work(&amp;<span class="keyword">self</span>.worker) &#123;</span><br><span class="line">                core = <span class="keyword">self</span>.run_task(task, core)?;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Wait for work</span></span><br><span class="line">                core = <span class="keyword">self</span>.park(core);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        core.pre_shutdown(&amp;<span class="keyword">self</span>.worker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Signal shutdown</span></span><br><span class="line">        <span class="keyword">self</span>.worker.shared.shutdown(core);</span><br><span class="line">        <span class="literal">Err</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>短小精干，整个调度轮训代码就这么多，有点借鉴了golang的调度器，基本都是</p><ol><li>LIFO slot: 从优先队列获取协程任务执行</li><li>local queue: 从本地队列获取协程任务执行</li><li>global queue: 从全局队列获取协程任务执行</li><li>steal: 从其他线程队列窃取任务来执行</li></ol><h3 id="3-没有任务时进入事件轮训-epoll-wait"><a href="#3-没有任务时进入事件轮训-epoll-wait" class="headerlink" title="3. 没有任务时进入事件轮训(epoll_wait)"></a>3. 没有任务时进入事件轮训(epoll_wait)</h3><p>可以看到上面4个队列都没有获取到任务后，会调用<code>sel.park(core)</code>让出cpu，等待有事件到来时恢复线程后继续寻找下一个等待执行的协程任务</p><p>park被层层包装后最终的实现是通过<code>epoll_wait</code>来等待事件<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Park <span class="keyword">for</span> runtime::Driver::Driver &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">park</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), Self::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.inner.park()      <span class="comment">// call time driver's park</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;P&gt; Park <span class="keyword">for</span> time::driver::Driver&lt;P&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">park</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), Self::Error&gt; &#123;</span><br><span class="line">        <span class="comment">// ... preprocess for time</span></span><br><span class="line">        <span class="comment">// may call self.park.park_timeout(duration)?;</span></span><br><span class="line">        <span class="keyword">self</span>.park.park()?;     <span class="comment">// call process driver's park</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.handle.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Park <span class="keyword">for</span> process::unix::driver::Driver &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">park</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), Self::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.park.park()?;      <span class="comment">// call signal driver's park</span></span><br><span class="line">        <span class="keyword">self</span>.inner.process();</span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Park <span class="keyword">for</span> signal::unix::driver::Driver &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">park</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), Self::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.park.park()?;      <span class="comment">// call io driver's park</span></span><br><span class="line">        <span class="keyword">self</span>.process();</span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Park <span class="keyword">for</span> io::Driver &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">park</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.turn(<span class="literal">None</span>)?;</span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>继续调用<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">turn</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, max_wait: <span class="built_in">Option</span>&lt;Duration&gt;) -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// 省略了一些events处理</span></span><br><span class="line">    <span class="comment">// 重点就是这个</span></span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.poll.poll(&amp;<span class="keyword">mut</span> events, max_wait) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(_) =&gt; &#123;&#125;</span><br><span class="line">        <span class="literal">Err</span>(<span class="keyword">ref</span> e) <span class="keyword">if</span> e.kind() == io::ErrorKind::Interrupted =&gt; &#123;&#125;</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略了一些处理</span></span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>poll的实际实现是调用了mio的方法<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, events: &amp;<span class="keyword">mut</span> Events, timeout: <span class="built_in">Option</span>&lt;Duration&gt;) -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.registry.selector.select(events.sys(), timeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>select函数里通过syscall调用了epoll_wait,并且传入的timeout=-1，会一直阻塞直到有事件到来<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">select</span></span>(&amp;<span class="keyword">self</span>, events: &amp;<span class="keyword">mut</span> Events, timeout: <span class="built_in">Option</span>&lt;Duration&gt;) -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">//省略一些。。。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> timeout = timeout</span><br><span class="line">        .map(|to| cmp::min(to.as_millis(), MAX_SAFE_TIMEOUT) <span class="keyword">as</span> libc::c_int)</span><br><span class="line">        .unwrap_or(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    events.clear();</span><br><span class="line">    syscall!(epoll_wait(</span><br><span class="line">        <span class="keyword">self</span>.ep,</span><br><span class="line">        events.as_mut_ptr(),</span><br><span class="line">        events.capacity() <span class="keyword">as</span> <span class="built_in">i32</span>,</span><br><span class="line">        timeout,</span><br><span class="line">    ))</span><br><span class="line">    .map(|n_events| &#123;</span><br><span class="line">        <span class="comment">// This is safe because `epoll_wait` ensures that `n_events` are</span></span><br><span class="line">        <span class="comment">// assigned.</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; events.set_len(n_events <span class="keyword">as</span> <span class="built_in">usize</span>) &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="4-事件到来后的协程唤醒"><a href="#4-事件到来后的协程唤醒" class="headerlink" title="4. 事件到来后的协程唤醒"></a>4. 事件到来后的协程唤醒</h3><p>上面epoll_wait过后，有事件到来则会进行事件分发<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"><span class="keyword">match</span> <span class="keyword">self</span>.poll.poll(&amp;<span class="keyword">mut</span> events, max_wait)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> event <span class="keyword">in</span> events.iter() &#123;</span><br><span class="line">    <span class="keyword">let</span> token = event.token();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> token != TOKEN_WAKEUP &#123;</span><br><span class="line">        <span class="keyword">self</span>.dispatch(token, Ready::from_mio(event));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着就会进行事件处理，唤醒对应的线程，将task投递到队列中<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"><span class="comment">// set_readiness:</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> current = <span class="keyword">self</span>.readiness.load(Acquire);</span><br><span class="line"></span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current_generation = GENERATION.unpack(current);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(token) = token &#123;</span><br><span class="line">        <span class="keyword">if</span> GENERATION.unpack(token) != current_generation &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">Err</span>(());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.</span></span><br><span class="line">    <span class="keyword">let</span> current_readiness = Ready::from_usize(current);</span><br><span class="line">    <span class="keyword">let</span> new = f(current_readiness);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.</span></span><br><span class="line">    <span class="keyword">let</span> packed = <span class="keyword">match</span> tick &#123;</span><br><span class="line">        Tick::Set(t) =&gt; TICK.pack(t <span class="keyword">as</span> <span class="built_in">usize</span>, new.as_usize()),</span><br><span class="line">        Tick::Clear(t) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> TICK.unpack(current) <span class="keyword">as</span> <span class="built_in">u8</span> != t &#123;</span><br><span class="line">                <span class="comment">// Trying to clear readiness with an old event!</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Err</span>(());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TICK.pack(t <span class="keyword">as</span> <span class="built_in">usize</span>, new.as_usize())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.</span></span><br><span class="line">    <span class="keyword">let</span> next = GENERATION.pack(current_generation, packed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span></span><br><span class="line">        .readiness</span><br><span class="line">        .compare_exchange(current, next, AcqRel, Acquire)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">Ok</span>(_) =&gt; <span class="keyword">return</span> <span class="literal">Ok</span>(()),</span><br><span class="line">        <span class="comment">// we lost the race, retry!</span></span><br><span class="line">        <span class="literal">Err</span>(actual) =&gt; current = actual,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所有都处理完后，park函数返回到最开始调度循环，重新开始新的一轮任务处理</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>rust的协程主要是靠编译器的状态机实现 + 三方的调度器实现</p><p>tokio调度器的逻辑也有些借鉴了golang的调度器</p><p>大体分析的设计就是这样，当然细节没有深挖都是非常多的，但不妨碍我们对rust协程实现的理解</p></div><footer class="article-footer"></footer></div></article><nav id="article-nav"> <a href="/wiki/middlewares/glusterfs/1.glusterfs-客户端源码分析/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title"> glusterfs-客户端源码分析</div></a> <a href="/wiki/algorithm/graph/稀疏图-邻接表/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">稀疏图-邻接表</div></a></nav><script type="text/javascript">!function(){var e=window.location.href,r=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var o="//api.share.baidu.com/s.gif";r?(o+="?r="+encodeURIComponent(document.referrer),e&&(o+="&l="+e)):e&&(o+="?l="+e),(new Image).src=o}}(window)</script></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"> brewlin &copy; 2022 <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a><br> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten">wikitten</a><br><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> |<span id="busuanzi_container_site_pv"><i class="fa fa-user"><span id="busuanzi_value_site_uv"></span></i></span></div></div></footer><script src="/libs/lightgallery/js/lightgallery.min.js"></script><script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script><script src="/libs/lightgallery/js/lg-pager.min.js"></script><script src="/libs/lightgallery/js/lg-autoplay.min.js"></script><script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script><script src="/libs/lightgallery/js/lg-zoom.min.js"></script><script src="/libs/lightgallery/js/lg-hash.min.js"></script><script src="/libs/lightgallery/js/lg-share.min.js"></script><script src="/libs/lightgallery/js/lg-video.min.js"></script><script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/main.js"></script></div></body>