<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>Goos-底层协程实现(一) | Brewlin&#39;s Wiki</title><meta name="keywords" content="c,php,ext,linux,coroutine,thread,scheduler"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="本节主要讲解什么是协程、协程的实现、php的协程封装的内容，从为什么我们需要协程到如何实现协程，主要讲解协程、php、c、汇编指令的相关关系，从整体窥探它的整个结构  Goos-多线程协程实现简要 Goos-协程底层实现(一) Goos-线程协程隔离(二) Goos-线程切换实现(三) Goos-抢占调度实现(四) Goos-监控线程实现(五)  协程本质协程最直观的就是我们将一个闭包函数当做参数"><meta name="keywords" content="c,php,ext,linux,coroutine,thread,scheduler"><meta property="og:type" content="article"><meta property="og:title" content="Goos-底层协程实现(一)"><meta property="og:url" content="http://wiki.brewlin.com/wiki/blog/goos/Goos-底层协程实现(一)/index.html"><meta property="og:site_name" content="Brewlin&#39;s Wiki"><meta property="og:description" content="本节主要讲解什么是协程、协程的实现、php的协程封装的内容，从为什么我们需要协程到如何实现协程，主要讲解协程、php、c、汇编指令的相关关系，从整体窥探它的整个结构  Goos-多线程协程实现简要 Goos-协程底层实现(一) Goos-线程协程隔离(二) Goos-线程切换实现(三) Goos-抢占调度实现(四) Goos-监控线程实现(五)  协程本质协程最直观的就是我们将一个闭包函数当做参数"><meta property="og:locale" content="en"><meta property="og:image" content="http://wiki.brewlin.com/images/blog/goos/1.png"><meta property="og:image" content="http://wiki.brewlin.com/images/blog/goos/stack.png"><meta property="og:updated_time" content="2021-04-07T03:24:05.189Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Goos-底层协程实现(一)"><meta name="twitter:description" content="本节主要讲解什么是协程、协程的实现、php的协程封装的内容，从为什么我们需要协程到如何实现协程，主要讲解协程、php、c、汇编指令的相关关系，从整体窥探它的整个结构  Goos-多线程协程实现简要 Goos-协程底层实现(一) Goos-线程协程隔离(二) Goos-线程切换实现(三) Goos-抢占调度实现(四) Goos-监控线程实现(五)  协程本质协程最直观的就是我们将一个闭包函数当做参数"><meta name="twitter:image" content="http://wiki.brewlin.com/images/blog/goos/1.png"><link rel="alternate" href="/atom.xml" title="Brewlin&#39;s Wiki" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/libs/open-sans/styles.css"><link rel="stylesheet" href="/libs/source-code-pro/styles.css"><link rel="stylesheet" href="/css/style.css"><script src="/libs/jquery/2.1.3/jquery.min.js"></script><script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script><link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css"><link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head></html><body><div id="container"><header id="header"><div id="header-main" class="header-inner"><div class="outer"><a href="/" id="logo"><i class="logo"></i> <span class="site-title">Brewlin&#39;s Wiki</span></a><nav id="main-nav"> <a class="main-nav-link" href="/">首页</a> <a class="main-nav-link" href="/archives">归档</a> <a class="main-nav-link" href="/categories">分类</a> <a class="main-nav-link" href="/tags">标签</a> <a class="main-nav-link" href="/about">关于</a></nav><div id="search-form-wrap"><form class="search-form"> <input type="text" class="ins-search-input search-form-input" placeholder="Search"> <button type="submit" class="search-form-submit"></button></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"> <input type="text" class="ins-search-input" placeholder="Type something..."><span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script></div></div></div><div id="main-nav-mobile" class="header-sub header-inner"><table class="menu outer"><tr><td><a class="main-nav-link" href="/">首页</a></td><td><a class="main-nav-link" href="/archives">归档</a></td><td><a class="main-nav-link" href="/categories">分类</a></td><td><a class="main-nav-link" href="/tags">标签</a></td><td><a class="main-nav-link" href="/about">关于</a></td><td><div class="search-form"> <input type="text" class="ins-search-input search-form-input" placeholder="Search"></div></td></tr></table></div></header><div class="outer"><aside id="sidebar"><div class="widget-wrap" id="categories"><h3 class="widget-title"> <span>categories</span> &nbsp;<a id="allExpand" href="#"><i class="fa fa-angle-double-down fa-2x"></i></a></h3><ul class="unstyled" id="tree"><li class="directory open"><a href="#" data-role="directory"><i class="fa fa-folder-open"></i> &nbsp; blog</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; algorithm</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; graph</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/blog/algorithm/graph/dijkstra/">Dijkstra最短路径</a></li><li class="file"><a href="/wiki/blog/algorithm/graph/最小生成树/">最小生成树</a></li><li class="file"><a href="/wiki/blog/algorithm/graph/稀疏图-寻路/">稀疏图-寻路</a></li><li class="file"><a href="/wiki/blog/algorithm/graph/稀疏图-连通分量-bfs-dfs/">稀疏图-连通分量-bfs-dfs</a></li><li class="file"><a href="/wiki/blog/algorithm/graph/稀疏图-邻接表/">稀疏图-邻接表</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; gc-learning</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/blog/gc-learning/前言/1.什么是roots/">什么是Root</a></li><li class="file"><a href="/wiki/blog/gc-learning/前言/2.什么是heaps/">什么是Heap</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 算法实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/blog/gc-learning/算法实现/1.标记清除算法/">标记清除算法</a></li><li class="file"><a href="/wiki/blog/gc-learning/算法实现/2.标记清除-多链表法/">标记清除-多链表法</a></li><li class="file"><a href="/wiki/blog/gc-learning/算法实现/3.引用计数/">引用计数</a></li><li class="file"><a href="/wiki/blog/gc-learning/算法实现/4.GC复制/">GC复制</a></li><li class="file"><a href="/wiki/blog/gc-learning/算法实现/6.压缩算法-lisp2/">压缩算法-lisp2</a></li><li class="file"><a href="/wiki/blog/gc-learning/算法实现/7.压缩算法-two-finger/">压缩算法-two-finger</a></li><li class="file"><a href="/wiki/blog/gc-learning/算法实现/8.保守式gc/">关于保守式GC</a></li><li class="file"><a href="/wiki/blog/gc-learning/算法实现/10.三色标记清除/">三色标记清除</a></li><li class="file"><a href="/wiki/blog/gc-learning/算法实现/5.GC复制-标记清除/">GC复制-标记清除</a></li><li class="file"><a href="/wiki/blog/gc-learning/算法实现/9.分代回收算法/">分代回收算法</a></li></ul></li><li class="file"><a href="/wiki/blog/gc-learning/GC算法分析与实现/">GC算法分析与实现</a></li></ul></li><li class="directory open"><a href="#" data-role="directory"><i class="fa fa-folder-open"></i> &nbsp; goos</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/blog/goos/Goos-多线程协程实现简要/">Goos-多线程协程实现简要</a></li><li class="file"><a href="/wiki/blog/goos/Goos-底层协程实现(三)/">Goos-底层协程实现(三)</a></li><li class="file active"><a href="/wiki/blog/goos/Goos-底层协程实现(一)/">Goos-底层协程实现(一)</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; nginx</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; mini_ngx</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/blog/nginx/mini_ngx/1.mini_ngx_实现一-简述/">mini_ngx_实现一-简述</a></li><li class="file"><a href="/wiki/blog/nginx/mini_ngx/2.mini_ngx_实现二-core模块/">mini_ngx_实现二-core模块</a></li><li class="file"><a href="/wiki/blog/nginx/mini_ngx/3.mini_ngx_实现三-http模块/">mini_ngx_实现三-http模块</a></li><li class="file"><a href="/wiki/blog/nginx/mini_ngx/4.mini_ngx_实现四-event模块/">mini_ngx_实现四-event模块</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; sharmem</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/blog/nginx/sharmem/shamem.h/">shamem.h</a></li><li class="file"><a href="/wiki/blog/nginx/sharmem/共享内存/">共享内存的实现</a></li><li class="file"><a href="/wiki/blog/nginx/sharmem/shamem.c/">shamem.c</a></li></ul></li><li class="file"><a href="/wiki/blog/nginx/1.ngx_连接池与事件封装(一)/">ngx_连接池与事件封装(一)</a></li><li class="file"><a href="/wiki/blog/nginx/2.ngx_连接池与事件封装(二)/">ngx_连接池与事件封装(二)</a></li><li class="file"><a href="/wiki/blog/nginx/http_模块开发的步骤（一）/">http_模块开发的步骤</a></li><li class="file"><a href="/wiki/blog/nginx/nginx_内存池封装/">ngx_内存池封装</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; php</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/blog/php/linux_内核_链表偏移量技巧/">linux_内核_链表偏移量技巧</a></li><li class="file"><a href="/wiki/blog/php/php_引用计数与GC/">php_引用计数与gc</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; c-ext</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; coroutine</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/coroutine/协程/">协程</a></li><li class="file"><a href="/wiki/c-ext/coroutine/协程socket/">协程socket</a></li><li class="file"><a href="/wiki/c-ext/coroutine/协程tcp服务/">协程tcp服务</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; event</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/event/event/">event</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; hook</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/hook/runtime/">runtime</a></li><li class="file"><a href="/wiki/c-ext/hook/sleep/">sleep</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; memory</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/memory/共享内存/">共享内存</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; process</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/process/进程管理/">进程管理</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; thread</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/thread/线程池/">线程池</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; timer</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/timer/定时器/">定时器</a></li></ul></li><li class="file"><a href="/wiki/c-ext/index/">c扩展</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; go-stl</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; graph</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/graph/图论/">图论算法</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; hash</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/hash/hash_list/">哈希链表</a></li><li class="file"><a href="/wiki/go-stl/hash/hash_code/">哈希Code生成</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; queue</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/queue/list/">LIST</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; raft</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/raft/raft分布式一致性原理(一)/">raft分布式一致性原理(一)</a></li><li class="file"><a href="/wiki/go-stl/raft/raft分布式一致性原理(二)/">raft分布式一致性原理(二)</a></li><li class="file"><a href="/wiki/go-stl/raft/相关资料/">相关资料</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; tree</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/tree/binary-search/">二分搜索树</a></li><li class="file"><a href="/wiki/go-stl/tree/reds-black-tree/">红黑树</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; trie</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/trie/trie/">字典树</a></li></ul></li><li class="file"><a href="/wiki/go-stl/index/">GO标准库和算法应用</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; im-cloud</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 1.前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/1.前言/2.并发压测对比/">并发压测对比</a></li><li class="file"><a href="/wiki/im-cloud/1.前言/1.安装部署/">安装部署</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 2.版本</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/2.版本/1.版本兼容/">版本兼容</a></li><li class="file"><a href="/wiki/im-cloud/2.版本/2.单进程全协程化版/">单线程全协程化版</a></li><li class="file"><a href="/wiki/im-cloud/2.版本/3.多进程worker版/">多进程worker版本</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 3.相关组件</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; core</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/core/core/">core</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; database</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/database/db/">db</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; discovery</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/discovery/discovery/">discovery</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; grpc</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/grpc/grpc/">grpc</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; log</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/log/log/">log</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; memeory</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/memeory/memeory/">memory</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; process</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/process/process/">process</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; queue</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/queue/queue/">queue</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; redis</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/redis/redis/">redis</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; task</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/task/task/">task</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 4.开放接口</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/4.开放接口/logic开放接口/">Logic 节点开放接口</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 5.相关实现</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 1.底层实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/5.相关实现/1.底层实现/1.im-cloud/">im-cloud</a></li><li class="file"><a href="/wiki/im-cloud/5.相关实现/1.底层实现/2.通讯协议/">通讯协议</a></li><li class="file"><a href="/wiki/im-cloud/5.相关实现/1.底层实现/4.job节点/">job节点实现</a></li><li class="file"><a href="/wiki/im-cloud/5.相关实现/1.底层实现/5.logic节点/">logic节点实现</a></li><li class="file"><a href="/wiki/im-cloud/5.相关实现/1.底层实现/3.cloud节点/">cloud节点实现</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 2.应用实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/5.相关实现/2.应用实现/1.推送实现/">推送实现</a></li><li class="file"><a href="/wiki/im-cloud/5.相关实现/2.应用实现/2.服务发现/">服务发现</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 3.组件实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/5.相关实现/3.组件实现/1.连接池实现/">连接池实现</a></li></ul></li></ul></li><li class="file"><a href="/wiki/im-cloud/index/">im-cloud 分布式推送中间件</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; net-protocol</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 1.前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/1.前言/1.快速开始/">快速开始</a></li><li class="file"><a href="/wiki/net-protocol/1.前言/2.协议分层模型/">协议分层模型</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 2.应用层</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; dns</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/2.应用层/dns/1.dns协议简介/">dns协议简介</a></li><li class="file"><a href="/wiki/net-protocol/2.应用层/dns/2.dns协议实现/">dns协议实现</a></li><li class="file"><a href="/wiki/net-protocol/2.应用层/dns/3.dns协议api/">dns协议api</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; http</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/2.应用层/http/1.http协议解析/">http协议解析</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; websocket</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/2.应用层/websocket/2.websocket算法/">websocket算法</a></li><li class="file"><a href="/wiki/net-protocol/2.应用层/websocket/1.websocket协议解析/">websocket协议解析</a></li><li class="file"><a href="/wiki/net-protocol/2.应用层/websocket/3.websocket实现/">websocket实现</a></li></ul></li><li class="file"><a href="/wiki/net-protocol/2.应用层/应用层前世今生/">应用层前世今生</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 3.传输层</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; tcp</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/3.传输层/tcp/2.流量控制/">tcp流量控制</a></li><li class="file"><a href="/wiki/net-protocol/3.传输层/tcp/3.可靠性机制/">tcp可靠性机制</a></li><li class="file"><a href="/wiki/net-protocol/3.传输层/tcp/4.连接状态/">连接状态</a></li><li class="file"><a href="/wiki/net-protocol/3.传输层/tcp/1.头部/">tcp头部</a></li><li class="file"><a href="/wiki/net-protocol/3.传输层/tcp/5.流量控制的实现-滑动窗口/">流量控制-滑动窗口</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; udp</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/3.传输层/udp/1.协议/">udp协议</a></li><li class="file"><a href="/wiki/net-protocol/3.传输层/udp/2.检验和计算/">校验和计算</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 4.网络层</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/4.网络层/arp协议/">arp协议</a></li><li class="file"><a href="/wiki/net-protocol/4.网络层/协议_端口/">端口机制</a></li><li class="file"><a href="/wiki/net-protocol/4.网络层/跨子网arp查询&子网arp查询/">arp子网查询&跨子网查询</a></li><li class="file"><a href="/wiki/net-protocol/4.网络层/协议_icmp/">icmp协议</a></li><li class="file"><a href="/wiki/net-protocol/4.网络层/协议_ip/">ip协议</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 5.链路层</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/5.链路层/1.以太网协议/">以太网协议</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 6.物理层</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/6.物理层/tap/">tap</a></li><li class="file"><a href="/wiki/net-protocol/6.物理层/tool/">tool</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 7.客户端</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/7.客户端/http-客户端/">http-客户端</a></li><li class="file"><a href="/wiki/net-protocol/7.客户端/tcp-客户端/">tcp-客户端</a></li><li class="file"><a href="/wiki/net-protocol/7.客户端/udp-客户端/">udp-客户端</a></li><li class="file"><a href="/wiki/net-protocol/7.客户端/websocekt-客户端/">websocket-客户端</a></li><li class="file"><a href="/wiki/net-protocol/7.客户端/dns-客户端/">dns-客户端</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 8.问题反馈</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/8.问题反馈/tun_tap/">Tun/Tap虚拟网卡外网通讯</a></li></ul></li><li class="file"><a href="/wiki/net-protocol/index/">index</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; read</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/read/read/">read</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; swoole-im</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/swoole-im/前言/业务说明/">业务说明</a></li></ul></li><li class="file"><a href="/wiki/swoole-im/index/">微服务应用</a></li></ul></li><li class="file"><a href="/wiki/index/">Welcome Brewlin's Wiki Site</a></li></ul></div><script>$(document).ready(function(){var r="fa-folder-open",i="fa-folder",l="fa-angle-double-down",d="fa-angle-double-up";$(document).on("click",'#categories a[data-role="directory"]',function(a){a.preventDefault();var e=$(this).children(".fa"),s=e.hasClass(r),l=$(this).siblings("ul");e.removeClass(r).removeClass(i),s?(void 0!==l&&l.slideUp({duration:100}),e.addClass(i)):(void 0!==l&&l.slideDown({duration:100}),e.addClass(r))}),$('#categories a[data-role="directory"]').bind("contextmenu",function(a){a.preventDefault();var e=$(this).children(".fa"),s=e.hasClass(r),l=$(this).siblings("ul"),d=$.merge(l.find("li ul"),l),o=$.merge(l.find(".fa"),e);o.removeClass(r).removeClass(i),s?(d.slideUp({duration:100}),o.addClass(i)):(d.slideDown({duration:100}),o.addClass(r))}),$(document).on("click","#allExpand",function(a){a.preventDefault();var e=$(this).children(".fa"),s=e.hasClass(l);e.removeClass(l).removeClass(d),s?($("#sidebar .fa.fa-folder").removeClass("fa-folder").addClass("fa-folder-open"),$("#categories li ul").slideDown({duration:100}),e.addClass(d)):($("#sidebar .fa.fa-folder-open").removeClass("fa-folder-open").addClass("fa-folder"),$("#categories li ul").slideUp({duration:100}),e.addClass(l))})})</script><div id="toTop" class="fa fa-angle-up"></div></aside><section id="main"><article id="post-blog/goos/Goos-底层协程实现(一)" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><div class="article-meta"><div class="article-category"><i class="fa fa-folder"></i> <a class="article-category-link" href="/categories/blog/">blog</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/blog/goos/">goos</a></div><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/c/">c</a>, <a class="tag-link" href="/tags/coroutine/">coroutine</a>, <a class="tag-link" href="/tags/ext/">ext</a>, <a class="tag-link" href="/tags/linux/">linux</a>, <a class="tag-link" href="/tags/php/">php</a>, <a class="tag-link" href="/tags/scheduler/">scheduler</a>, <a class="tag-link" href="/tags/thread/">thread</a></div><div class="article-date"><i class="fa fa-calendar"></i> <a href="/wiki/blog/goos/Goos-底层协程实现(一)/"><time datetime="2020-08-10T13:28:59.000Z" itemprop="datePublished">2020-08-10</time></a></div><i class="fa fa-bar-chart"></i><span id="busuanzi_container_site_pv"><span id="busuanzi_value_page_pv"></span></span><div class="article-meta-button"> <a href="https://github.com/brewlin/docs/raw/master/source/_posts/blog/goos/Goos-底层协程实现(一).md">Source</a></div><div class="article-meta-button"> <a href="https://github.com/brewlin/docs/edit/master/source/_posts/blog/goos/Goos-底层协程实现(一).md">Edit</a></div><div class="article-meta-button"> <a href="https://github.com/brewlin/docs/commits/master/source/_posts/blog/goos/Goos-底层协程实现(一).md">History</a></div></div><h1 class="article-title" itemprop="name"> Goos-底层协程实现(一)</h1></header><div class="article-entry" itemprop="articleBody"><div id="toc" class="toc-article"> <strong class="toc-title">Catalogue</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#协程本质"><span class="toc-number">1.</span> <span class="toc-text">协程本质</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数本质"><span class="toc-number">2.</span> <span class="toc-text">函数本质</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#php函数的实现"><span class="toc-number">2.1.</span> <span class="toc-text">php函数的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c函数的实现"><span class="toc-number">2.2.</span> <span class="toc-text">c函数的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题-同时多个实例的内存是怎么区分的"><span class="toc-number">2.2.1.</span> <span class="toc-text">问题: 同时多个实例的内存是怎么区分的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数栈的形成"><span class="toc-number">2.2.2.</span> <span class="toc-text">函数栈的形成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用流程整理"><span class="toc-number">2.2.3.</span> <span class="toc-text">函数调用流程整理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈-amp-堆的区别"><span class="toc-number">2.2.4.</span> <span class="toc-text">栈&amp;堆的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数翻译后的cpu指令"><span class="toc-number">2.3.</span> <span class="toc-text">函数翻译后的cpu指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协程的创建"><span class="toc-number">3.</span> <span class="toc-text">协程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#php创建协程"><span class="toc-number">3.1.</span> <span class="toc-text">php创建协程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#全局队列与本地队列"><span class="toc-number">4.</span> <span class="toc-text">全局队列与本地队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协程的释放"><span class="toc-number">5.</span> <span class="toc-text">协程的释放</span></a></li></ol></div><p>本节主要讲解什么是协程、协程的实现、php的协程封装的内容，从为什么我们需要协程到如何实现协程，主要讲解协程、php、c、汇编指令的相关关系，从整体窥探它的整个结构</p><ul><li><a href="">Goos-多线程协程实现简要</a></li><li>Goos-协程底层实现(一)</li><li><a href="">Goos-线程协程隔离(二)</a></li><li><a href="">Goos-线程切换实现(三)</a></li><li><a href="">Goos-抢占调度实现(四)</a></li><li><a href="">Goos-监控线程实现(五)</a></li></ul><h1 id="协程本质"><a href="#协程本质" class="headerlink" title="协程本质"></a>协程本质</h1><p>协程最直观的就是我们将一个闭包函数当做<code>参数</code>丢给了某个任务去执行，那么实际执行的其实就是我们自定义的函数，如:<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">Runtime::GOMAXPROCS(<span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"start doing sth"</span>;</span><br><span class="line">&#125;</span><br><span class="line">go(task);</span><br><span class="line"></span><br><span class="line">Runtime::wait();</span><br></pre></td></tr></table></figure><p></p><p>可以看到我们将<code>task</code>函数交给<code>go</code>去执行，某些情况下和我们直接<code>task()</code>调用无任何区别，那么我们为什么还要通过<code>go</code>来调用呢，因为我们想要更好的控制该函数的生命周期，试下一下如下场景:</p><ol><li><p>网络等待导致当前进程阻塞与网络调用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//maybe 10s+ waiting</span></span><br><span class="line">    $data = scoket_read(fd);</span><br><span class="line">    <span class="comment">//then do sting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务逻辑死循环导致进程挂起</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sth is <span class="keyword">true</span>)</span><br><span class="line">            then <span class="keyword">break</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单纯是需要利用多核cpu，且不想采用多进程的方式</p></li></ol><p>如果我们直接就调用执行了<code>task</code>。上面的三种情况都会导致性能杀手或者进程卡死，有没有一种方法可以控制函数的执行并且能无需受到到所写的业务代码还要担心阻塞等心智负担呢。有没有办法能够充分利用多核实现并行执行呢，所以多线程协程才有了意义。</p><ol><li>针对第一种网络阻塞等三方接口调用导致的阻塞，将该代码丢入协程调度器去执行，那么发生阻塞的时候会自动跳过当前函数，继续执行其他任务，完美解决当前问题。当然我们还需要一个契机去恢复上一次函数的继续执行，这就是后续要实现的<code>poller</code>网络轮训器来作为调度过程的一部分，当网络事件到来则恢复刚才暂停的函数继续去执行</li><li>如果某个函数长期占有cpu，导致其他函数得不到执行，这种情况就可以发起抢占，将当前函数从调度器中移除，继续执行其他的任务，很好的解决了进程卡死和效率低的问题</li><li>当然对于多线程来说本身就是可以利用多核cpu的，这样就更好的控制了并发</li></ol><p>继续回到协程本质的话题，协程本质就是可以通过调度器来管理一个用户自定义的函数，且该自定义函数被执行的期间的任务可以称为协程，和直接调用函数的区别在于协程的整个期间可以由内由外来进行控制，</p><h1 id="函数本质"><a href="#函数本质" class="headerlink" title="函数本质"></a>函数本质</h1><p>我们通过函数来将我们的业务逻辑划分为多个子集，为了更好的管理工程和设计，我们可以拿函数来作为例子讲解一下实际的执行过程</p><h2 id="php函数的实现"><a href="#php函数的实现" class="headerlink" title="php函数的实现"></a>php函数的实现</h2><p>引用这里的文档:<a href="https://www.kancloud.cn/lifei6671/php-kernel/675135,来简单分析下函数的本质">https://www.kancloud.cn/lifei6671/php-kernel/675135,来简单分析下函数的本质</a></p><p>php函数实际对应于c语言的<code>zend_function</code>结构体:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span>  _zend_function        zend_function;</span><br><span class="line"></span><br><span class="line"><span class="comment">//zend_compile.h</span></span><br><span class="line"><span class="keyword">union</span> _zend_function &#123;</span><br><span class="line">    zend_uchar type;    <span class="comment">/* MUST be the first element of this struct! */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        zend_uchar type;  <span class="comment">/* never used */</span></span><br><span class="line">        zend_uchar arg_flags[<span class="number">3</span>]; <span class="comment">/* bitset of arg_info.pass_by_reference */</span></span><br><span class="line">        <span class="keyword">uint32_t</span> fn_flags;</span><br><span class="line">        zend_string *function_name;</span><br><span class="line">        zend_class_entry *scope; <span class="comment">//成员方法所属类，面向对象实现中用到</span></span><br><span class="line">        <span class="keyword">union</span> _zend_function *prototype;</span><br><span class="line">        <span class="keyword">uint32_t</span> num_args; <span class="comment">//参数数量</span></span><br><span class="line">        <span class="keyword">uint32_t</span> required_num_args; <span class="comment">//必传参数数量</span></span><br><span class="line">        zend_arg_info *arg_info; <span class="comment">//参数信息</span></span><br><span class="line">    &#125; common;</span><br><span class="line"></span><br><span class="line">    zend_op_array op_array; <span class="comment">//函数实际编译为普通的zend_op_array</span></span><br><span class="line">    zend_internal_function internal_function;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>php实际有两种函数，一种是普通函数，另外一只是对象成员函数。 成员函数和普通函数的区别在于,底层zend_function指针内部的scope 会指向一个对象，普通函数则为<code>NULL</code>，成员函数则会指向当前的<code>zend_class_entry</code>对象指针来实现<code>this</code>功能</p><p>对于php函数还有两个区别,用户自定义函数和内部函数,虽然所有的函数都被包装成为了<code>zend_function</code>，但<code>zend_function</code>是一个联合体，所以不同类型的函数在结构上还是有区别的</p><ol><li>php的内部函数、动态扩展提供的c函数等，这些都是直接存储了一个函数指针给php层面调用即可，即<code>zend_function-&gt;internal_function</code>指向的是c层面的函数指针，无需其他初始化操作</li><li>php用户自定义函数，这个时候就有点复杂了，这个层面是zend引擎通过词法、语法分析等将php代码翻译为opcode码、基本就是汇编代码，直接装到<code>op_array</code>中，在发生函数调用是,会将<code>op_array</code>载入全局execute_globals执行引擎，等待执行opcode码</li></ol><h2 id="c函数的实现"><a href="#c函数的实现" class="headerlink" title="c函数的实现"></a>c函数的实现</h2><p>c语言函数就显得非常纯粹了，完全是按照cpu的执行方式来进行思考的，需要完整的考虑内存如:堆、栈等信息，在c层面我们就能想到很多问题，那么我们来讲讲什么是堆？什么是栈?</p><p>对于cpu来说内部有多个寄存器，同一时间只能存储一个值，所以显然是不够的，我们的程序拥有无比复杂的变量定义和逻辑运算，例如x64位cpu有16个通用寄存器:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通用: %rax %rbx %rdx %esi %edi %rbp %rsp %8-%15 </span><br><span class="line">栈段: %ss  %sp</span><br><span class="line">码段: %cs %ip</span><br><span class="line">数据段: %ds,%es</span><br></pre></td></tr></table></figure><p></p><p>即使这样依然是不够的，我们需要一种比较持久的方法来存储我们的变量以及相关函数地址。那就是栈,那怎么标识一个栈的位置呢，比如栈的起始位置和结束位置:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpu中有两个关键的寄存器用于标识栈的信息，ss:sp:bp 等段基础寄存器</span><br><span class="line">ss: 指向栈段的顶点边界</span><br><span class="line">sp: 指向的是栈底边界</span><br><span class="line">bp: 一般在函数开始的时候，指向当前函数的栈底，sp=bp 然后对于栈上的变量都是基于bp+偏移量访问的</span><br></pre></td></tr></table></figure><p></p><h3 id="问题-同时多个实例的内存是怎么区分的"><a href="#问题-同时多个实例的内存是怎么区分的" class="headerlink" title="问题: 同时多个实例的内存是怎么区分的"></a>问题: 同时多个实例的内存是怎么区分的</h3><p>每个程序在编译为机器码后，对应的ss，sp段寄存器的地址都是一样的，在编译期间就计算了，例如<br><img src="/images/blog/goos/1.png" alt="image"></p><p>这个是一个win 16的debug.exe，可以看到每个cpu指令执行期间的每个寄存器的值，当你的程序被启动多次，也就是产生了多个进程时，对于cpu来说执行的指令没有任何区别，包括上面<code>ss</code>,<code>sp</code>对于的栈地址也是一样</p><p>那就产生一个疑问，这样的话多进程下岂不是变量共享了，其实到这里就需要引申一个<code>虚拟地址</code>的问题，其实我们的运行的程序所有变量的地址都是虚拟地址，在实际访问时，由操作系统转为实际的物理地址</p><p>这就是为什么你针对多个进程debug，查看同一个变量地址时都是相同的，但是实际所指的地址却不是同一个东西的原因</p><h3 id="函数栈的形成"><a href="#函数栈的形成" class="headerlink" title="函数栈的形成"></a>函数栈的形成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">SP 栈顶: 0x10000</span><br><span class="line">1. 这里是main函数        +--------------+ main函数起始地址</span><br><span class="line">                         |              |</span><br><span class="line">                    +    |              | 这里是本地的变量存储区域</span><br><span class="line">                    |    +--------------+</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    |   arg(N-1)   | 这里起始就开始准备调用函数了</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    +--------------+</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    |     argN     |</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    +--------------+</span><br><span class="line">                    |    |              |</span><br><span class="line">2.start call        |    |Return address|  %rbp + 8</span><br><span class="line">Stack grows down    |    |              |</span><br><span class="line"></span><br><span class="line">===================================================================================</span><br><span class="line"></span><br><span class="line">3.new function      |    +--------------+  新的函数栈起始地址</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    |     %rbp     |  在刚初始化的时候 sp=bp</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    +--------------+</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    |  local var1  |  %rbp - 8</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    +--------------+</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    | local var 2  | &lt;-- %rsp</span><br><span class="line">                    |    |              |</span><br><span class="line">                    v    +--------------+</span><br><span class="line">                         |              |</span><br><span class="line">                         |              |</span><br><span class="line">                         +--------------+</span><br><span class="line">SS 栈段边界         0x00000</span><br></pre></td></tr></table></figure><ol><li><p>main函数开始执行时从sp栈开始初开始存储，这个sp当前是栈内存区域的最大边界，没新增一个变量或者一些存储操作则进行 压栈操作，如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">会被翻译为如下汇编指令</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        <span class="comment">// 通过rbp -4 也就是用了栈的下面4字节来存储 int 2</span></span><br><span class="line">        <span class="comment">// 也就是压栈操作，其实这是一种直接操作栈的方式，这是编译器优化的结果</span></span><br><span class="line">        <span class="comment">// 正常情况下 应该使用  push 2;这种方式来操作栈，这样的话 sp始终会指向栈顶</span></span><br><span class="line">        <span class="comment">// 而通过偏移量来操作栈则不会引起 sp栈顶的变化</span></span><br><span class="line">        mov     DWORD PTR [rbp<span class="number">-4</span>], <span class="number">2</span></span><br><span class="line">        mov     eax, <span class="number">0</span></span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure></li><li><p>函数返回时的执行流程:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//汇编指令</span></span><br><span class="line">test:</span><br><span class="line">        <span class="comment">//这里是压栈，当前的rbp其实是 调用放函数的rsp地址</span></span><br><span class="line">        push    rbp</span><br><span class="line">        <span class="comment">//将当前栈顶 复制给rbp寄存器，从此开辟了一个新的函数栈区</span></span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        <span class="comment">//这里就是我们程序实际逻辑开始的地方</span></span><br><span class="line">        mov     eax, <span class="number">2</span></span><br><span class="line">        <span class="comment">//程序结束，恢复调用方函数的栈底</span></span><br><span class="line">        pop     rbp</span><br><span class="line">        <span class="comment">//这里就是返回调用方调用函数的地方，恢复函数继续运行</span></span><br><span class="line">        ret</span><br><span class="line">        <span class="comment">//所谓函数返回，其实只是修改cpu的ip cs寄存器，修改cpu下一条需要执行的指令</span></span><br><span class="line">        <span class="comment">//那么下一条需要执行的指令其实就是 上面的Return address地址，我们也可以通过其他方法来实现ret</span></span><br><span class="line">        <span class="comment">// jmp %rbp+8;(%rbp+8  就是调用方函数的下一个cpu指令地址)从而实现了返回函数的功能</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="函数调用流程整理"><a href="#函数调用流程整理" class="headerlink" title="函数调用流程整理"></a>函数调用流程整理</h3><p>来自：<a href="https://juejin.im/post/6844903930497859591">https://juejin.im/post/6844903930497859591</a> go plan9 汇编的函数调用图</p><p>因为总体流程大致相似<br><img src="/images/blog/goos/stack.png" alt="image"></p><ol><li>每个函数执行期间 通过 <code>bp,sp</code>寄存器来表示内存区域</li><li><code>bp</code>寄存器一般不会发生改变，一般通过bp+偏移量来获取相关栈上的变量</li><li><code>sp</code>表示的是栈顶，调用<code>push</code>指令会自动修改sp指向的值</li><li>通过整体流程的熟悉后，就能明白为什么栈数据是局部变量，会被回收（其实不是立即回收）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们的栈是一个整段内存 0x00000 - 010000,整个栈内存都会不断复用，如上所示，当函数返回时，当前bp就会被恢复为之前调用方函数的栈，那么当前函数的区域就保持不变。</span><br><span class="line">如果发生其他调用，则会复用当前函数的区域，则会覆盖当前变量</span><br><span class="line"></span><br><span class="line">所以在c语言中返回一个局部变量地址，在其他地方依然能够访问的前提是因为没有新函数的栈内存将当前栈覆盖</span><br></pre></td></tr></table></figure></li></ol><h3 id="栈-amp-堆的区别"><a href="#栈-amp-堆的区别" class="headerlink" title="栈&amp;堆的区别"></a>栈&amp;堆的区别</h3><ol><li>栈是一块连续内存，由操作系统在程序执行期间为整个进程分配的生命周期</li><li>堆内存是独立于当前栈的另外一个快内存，自然该内存不会受到像栈那样覆盖的影响，所以需要开发者自己管理，所以在c等静态语言中存在一个非常恐怖的问题(内存泄露),堆内存如果申请次数！=释放次数，那么你的内存就会逐渐飙升，等待系统给你kill吧</li></ol><p>其实对于计算机来说，所有的都是二进制数据，没有代码和数据的区别，那怎么区分代码和数据呢，在cpu中有一个寄存器叫<code>ip</code>寄存器，存储的是下一条指令的地址，如果不发生中断的情况下顺序读取ip寄存器的值来进行执行，所谓的数据段只是应用层面划分的一块区域，使ip寄存器不会去访问该区域而实现的一个数据块，堆和栈就是典型的数据块，栈数据块会被多次复用，而堆数据块是栈快之外的额外需要向操作系统申请的一块内存</p><h2 id="函数翻译后的cpu指令"><a href="#函数翻译后的cpu指令" class="headerlink" title="函数翻译后的cpu指令"></a>函数翻译后的cpu指令</h2><p>再来看看一个c语言函数被编译后的汇编指令，因为汇编语言已经是最底层的语法表达，基本就是二进制指令一一对应，所以可以用汇编来表示最底层的cpu指令</p><p>下面是一个函数调用<code>test</code>和定义一个全局变量的例子<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">"string data"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>编译后的汇编<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.LC0:</span><br><span class="line">        .string &quot;string data&quot;</span><br><span class="line">str:</span><br><span class="line">        .quad   .LC0</span><br><span class="line">test:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     eax, 2</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 16</span><br><span class="line">        mov     DWORD PTR [rbp-4], 2</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        call    test</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p></p><p>汇编最左边是一个标号，也可以当做地址，在其他地方直接通过该标号就可以引用到该地址</p><ol><li>main: 这个标号是在程序启动时由外部来进行调用跳转的，所以程序开始的地方就是 <code>main</code>标号，也就是 <code>$rip = main:</code>设置 ip寄存器为main，开始执行main函数</li><li><code>push rbp</code>: 基本所有的函数在执行前都要执行这行指令，表示将之前的栈底<code>rbp</code>保存起来，我们知道函数调用返回后需要恢复当前的栈环境，那么在调用函数之前，要保存当前的栈信息，所以需要<code>push rbp</code></li><li><code>mov rbp,rsp</code>: 这个就比较清楚了，表示开辟一个新栈，把当前的<code>栈顶</code>设置为新函数的<code>栈底</code>,那么新函数的执行环境就在新的栈空间使用</li><li><code>sub rsp,16</code> : 这个模拟压栈，我们知道<code>rsp</code>代表的是栈顶，那么我们也可以手动将栈顶下移一定的空间，而申请的空间我们可以存储变量等信息,这行和手动执行2次<code>push ***</code>是相同的，因为push首先<code>rsp -= 8</code>然后在将数据写入栈区</li><li><code>mov dword ptr [rbp-4],2</code>: 步骤4的时候新开辟了16字节的空间，这里就是通过对rbp进行偏移量来获取第一个4字节空间，然后将2存储进去，实现的一种手动压栈</li><li><code>mov eax,0</code>: 这个没什么特别的，ax寄存器一般用作计算、传参等作用的寄存器，这里先初始化恢复为0</li><li><p><code>call test</code>: 如1所说的，test是一个标号，也是一个地址，所以这里实际的执行可以分为如下两个步骤:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push cs //将代码段基段 cs保存起来</span><br><span class="line">push ip //将ip段保存起来，这里相当于这个ip就是返回地址，当被调用函数返回的时，会获取当前换个ip在jmp %rip</span><br><span class="line">jmp  test // 跳转到test标号的地址，实现函数调用</span><br></pre></td></tr></table></figure></li><li><p>test: 进入test函数内部，首先执行<code>push rbp</code> 保存上一个函数的栈底指针</p></li><li><code>mov rbp,rsp</code>: 和main函数一样开辟新栈</li><li><code>mov eax,2</code>: 这里就是我们的c代码<code>return 2</code>的实际汇编指令，因为返回一般用ax寄存器存储，所以这里现将2存入eax寄存器</li><li><code>pop rbp</code>: 恢复main函数的栈底指针，准备返回到main函数的下一行代码继续执行</li><li><code>ret</code>: 可以表示为如下汇编<code>pop ip</code>实际就是获取main函数的之前保存的ip值，然后恢复到ip寄存器中，实现函数返回</li><li>最后讲讲全局变量:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//char *str = &quot;string data&quot;;</span><br><span class="line">c代码会被翻译为如下的汇编指令，可以看到全局变量也是放到整个代码段上面的，如何区分该代码是数据还是代码呢，区别就在我们的程序如何去对待他</span><br><span class="line">比如我们不管在何时引用.LCO时都是把他当做一个数据来处理，而不是加载到ip当做指令来执行</span><br><span class="line">.LC0:</span><br><span class="line">        .string &quot;string data&quot;</span><br><span class="line">str:</span><br><span class="line">        .quad   .LC0</span><br></pre></td></tr></table></figure></li></ol><h1 id="协程的创建"><a href="#协程的创建" class="headerlink" title="协程的创建"></a>协程的创建</h1><p>这里来讲讲我们php扩展怎么创建一个协程，php代码和扩展的c代码怎么交互的问题</p><h2 id="php创建协程"><a href="#php创建协程" class="headerlink" title="php创建协程"></a>php创建协程</h2><p>php执行一个协程函数<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"go task"</span>;</span><br><span class="line">&#125;</span><br><span class="line">go(task);</span><br></pre></td></tr></table></figure><p></p><p>c层面获取该函数<code>wrapper/coroutine.cpp</code>：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(go_create)</span><br><span class="line">&#123;</span><br><span class="line">    zend_fcall_info fci = empty_fcall_info;</span><br><span class="line">    zend_fcall_info_cache fcc = empty_fcall_info_cache;</span><br><span class="line">    <span class="comment">//1 -1 可变参数</span></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line">    Z_PARAM_FUNC(fci,fcc)</span><br><span class="line">    Z_PARAM_VARIADIC(<span class="string">"*"</span>,fci.params,fci.param_count)</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE);</span><br><span class="line">    <span class="keyword">long</span> cid = PHPCoroutine::go(fcc.function_handler,fci.params,fci.param_count);</span><br><span class="line">    RETURN_LONG(cid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过<code>PHP_FUNCTION</code>申明一个提供给php调用的api，<code>go</code>实际执行的是c的<code>go_create</code>。<code>fci,fcc</code>可以表示一个php传过来的函数参数.<br>通过<code>PHPCoroutine::go</code>来初始化一个协程，并投递到调度器去执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/coroutine/PHPCoroutine.cpp</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个协程G运行</span></span><br><span class="line"><span class="comment"> * @param call</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">PHPCoroutine::go</span><span class="params">(zend_function *func,zval *argv,<span class="keyword">uint32_t</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ZendFunction *call = <span class="keyword">new</span> ZendFunction(func,argv,argc);</span><br><span class="line">    Coroutine *ctx = <span class="keyword">new</span> Coroutine(run, call);</span><br><span class="line">    <span class="keyword">return</span> ctx-&gt;run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>拷贝当前用户函数，因为多线程协程情况下已经采取了线程隔离<code>TSRM</code>,所以该闭包任务呗调度到其他线程执行时环境不同，且当前函数返回后可能被回收等因素，需要对用户的函数进行硬拷贝，拷贝会专门在线程隔离中说明。</li><li>创建一个<code>G</code>绑定当前php用户函数，等待投递调度</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//coroutine/Coroutine.cpp</span></span><br><span class="line"> * 投递到调度到其他线程CPU中去执行</span><br><span class="line"> * @<span class="keyword">return</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">long</span> Coroutine::run()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//投递到 proc 线程去执行该协程</span></span><br><span class="line">    <span class="keyword">if</span>(proc == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"未初始化线程"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"未初始化线程"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;gogo(ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里基本就完成了一个php协程创建到执行的过程了，<code>proc-&gt;gogo</code>后面就是属于调度和任务投递的事情了，这个是多线程调度处理的，会有专门的章节讲解</p><h1 id="全局队列与本地队列"><a href="#全局队列与本地队列" class="headerlink" title="全局队列与本地队列"></a>全局队列与本地队列</h1><p>目前实现的多线程协程基于两个队列来调度任务，一个是全局队列，所有线程获取时需要枷锁，另外一个是本地队列，目前只处理被调度过的协程，不接受新协程投递<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//runtime/proc.cpp</span></span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;queue_mu)</span></span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;cond.wait(lock,[<span class="keyword">this</span>,rq]&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.empty() || !rq-&gt;q-&gt;isEmpty();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.empty() &amp;&amp; rq-&gt;q-&gt;isEmpty())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>-&gt;tasks.empty())&#123;</span><br><span class="line">                ctx = move(<span class="keyword">this</span>-&gt;tasks.front());</span><br><span class="line">                <span class="keyword">this</span>-&gt;tasks.pop();</span><br><span class="line">                co = <span class="keyword">static_cast</span>&lt;Coroutine *&gt;(ctx-&gt;func_data);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                co = rq-&gt;q-&gt;pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(co == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"co exception:"</span>&lt;&lt;co&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p></p><ol><li><code>tasks</code> 是一个全局队列，新创建的协程优先投递到tasks等待所以线程获取，这里的问题就是会导致竞争严重，多线程会同时获取锁来争抢该协程</li><li><code>rq-&gt;q</code> 是一个本地队列，通过<code>GO_ZG(rq)</code>来获取该队列，所以调度的前提就是本地队列和全局队列都有数据则触发调度循环，获取待处理的协程进行切入</li></ol><h1 id="协程的释放"><a href="#协程的释放" class="headerlink" title="协程的释放"></a>协程的释放</h1><p>协程的释放，目前协程的释放会回收c栈和php栈，会极大的影响性能，后面会实现c和php栈复用，更好的提高性能<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//coroutine/coroutine.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Coroutine::close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    zend_vm_stack <span class="built_in">stack</span> = EG(vm_stack);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">    restore_stack(&amp;main_stack);</span><br><span class="line">    <span class="keyword">delete</span> ctx;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ol><li>将当前的通过堆申请的栈销毁，也就是销毁php栈</li><li>恢复在协程切入前的主php栈，模拟函数返回</li><li>删除<code>ctx</code>也就是c栈，回收c栈</li><li><code>delete this</code>删除G相关内存，回收内存</li></ol></div><footer class="article-footer"></footer></div></article><nav id="article-nav"> <a href="/wiki/blog/goos/Goos-底层协程实现(三)/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title"> Goos-底层协程实现(三)</div></a> <a href="/wiki/blog/goos/Goos-多线程协程实现简要/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">Goos-多线程协程实现简要</div></a></nav><script type="text/javascript">!function(){var e=window.location.href,r=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var o="//api.share.baidu.com/s.gif";r?(o+="?r="+encodeURIComponent(document.referrer),e&&(o+="&l="+e)):e&&(o+="?l="+e),(new Image).src=o}}(window)</script></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"> brewlin &copy; 2021 <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a><br> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten">wikitten</a><br><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> |<span id="busuanzi_container_site_pv"><i class="fa fa-user"><span id="busuanzi_value_site_uv"></span></i></span></div></div></footer><script src="/libs/lightgallery/js/lightgallery.min.js"></script><script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script><script src="/libs/lightgallery/js/lg-pager.min.js"></script><script src="/libs/lightgallery/js/lg-autoplay.min.js"></script><script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script><script src="/libs/lightgallery/js/lg-zoom.min.js"></script><script src="/libs/lightgallery/js/lg-hash.min.js"></script><script src="/libs/lightgallery/js/lg-share.min.js"></script><script src="/libs/lightgallery/js/lg-video.min.js"></script><script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/main.js"></script></div></body>