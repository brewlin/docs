<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>Goos-多线程协程实现简要 | Brewlin&#39;s Wiki</title><meta name="keywords" content="c,php,ext,linux,coroutine,thread,scheduler"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="简介Goos 是一个借鉴Golang的多线程协程调度器的设计而利用C++实现的PHP扩展。笔者在接触golang的协程调度器的力量后不能自拔，感受到协程的魅力后也想试试能不能为php也实现这么炫酷的功能 Goos 目的是实现一个真正意义的单进程多线程协程调度器，充分利用多核,使动态语言也能高效的开发出高性能的服务。目前主要实现进展如下:   php环境线程隔离，协程隔离  实现G-M调度,任意协程"><meta name="keywords" content="c,php,ext,linux,coroutine,thread,scheduler"><meta property="og:type" content="article"><meta property="og:title" content="Goos-多线程协程实现简要"><meta property="og:url" content="http://wiki.brewlin.com/wiki/blog/goos/Goos-多线程协程实现简要/index.html"><meta property="og:site_name" content="Brewlin&#39;s Wiki"><meta property="og:description" content="简介Goos 是一个借鉴Golang的多线程协程调度器的设计而利用C++实现的PHP扩展。笔者在接触golang的协程调度器的力量后不能自拔，感受到协程的魅力后也想试试能不能为php也实现这么炫酷的功能 Goos 目的是实现一个真正意义的单进程多线程协程调度器，充分利用多核,使动态语言也能高效的开发出高性能的服务。目前主要实现进展如下:   php环境线程隔离，协程隔离  实现G-M调度,任意协程"><meta property="og:locale" content="en"><meta property="og:updated_time" content="2020-11-10T03:30:29.228Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Goos-多线程协程实现简要"><meta name="twitter:description" content="简介Goos 是一个借鉴Golang的多线程协程调度器的设计而利用C++实现的PHP扩展。笔者在接触golang的协程调度器的力量后不能自拔，感受到协程的魅力后也想试试能不能为php也实现这么炫酷的功能 Goos 目的是实现一个真正意义的单进程多线程协程调度器，充分利用多核,使动态语言也能高效的开发出高性能的服务。目前主要实现进展如下:   php环境线程隔离，协程隔离  实现G-M调度,任意协程"><link rel="alternate" href="/atom.xml" title="Brewlin&#39;s Wiki" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/libs/open-sans/styles.css"><link rel="stylesheet" href="/libs/source-code-pro/styles.css"><link rel="stylesheet" href="/css/style.css"><script src="/libs/jquery/2.1.3/jquery.min.js"></script><script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script><link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css"><link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head></html><body><div id="container"><header id="header"><div id="header-main" class="header-inner"><div class="outer"><a href="/" id="logo"><i class="logo"></i> <span class="site-title">Brewlin&#39;s Wiki</span></a><nav id="main-nav"> <a class="main-nav-link" href="/">首页</a> <a class="main-nav-link" href="/archives">归档</a> <a class="main-nav-link" href="/categories">分类</a> <a class="main-nav-link" href="/tags">标签</a> <a class="main-nav-link" href="/about">关于</a></nav><div id="search-form-wrap"><form class="search-form"> <input type="text" class="ins-search-input search-form-input" placeholder="Search"> <button type="submit" class="search-form-submit"></button></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"> <input type="text" class="ins-search-input" placeholder="Type something..."><span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script></div></div></div><div id="main-nav-mobile" class="header-sub header-inner"><table class="menu outer"><tr><td><a class="main-nav-link" href="/">首页</a></td><td><a class="main-nav-link" href="/archives">归档</a></td><td><a class="main-nav-link" href="/categories">分类</a></td><td><a class="main-nav-link" href="/tags">标签</a></td><td><a class="main-nav-link" href="/about">关于</a></td><td><div class="search-form"> <input type="text" class="ins-search-input search-form-input" placeholder="Search"></div></td></tr></table></div></header><div class="outer"><aside id="sidebar"><div class="widget-wrap" id="categories"><h3 class="widget-title"> <span>categories</span> &nbsp;<a id="allExpand" href="#"><i class="fa fa-angle-double-down fa-2x"></i></a></h3><ul class="unstyled" id="tree"><li class="directory open"><a href="#" data-role="directory"><i class="fa fa-folder-open"></i> &nbsp; blog</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; algorithm</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/blog/algorithm/最小生成树/">最小生成树</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; gc-learning</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/blog/gc-learning/前言/1.简介/">简介</a></li><li class="file"><a href="/wiki/blog/gc-learning/前言/2.什么是roots/">什么是Root</a></li><li class="file"><a href="/wiki/blog/gc-learning/前言/3.什么是heaps/">什么是Heap</a></li></ul></li></ul></li><li class="directory open"><a href="#" data-role="directory"><i class="fa fa-folder-open"></i> &nbsp; goos</a><ul class="unstyled" id="tree"><li class="file active"><a href="/wiki/blog/goos/Goos-多线程协程实现简要/">Goos-多线程协程实现简要</a></li><li class="file"><a href="/wiki/blog/goos/Goos-底层协程实现(三)/">Goos-底层协程实现(三)</a></li><li class="file"><a href="/wiki/blog/goos/Goos-底层协程实现(一)/">Goos-底层协程实现(一)</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; nginx</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; mini_ngx</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/blog/nginx/mini_ngx/1.mini_ngx_实现一-简述/">mini_ngx_实现一-简述</a></li><li class="file"><a href="/wiki/blog/nginx/mini_ngx/2.mini_ngx_实现二-core模块/">mini_ngx_实现二-core模块</a></li><li class="file"><a href="/wiki/blog/nginx/mini_ngx/3.mini_ngx_实现三-http模块/">mini_ngx_实现三-http模块</a></li><li class="file"><a href="/wiki/blog/nginx/mini_ngx/4.mini_ngx_实现四-event模块/">mini_ngx_实现四-event模块</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; sharmem</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/blog/nginx/sharmem/shamem.c/">shamem.c</a></li><li class="file"><a href="/wiki/blog/nginx/sharmem/shamem.h/">shamem.h</a></li><li class="file"><a href="/wiki/blog/nginx/sharmem/共享内存/">共享内存的实现</a></li></ul></li><li class="file"><a href="/wiki/blog/nginx/1.ngx_连接池与事件封装(一)/">ngx_连接池与事件封装(一)</a></li><li class="file"><a href="/wiki/blog/nginx/2.ngx_连接池与事件封装(二)/">ngx_连接池与事件封装(二)</a></li><li class="file"><a href="/wiki/blog/nginx/http_模块开发的步骤（一）/">http_模块开发的步骤</a></li><li class="file"><a href="/wiki/blog/nginx/nginx_内存池封装/">ngx_内存池封装</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; php</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/blog/php/linux_内核_链表偏移量技巧/">linux_内核_链表偏移量技巧</a></li><li class="file"><a href="/wiki/blog/php/php_引用计数与GC/">php_引用计数与gc</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; c-ext</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; coroutine</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/coroutine/协程/">协程</a></li><li class="file"><a href="/wiki/c-ext/coroutine/协程socket/">协程socket</a></li><li class="file"><a href="/wiki/c-ext/coroutine/协程tcp服务/">协程tcp服务</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; event</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/event/event/">event</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; hook</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/hook/runtime/">runtime</a></li><li class="file"><a href="/wiki/c-ext/hook/sleep/">sleep</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; memory</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/memory/共享内存/">共享内存</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; process</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/process/进程管理/">进程管理</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; thread</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/thread/线程池/">线程池</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; timer</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/c-ext/timer/定时器/">定时器</a></li></ul></li><li class="file"><a href="/wiki/c-ext/index/">c扩展</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; go-stl</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; graph</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/graph/图论/">图论算法</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; hash</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/hash/hash_code/">哈希Code生成</a></li><li class="file"><a href="/wiki/go-stl/hash/hash_list/">哈希链表</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; queue</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/queue/list/">LIST</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; raft</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/raft/raft分布式一致性原理(一)/">raft分布式一致性原理(一)</a></li><li class="file"><a href="/wiki/go-stl/raft/raft分布式一致性原理(二)/">raft分布式一致性原理(二)</a></li><li class="file"><a href="/wiki/go-stl/raft/相关资料/">相关资料</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; tree</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/tree/binary-search/">二分搜索树</a></li><li class="file"><a href="/wiki/go-stl/tree/reds-black-tree/">红黑树</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; trie</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/go-stl/trie/trie/">字典树</a></li></ul></li><li class="file"><a href="/wiki/go-stl/index/">GO标准库和算法应用</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; im-cloud</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 1.前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/1.前言/1.安装部署/">安装部署</a></li><li class="file"><a href="/wiki/im-cloud/1.前言/2.并发压测对比/">并发压测对比</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 2.版本</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/2.版本/1.版本兼容/">版本兼容</a></li><li class="file"><a href="/wiki/im-cloud/2.版本/2.单进程全协程化版/">单线程全协程化版</a></li><li class="file"><a href="/wiki/im-cloud/2.版本/3.多进程worker版/">多进程worker版本</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 3.相关组件</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; core</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/core/core/">core</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; database</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/database/db/">db</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; discovery</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/discovery/discovery/">discovery</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; grpc</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/grpc/grpc/">grpc</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; log</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/log/log/">log</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; memeory</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/memeory/memeory/">memory</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; process</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/process/process/">process</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; queue</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/queue/queue/">queue</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; redis</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/redis/redis/">redis</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; task</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/3.相关组件/task/task/">task</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 4.开放接口</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/4.开放接口/logic开放接口/">Logic 节点开放接口</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 5.相关实现</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 1.底层实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/5.相关实现/1.底层实现/1.im-cloud/">im-cloud</a></li><li class="file"><a href="/wiki/im-cloud/5.相关实现/1.底层实现/2.通讯协议/">通讯协议</a></li><li class="file"><a href="/wiki/im-cloud/5.相关实现/1.底层实现/4.job节点/">job节点实现</a></li><li class="file"><a href="/wiki/im-cloud/5.相关实现/1.底层实现/5.logic节点/">logic节点实现</a></li><li class="file"><a href="/wiki/im-cloud/5.相关实现/1.底层实现/3.cloud节点/">cloud节点实现</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 2.应用实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/5.相关实现/2.应用实现/1.推送实现/">推送实现</a></li><li class="file"><a href="/wiki/im-cloud/5.相关实现/2.应用实现/2.服务发现/">服务发现</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 3.组件实现</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/im-cloud/5.相关实现/3.组件实现/1.连接池实现/">连接池实现</a></li></ul></li></ul></li><li class="file"><a href="/wiki/im-cloud/index/">im-cloud 分布式推送中间件</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; net-protocol</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 1.前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/1.前言/1.快速开始/">快速开始</a></li><li class="file"><a href="/wiki/net-protocol/1.前言/2.协议分层模型/">协议分层模型</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 2.应用层</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; dns</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/2.应用层/dns/1.dns协议简介/">dns协议简介</a></li><li class="file"><a href="/wiki/net-protocol/2.应用层/dns/2.dns协议实现/">dns协议实现</a></li><li class="file"><a href="/wiki/net-protocol/2.应用层/dns/3.dns协议api/">dns协议api</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; http</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/2.应用层/http/1.http协议解析/">http协议解析</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; websocket</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/2.应用层/websocket/2.websocket算法/">websocket算法</a></li><li class="file"><a href="/wiki/net-protocol/2.应用层/websocket/1.websocket协议解析/">websocket协议解析</a></li><li class="file"><a href="/wiki/net-protocol/2.应用层/websocket/3.websocket实现/">websocket实现</a></li></ul></li><li class="file"><a href="/wiki/net-protocol/2.应用层/应用层前世今生/">应用层前世今生</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 3.传输层</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; tcp</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/3.传输层/tcp/2.流量控制/">tcp流量控制</a></li><li class="file"><a href="/wiki/net-protocol/3.传输层/tcp/3.可靠性机制/">tcp可靠性机制</a></li><li class="file"><a href="/wiki/net-protocol/3.传输层/tcp/4.连接状态/">连接状态</a></li><li class="file"><a href="/wiki/net-protocol/3.传输层/tcp/5.流量控制的实现-滑动窗口/">流量控制-滑动窗口</a></li><li class="file"><a href="/wiki/net-protocol/3.传输层/tcp/1.头部/">tcp头部</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; udp</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/3.传输层/udp/1.协议/">udp协议</a></li><li class="file"><a href="/wiki/net-protocol/3.传输层/udp/2.检验和计算/">校验和计算</a></li></ul></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 4.网络层</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/4.网络层/arp协议/">arp协议</a></li><li class="file"><a href="/wiki/net-protocol/4.网络层/协议_icmp/">icmp协议</a></li><li class="file"><a href="/wiki/net-protocol/4.网络层/协议_端口/">端口机制</a></li><li class="file"><a href="/wiki/net-protocol/4.网络层/跨子网arp查询&子网arp查询/">arp子网查询&跨子网查询</a></li><li class="file"><a href="/wiki/net-protocol/4.网络层/协议_ip/">ip协议</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 5.链路层</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/5.链路层/1.以太网协议/">以太网协议</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 6.物理层</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/6.物理层/tap/">tap</a></li><li class="file"><a href="/wiki/net-protocol/6.物理层/tool/">tool</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 7.客户端</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/7.客户端/dns-客户端/">dns-客户端</a></li><li class="file"><a href="/wiki/net-protocol/7.客户端/http-客户端/">http-客户端</a></li><li class="file"><a href="/wiki/net-protocol/7.客户端/tcp-客户端/">tcp-客户端</a></li><li class="file"><a href="/wiki/net-protocol/7.客户端/udp-客户端/">udp-客户端</a></li><li class="file"><a href="/wiki/net-protocol/7.客户端/websocekt-客户端/">websocket-客户端</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 8.问题反馈</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/net-protocol/8.问题反馈/tun_tap/">Tun/Tap虚拟网卡外网通讯</a></li></ul></li><li class="file"><a href="/wiki/net-protocol/index/">index</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; read</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/read/read/">read</a></li></ul></li><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; swoft-im</a><ul class="unstyled" id="tree"><li class="directory"><a href="#" data-role="directory"><i class="fa fa-folder"></i> &nbsp; 前言</a><ul class="unstyled" id="tree"><li class="file"><a href="/wiki/swoft-im/前言/业务说明/">业务说明</a></li></ul></li><li class="file"><a href="/wiki/swoft-im/index/">微服务应用</a></li></ul></li><li class="file"><a href="/wiki/index/">Welcome Brewlin's Wiki Site</a></li></ul></div><script>$(document).ready(function(){var r="fa-folder-open",i="fa-folder",l="fa-angle-double-down",d="fa-angle-double-up";$(document).on("click",'#categories a[data-role="directory"]',function(a){a.preventDefault();var e=$(this).children(".fa"),s=e.hasClass(r),l=$(this).siblings("ul");e.removeClass(r).removeClass(i),s?(void 0!==l&&l.slideUp({duration:100}),e.addClass(i)):(void 0!==l&&l.slideDown({duration:100}),e.addClass(r))}),$('#categories a[data-role="directory"]').bind("contextmenu",function(a){a.preventDefault();var e=$(this).children(".fa"),s=e.hasClass(r),l=$(this).siblings("ul"),d=$.merge(l.find("li ul"),l),o=$.merge(l.find(".fa"),e);o.removeClass(r).removeClass(i),s?(d.slideUp({duration:100}),o.addClass(i)):(d.slideDown({duration:100}),o.addClass(r))}),$(document).on("click","#allExpand",function(a){a.preventDefault();var e=$(this).children(".fa"),s=e.hasClass(l);e.removeClass(l).removeClass(d),s?($("#sidebar .fa.fa-folder").removeClass("fa-folder").addClass("fa-folder-open"),$("#categories li ul").slideDown({duration:100}),e.addClass(d)):($("#sidebar .fa.fa-folder-open").removeClass("fa-folder-open").addClass("fa-folder"),$("#categories li ul").slideUp({duration:100}),e.addClass(l))})})</script><div id="toTop" class="fa fa-angle-up"></div></aside><section id="main"><article id="post-blog/goos/Goos-多线程协程实现简要" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><div class="article-meta"><div class="article-category"><i class="fa fa-folder"></i> <a class="article-category-link" href="/categories/blog/">blog</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/blog/goos/">goos</a></div><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/c/">c</a>, <a class="tag-link" href="/tags/coroutine/">coroutine</a>, <a class="tag-link" href="/tags/ext/">ext</a>, <a class="tag-link" href="/tags/linux/">linux</a>, <a class="tag-link" href="/tags/php/">php</a>, <a class="tag-link" href="/tags/scheduler/">scheduler</a>, <a class="tag-link" href="/tags/thread/">thread</a></div><div class="article-date"><i class="fa fa-calendar"></i> <a href="/wiki/blog/goos/Goos-多线程协程实现简要/"><time datetime="2020-07-10T13:28:59.000Z" itemprop="datePublished">2020-07-10</time></a></div><i class="fa fa-bar-chart"></i><span id="busuanzi_container_site_pv"><span id="busuanzi_value_page_pv"></span></span><div class="article-meta-button"> <a href="https://github.com/brewlin/docs/raw/master/source/_posts/blog/goos/Goos-多线程协程实现简要.md">Source</a></div><div class="article-meta-button"> <a href="https://github.com/brewlin/docs/edit/master/source/_posts/blog/goos/Goos-多线程协程实现简要.md">Edit</a></div><div class="article-meta-button"> <a href="https://github.com/brewlin/docs/commits/master/source/_posts/blog/goos/Goos-多线程协程实现简要.md">History</a></div></div><h1 class="article-title" itemprop="name"> Goos-多线程协程实现简要</h1></header><div class="article-entry" itemprop="articleBody"><div id="toc" class="toc-article"> <strong class="toc-title">Catalogue</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#swoole的协程相关"><span class="toc-number">2.</span> <span class="toc-text">swoole的协程相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么无完整调度器协程"><span class="toc-number">2.1.</span> <span class="toc-text">为什么无完整调度器协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook-php原生函数"><span class="toc-number">2.1.1.</span> <span class="toc-text">Hook php原生函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在api中埋点监测协程"><span class="toc-number">2.1.2.</span> <span class="toc-text">在api中埋点监测协程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是栈复用"><span class="toc-number">2.2.</span> <span class="toc-text">什么是栈复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么是无栈内存收缩"><span class="toc-number">2.3.</span> <span class="toc-text">为什么是无栈内存收缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么无抢占调度"><span class="toc-number">2.4.</span> <span class="toc-text">为什么无抢占调度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#golang的调度"><span class="toc-number">3.</span> <span class="toc-text">golang的调度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#简要总结"><span class="toc-number">4.</span> <span class="toc-text">简要总结</span></a></li></ol></div><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Goos 是一个借鉴Golang的多线程协程调度器的设计而利用C++实现的PHP扩展。笔者在接触golang的协程调度器的力量后不能自拔，感受到协程的魅力后也想试试能不能为php也实现这么炫酷的功能</p><p>Goos 目的是实现一个真正意义的单进程多线程协程调度器，充分利用多核,使动态语言也能高效的开发出高性能的服务。目前主要实现进展如下:</p><ul><li style="list-style:none"><input type="checkbox" checked="checked"> php环境线程隔离，协程隔离</li><li style="list-style:none"><input type="checkbox" checked="checked"> 实现G-M调度,任意协程G创建后，自动绑定到线程M上去执行</li><li style="list-style:none"><input type="checkbox" checked="checked"> 实现多线程协程G调度，切出与恢复</li><li style="list-style:none"><input type="checkbox" checked="checked"> 优化php内存相关</li><li style="list-style:none"><input type="checkbox"> 引入P, 实现G-P-M 任务窃取调度</li><li style="list-style:none"><input type="checkbox"> 协程栈自动收缩，防止 stack overflow</li><li style="list-style:none"><input type="checkbox" checked="checked"> 实现抢占调度,可以对任意在执行的协程发起抢占</li><li style="list-style:none"><input type="checkbox" checked="checked"> 优化抢占调度,检查任意超过10ms持有G的线程，发起抢占调度</li></ul><p>目前主要在优化内存方面的实现、引入P的实现、周边工具的开发(lock…)</p><p>接下来的其他文章将陆续讲解从底层至汇编指令-php应用层的整个实现过程</p><ul><li>Goos-多线程协程实现简要</li><li><a href="">Goos-协程底层实现(一)</a></li><li><a href="">Goos-线程协程隔离(二)</a></li><li><a href="">Goos-线程切换实现(三)</a></li><li><a href="">Goos-抢占调度实现(四)</a></li><li><a href="">Goos-监控线程实现(五)</a></li></ul><p>现在php其实也有许多相关扩展都带有协程实现的、如swoole。swoole和golang区别还是挺大的。下面来讲讲swoole和golang的简单区别吧</p><h1 id="swoole的协程相关"><a href="#swoole的协程相关" class="headerlink" title="swoole的协程相关"></a>swoole的协程相关</h1><p>swoole的协程为单进程协程,无完整调度器，只有触发了相关hook后才能切换，例如：swoole可以替换<code>function_table</code>中的sleep变成非阻塞，当调用sleep后直接切出当前协程</p><p>在内存方面swoole会申请c栈和php栈，基本上每个协程会占有2m的堆内存，且在协程销毁后该内存没有复用而是直接释放，因为swoole协程没有栈的收缩，所以需要注意在协程内的不要越栈Stack Overflow，否则system会给你一个segment error kill 进程。</p><p>综上建议不要什么都往协程上扔，针对这种协程机制需要严格考虑场景否则协程就是你的瓶颈。</p><p>总结一下swoole的协程机制：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 无协程调度只能依赖hook原生函数实现切换</span><br><span class="line"></span><br><span class="line">- 协程栈无复用导致频繁大内存申请释放</span><br><span class="line"></span><br><span class="line">- 无栈内存收缩，当协程栈溢出后即致命错误</span><br><span class="line"></span><br><span class="line">- 无抢占调度(发生for死循环将永远占用cpu)、</span><br><span class="line"></span><br><span class="line">- 同步协程模型</span><br></pre></td></tr></table></figure><p></p><p>上面的声明只是针对swoole的协程相关，因为swoole在多进程模式下也能充分利用多核cpu，弥补了一些不足，并且swoole的task-worker模型也做的足够出色了，可以轻松的实现一个多进程常驻通讯服务</p><h2 id="为什么无完整调度器协程"><a href="#为什么无完整调度器协程" class="headerlink" title="为什么无完整调度器协程"></a>为什么无完整调度器协程</h2><p>我认为调度过程应该是一个底层的分配管理过程，就像linux的调度一样是一个更加底层的管理，无需用户去关注，而针对协程的调度目前主要有两个方面</p><p>协程让出:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个正在运行的G，享有独立的栈空间，该栈是从堆上分配的一块独立内存来模拟栈行为。</span><br><span class="line">且该独立的函数栈在执行过程中能够中断，能够暂停后被切出</span><br><span class="line">就像我们的系统进程，线程一样，对于上层开发者来说是无感知的，</span><br><span class="line">其实系统随时都在进行着切换</span><br></pre></td></tr></table></figure><p></p><p>协程恢复<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个独立的函数栈因为在执行到一半的时候被调度出去了，那么在恢复的时候我们要能够让cpu继续执行在让出时的那条指令。</span><br><span class="line">从而达到该暂停的函数能够继续向下执行，在执行完毕的时候要能够返回到我们正常的流程这里</span><br></pre></td></tr></table></figure><p></p><p>具体协程的底层实现和流程我们会单独拿一个文章来说</p><p>swoole目前的协程是能够进行随意的切出和让出的，但是我想标注的点在于切出和让出的点应该有调度器来完全完成，而swoole目前是需要开发者具备协程的切出和恢复时机的</p><p>接下来讲讲swoole协程调度的点，swoole目前主要有两种实现来切换让出协程</p><ol><li>Hook php原生函数</li><li>swoole相关api都加入检查是否需要切出</li></ol><h3 id="Hook-php原生函数"><a href="#Hook-php原生函数" class="headerlink" title="Hook php原生函数"></a>Hook php原生函数</h3><p>在讲讲hook前，我们先说一下php函数的调用<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">php在脚本初始化阶段会初始化所有模块，并将对应模块函数 zend_function* 和php内置的函数存入一个全局EG(function_table)中，这个是一个hash表。</span><br><span class="line">其实就是php里的数组底层的实现，然后key就是对应的php内置的函数名</span><br><span class="line"></span><br><span class="line">那么能够想到value就是该函数的实际地址或者opcode汇编指令，这里不细说，因为php函数有好几种类型。</span><br><span class="line">普通的c动态库扩展的函数就是一个函数指针指向扩展里的实际函数地址，而php内部函数比如用户自定义的函数可能就是一份编译过后的opcode码指令</span><br><span class="line"></span><br><span class="line">在函数调用前(针对内置函数 比如sleep)，会先去全局EG(function_table)-&gt;zend_hash_index(sleep) </span><br><span class="line">查找是否存在，如果存在则获取对应的value，并设置对应的php函数栈帧信息，并执行</span><br></pre></td></tr></table></figure><p></p><p>所以这里所说的hook，我们就可以理解为，在我们的php扩展里将全局函数替换为自己的自定函数，当用户执行sleep时<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sleep(<span class="number">10000</span>);<span class="comment">//实际被替换为协程版的sleep实现</span></span><br><span class="line">&#125;</span><br><span class="line">go(co);</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------</span></span><br><span class="line">demo.sleep.c</span><br><span class="line">EG(function_table)-&gt;zend_hash_update_ptr(<span class="string">"sleep"</span>,co_sleep);</span><br><span class="line"></span><br><span class="line">void co_sleep(long sec)</span><br><span class="line">&#123;</span><br><span class="line">    timer.add(_g,sec);</span><br><span class="line">    _g.swap_out();</span><br><span class="line">&#125;</span><br><span class="line">void timer_loop()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    int n = epoll_wait(epfd,events,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(....)&#123;</span><br><span class="line">        g = events[i];</span><br><span class="line">        <span class="comment">//在timer定时器中在执行恢复该协程</span></span><br><span class="line">        g.swap_out()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>实际执行的是一个协程切换的方法，并且将当前协程加入 timer中，等待epoll时间片到期后恢复</p><h3 id="在api中埋点监测协程"><a href="#在api中埋点监测协程" class="headerlink" title="在api中埋点监测协程"></a>在api中埋点监测协程</h3><p>这个容易想到，在swoole的新增api中，都会监测是否需要切入或者恢复，例如调用swoole协程客户端<code>send</code>，因为该tcp端点属性被设置为边缘模式，也就是如果没有就绪事件则不阻塞进程，而是直接返回EAGAIN，那么此时swoole就会将该G加入到epoll_add中管理，等待事件到来后 在恢复该执行</p><h2 id="什么是栈复用"><a href="#什么是栈复用" class="headerlink" title="什么是栈复用"></a>什么是栈复用</h2><p>一个协程的准备环境是需要申请两次大内存，一个是php栈，一个是c栈，来看看什么是函数栈，来着曹大的图:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">                         +--------------+</span><br><span class="line">                         |              |</span><br><span class="line">                    +    |              |</span><br><span class="line">                    |    +--------------+</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    |   arg(N-1)   |  starts from 7&apos;th argument for x86_64</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    +--------------+</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    |     argN     |</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    +--------------+</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    |Return address|  %rbp + 8</span><br><span class="line">Stack grows down    |    |              |</span><br><span class="line">                    |    +--------------+</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    |     %rbp     |  Frame base pointer</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    +--------------+</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    |  local var1  |  %rbp - 8</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    +--------------+</span><br><span class="line">                    |    |              |</span><br><span class="line">                    |    | local var 2  | &lt;-- %rsp</span><br><span class="line">                    |    |              |</span><br><span class="line">                    v    +--------------+</span><br><span class="line">                         |              |</span><br><span class="line">                         |              |</span><br><span class="line">                         +--------------+</span><br></pre></td></tr></table></figure><p></p><p>首先受限于寄存器数量的原因，大多数变量都是存储在在栈中，每次新调用一个函数，那么就会保存当前上下文变量到栈中，最后将当前指令地址 <code>cs,ip</code>(就是函数的返回地址)压栈，然后在jump到目的指令地址实现函数调用，新函数栈会在系统栈<code>下面继续使用</code>，不断从高地址往低地址增长，如果函数返回则低地址往高地址增长<code>出栈</code>。所以这就是为什么栈上的变量在函数退出后不能再使用了的原因(虽然变量不会被立即销毁，但是如果发生其他函数调用，则会复用该地址的数据，这样就会导致非法内存访问，发生难以排查的致命bug)</p><p>上面的图加上粗略的描述了函数栈后来讲讲为什么要用堆模拟栈：</p><p>协程也是一个函数，那为什么要另外申请一个堆内存来当做该函数的执行栈呢，而不用本身系统为当前进程分配的栈呢，正如上面讲的当前栈在函数退出后，会被其他函数栈给覆盖，那么当前函数的所有上下文和变量都变成了未知内存</p><p>所以想要支持协程函数的切换和恢复，那么肯定是需要一直保存该函数栈的上下文信息的，所以只能用堆内存来当做栈使用</p><p>让我们继续回到swoole栈复用的问题，因为每次协程创建都会申请8kphp栈和2mc栈，且协程释放后会销毁该内存，所有目前swoole会存在这种频繁申请和释放的浪费情况，因为swooole是进程模型所以协程是同步的，所以就算创建千万协程也是同步排队执行，不会导致内存飙升</p><h2 id="为什么是无栈内存收缩"><a href="#为什么是无栈内存收缩" class="headerlink" title="为什么是无栈内存收缩"></a>为什么是无栈内存收缩</h2><p>上面降了函数栈的模型，我们知道在函数内所有产生的栈变量都会压栈，不断的使用栈空间，但是这个栈是系统分配的栈空间，默认是可以<code>达到进程上限</code>的</p><p>而我们要实现的协程是申请的一份堆内存来模拟的栈，所以大小一开始就固定好的且不会太大，当我们在协程内做了大量操作栈溢出后，就会<code>触发堆溢出</code>引发致命问题<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">高地址位 堆内存的末尾位置</span><br><span class="line">                ┼───────────┼</span><br><span class="line">                │  返回值g   │</span><br><span class="line">                ┼───────────┼</span><br><span class="line">                │  返回值f   │</span><br><span class="line">                ┼───────────┼</span><br><span class="line">                │  返回值e   │</span><br><span class="line">                ┼───────────┼</span><br><span class="line">                │  参数之c   │</span><br><span class="line">                ┼───────────┼</span><br><span class="line">                │  参数之b   │</span><br><span class="line">                ┼───────────┼</span><br><span class="line">                │  参数之a   │     &lt;-- FP</span><br><span class="line">                ┼───────────┼</span><br><span class="line">                │    PC     │     &lt;-- SP</span><br><span class="line">                ┼───────────┼</span><br><span class="line">                |。。。。。 |</span><br><span class="line">                </span><br><span class="line">低地址位  堆内存的起始位置</span><br></pre></td></tr></table></figure><p></p><p>swoole貌似目前在协程里跑大的数组进行遍历就会导致栈溢出，这就需要开发者在开发中小心这类问题</p><p>这就是无栈收缩会导致的问题，如果栈能够自动收缩，就无需考虑协程<code>预分配大小</code>,<code>栈溢出</code>等问题，既能节省内存也能是开发效率高效</p><h2 id="为什么无抢占调度"><a href="#为什么无抢占调度" class="headerlink" title="为什么无抢占调度"></a>为什么无抢占调度</h2><p>何谓抢占调度，就是强制的被动触发的调度。在正常情况下发生调度都依赖于函数执行流遇到了阻塞或是主动让出才会触发切换。那抢占的意义又是什么呢,想象一下如下场景在swoole中使用<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">go(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      <span class="comment">//do sth</span></span><br><span class="line">      <span class="comment">//then break</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><ol><li><p>如果上面的没有发生死循环，始终会等到某个条件中断该循环，那么依然会存在如下问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">如果该协程是在网络触发事件中被恢复的协程，那么自然能想到如下的情景</span><br><span class="line">for(;;)&#123;</span><br><span class="line">    epoll_wait(...)</span><br><span class="line">    </span><br><span class="line">    //co-&gt;resume()</span><br><span class="line">&#125;</span><br><span class="line">那么如果这时候上面那个协程执行的时间过长，都会直接影响其他流程的精度，比如timer是挂在epoll上触发的，那么定时器就会一直得不到执行，且网络事件也得不到执行</span><br><span class="line"></span><br><span class="line">这时候就会有其他意外产生</span><br></pre></td></tr></table></figure></li><li><p>如果上面的协程发生死循环，永远不会中断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在目前没有抢占调度的情况下，自然阻塞当前进程，任何其他都得不到执行，基本就是死锁的样子了</span><br></pre></td></tr></table></figure></li></ol><p>这个时候就知道了抢占调度的意义了，监测每个协程的执行时间，严格控制时间，发生超时则调度该协程切出，这都是一个完整的协程调度器需要考虑的事情</p><h1 id="golang的调度"><a href="#golang的调度" class="headerlink" title="golang的调度"></a>golang的调度</h1><p>golang 的调度就非常完整了，golang走的单进程多线程协程实现并发控制，swoole基于多进程同步协程实现并发控制，各有优缺点，我认为最大的区别就是</p><p>对于技术实现来说：</p><blockquote><p>golang的多线程协程对于实现者来说非常复杂，而swoole的多进程同步协程对于实现者来说要相对友好，反正基于线程的实现都是异常恐怖的</p></blockquote><p>对于技术使用者来说:</p><blockquote><p>多线程的协程当然用起来要高效简单很多，无需关心进程通信等，而多进程对于开发者来说就稍微不友好一点</p></blockquote><p>golang的协程和swoole比起来当然是完全不同的，golang走的多线程协程，所以几乎上面的特性都支持例如:</p><ol><li>多线程调度</li><li>任务窃取器调度</li><li>抢占式调度</li><li>以及一些协程的优化:栈内存自动收缩</li><li>还有超多的协程生态工具链:lock,channel..等等</li></ol><h1 id="简要总结"><a href="#简要总结" class="headerlink" title="简要总结"></a>简要总结</h1><p>上面的协程方面的设计确实还是和golang相差较大，swoole本身走的是多进程路线，同步协程只是为它在加了一份力，所以硬要和golang完整的单进程多线程协程比是没意义的</p><p>所以GOOS由此而来，想为php生效一个多线程协程版调度，从而使php既能保持动态语言编写代码的高效又能实现golang等静态语言的高性能并发控制</p></div><footer class="article-footer"></footer></div></article><nav id="article-nav"> <a href="/wiki/blog/goos/Goos-底层协程实现(一)/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title"> Goos-底层协程实现(一)</div></a> <a href="/wiki/blog/nginx/mini_ngx/4.mini_ngx_实现四-event模块/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">mini_ngx_实现四-event模块</div></a></nav><script type="text/javascript">!function(){var e=window.location.href,r=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var o="//api.share.baidu.com/s.gif";r?(o+="?r="+encodeURIComponent(document.referrer),e&&(o+="&l="+e)):e&&(o+="?l="+e),(new Image).src=o}}(window)</script></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"> brewlin &copy; 2020 <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a><br> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten">wikitten</a><br><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> |<span id="busuanzi_container_site_pv"><i class="fa fa-user"><span id="busuanzi_value_site_uv"></span></i></span></div></div></footer><script src="/libs/lightgallery/js/lightgallery.min.js"></script><script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script><script src="/libs/lightgallery/js/lg-pager.min.js"></script><script src="/libs/lightgallery/js/lg-autoplay.min.js"></script><script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script><script src="/libs/lightgallery/js/lg-zoom.min.js"></script><script src="/libs/lightgallery/js/lg-hash.min.js"></script><script src="/libs/lightgallery/js/lg-share.min.js"></script><script src="/libs/lightgallery/js/lg-video.min.js"></script><script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/main.js"></script></div></body>