<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Brewlin&#39;s Wiki</title>
  
  <subtitle>found everthing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.huido.site/"/>
  <updated>2019-11-10T08:01:21.257Z</updated>
  <id>http://blog.huido.site/</id>
  
  <author>
    <name>brewlin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tcp-客户端</title>
    <link href="http://blog.huido.site/wiki/net-protocol/7.%E5%AE%A2%E6%88%B7%E7%AB%AF/tcp-%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>http://blog.huido.site/wiki/net-protocol/7.客户端/tcp-客户端/</id>
    <published>2019-11-10T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="客户端创建"><a href="#客户端创建" class="headerlink" title="@客户端创建"></a>@客户端创建</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/pkg/logging"</span></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/protocol/transport/tcp/client"</span></span><br><span class="line">_ <span class="string">"github.com/brewlin/net-protocol/stack/stackinit"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">logging.Setup()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//注意不可以 目标IP为 127.0.0.1 导致无法发送 数据包</span></span><br><span class="line">con := client.NewClient(<span class="string">"10.0.2.15"</span>, <span class="number">8080</span>)</span><br><span class="line"><span class="keyword">if</span> err := con.Connect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    con.Write([]<span class="keyword">byte</span>(<span class="string">"send msg"</span>))</span><br><span class="line">    <span class="comment">//阻塞等待读</span></span><br><span class="line">res, _ := con.Read()</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(res))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现了基本的tcp客户端连接读写等函数</li><li>依赖tap虚拟网卡，所以需要启动网卡依赖</li><li>依赖<code>ARP</code>,<code>TCP</code>,<code>IPV4</code>等协议，所以默认注册了该协议</li><li>注意：<code>默认本地地址为192.168.1.0/24 网段，如果目标ip为127.0.0.1 导致无法arp查询物理层地址</code></li></ul><h2 id="NewClient-创建客户端"><a href="#NewClient-创建客户端" class="headerlink" title="@NewClient 创建客户端"></a>@NewClient 创建客户端</h2><p>构造函数传入目的ip,端口等参数，默认返回一个*Client 指针<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con := client.NewClient(<span class="string">"10.0.2.15"</span>, <span class="number">8080</span>)</span><br></pre></td></tr></table></figure></p><p>注意:<code>默认本地地址为192.168.1.0/24 网段，如果目标ip为127.0.0.1 导致无法arp查询物理层地址</code></p><h2 id="Connect-tcp连接握手"><a href="#Connect-tcp连接握手" class="headerlink" title="@Connect tcp连接握手"></a>@Connect tcp连接握手</h2><p>该函数主要处理两个任务</p><ul><li>1.检查tap网卡是否启动，没有则默认初始化启动一个tap网卡拿到<code>fd</code></li><li>2.进行tcp三次握手<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := con.Connect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">       fmt.Println(err)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>连接失败的情况举例:<br>1.<code>err = no remote link address</code></p><ul><li>这种情况一般表示该ip地址的arp查询失败，没有找到对应的mac地址<br>2.<code>err = connection was refused</code></li><li>这个和linux socket 错误码一致 表示 对端未监听该端口,连接拒绝</li></ul><h2 id="Write-写入数据"><a href="#Write-写入数据" class="headerlink" title="@Write 写入数据"></a>@Write 写入数据</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.Write([]<span class="keyword">byte</span>(<span class="string">"send msg"</span>))</span><br></pre></td></tr></table></figure><p>直接向对端连接写入数据，错误返回err</p><h2 id="Read-读取数据"><a href="#Read-读取数据" class="headerlink" title="@Read 读取数据"></a>@Read 读取数据</h2><p>一次只读取一次数据，如果缓存没有读取完，则会返回 <code>ErrWouldBlock</code>错误，可以 在此监听该读方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   //阻塞等待读</span><br><span class="line">res, _ := con.Read()</span><br></pre></td></tr></table></figure></p><h2 id="Readn-读取n字节数据"><a href="#Readn-读取n字节数据" class="headerlink" title="@Readn 读取n字节数据"></a>@Readn 读取n字节数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// var p [8]byte</span><br><span class="line">// res, _ := con.Readn(p[:1])</span><br><span class="line">// fmt.Println(p)</span><br></pre></td></tr></table></figure><p>可以根据传入参数填充对应的字节数数据，如果不够则会阻塞等待数据填充满为止</p><p>golang 的slice底层是一个指针，所以虽然传值，但是实际会复制指针，那么该slice实际值会在Readn（）函数里被改变填充完后返回</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;客户端创建&quot;&gt;&lt;a href=&quot;#客户端创建&quot; class=&quot;headerlink&quot; title=&quot;@客户端创建&quot;&gt;&lt;/a&gt;@客户端创建&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="7.客户端" scheme="http://blog.huido.site/categories/net-protocol/7-%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
      <category term="client" scheme="http://blog.huido.site/tags/client/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.huido.site/wiki/net-protocol/6.%E7%89%A9%E7%90%86%E5%B1%82/tap/"/>
    <id>http://blog.huido.site/wiki/net-protocol/6.物理层/tap/</id>
    <published>2019-11-10T08:01:21.257Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="6.物理层" scheme="http://blog.huido.site/categories/net-protocol/6-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    
    
  </entry>
  
  <entry>
    <title>流量控制-滑动窗口</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/5.%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/tcp/5.流量控制的实现-滑动窗口/</id>
    <published>2019-11-05T12:20:20.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<p>接收端在给发送端回 ACK 中会汇报自己的 AdvertisedWindow，而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。<br>要明确的是滑动窗口分为两个窗口，接收窗口和发送窗口</p><h2 id="接受窗口"><a href="#接受窗口" class="headerlink" title="@接受窗口"></a>@接受窗口</h2><p>接收窗口不仅可以限制发送端发送的速率，还可以提高效率，因为接收窗口的机制，可以允许发送端一次多发送几个片段，而不必等候 ACK，而且可以允许等待一定情况下的乱序， 比如说先缓存提前到的数据，然后去等待需要的数据。</p><p>接收的窗口可以分为四段：</p><ul><li>数据已经被 tcp 确认，但用户程序还未读取数据内容</li><li>中间还有些数据没有到达</li><li>数据已经接收到，但 tcp 未确认</li><li>通告窗口，也就是接收端在给发送端回 ACK 中会汇报自己的窗口大小</li></ul><p>当接收端接收到数据包时，会判断该数据包的序列号是不是在接收窗口內，如果不在窗口內会立即回一个 ack 给发送端， 且丢弃该报文。<br>滑动： 当用户程序读取接收窗口的内容后，窗口向右滑行</p><h2 id="发送窗口"><a href="#发送窗口" class="headerlink" title="@发送窗口"></a>@发送窗口</h2><p>发送窗口的值是由接收窗口和拥塞窗口一起决定的，发送窗口的大小也决定了发送的速率。</p><p>发送窗口的上限值 = Min [rwnd, cwnd]，cwnd 拥塞窗口</p><p>f发送窗口可以分成四段:</p><ul><li>已收到 ack 确认的数据</li><li>已经发送，但还没收到 ack 的数据</li><li>在窗口中还没有发出的（接收方还有空间）</li><li>窗口以外的数据（接收方没空间）<br>滑动： 当发送端收到数据 ack 确认时，窗口向右滑</li></ul><p>如果一个处理缓慢的 Server（接收端）是怎么把 Client（发送端）的TCP Sliding Window给降成 0 的。此时，你一定会问，如果 Window 变成 0 了，TCP 会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿 Window size 可用了，怎么通知发送端呢？</p><p>1.当接收方的应用程序读取了接收缓冲区中的数据以后，接收方会发送一个 ACK，通过通告窗口字段告诉发送方自己又可以接收数据了，发送方收到这个 ACK 之后，就知道自己可以继续发送数据了。</p><p>2.同时发送端使用了Zero Window Probe技术，缩写为 ZWP，当接收方的接收窗口为 0 时，每隔一段时间，发送方会主动发送探测包，迫使对端响应来得知其接收窗口有无打开。</p><p>既然接收端会主动通知发送端，为何还需要发送端定时探测？</p><h2 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="@Silly Window Syndrome"></a>@Silly Window Syndrome</h2><p>Silly Window Syndrome翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走 Receive Windows 里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的 window，而我们的发送方会义无反顾地发送这几个字节。</p><p>要知道，我们的 TCP+IP 头有 40 个字节，为了几个字节，要达上这么大的开销，这太不经济了。</p><p>所以，Silly Windows Syndrome这个现像就像是你本来可以坐 200 人的飞机里只做了一两个人。要解决这个问题也不难，就是避免对小的 window size 做出响应，直到有足够大的 window size 再响应，这个思路可以同时实现在 sender 和 receiver 两端。</p><p>如果这个问题是由 Receiver 端引起的，那么就会使用David D Clark’s方案。在 receiver 端，如果收到的数据导致window size小于某个值，可以直接 ack(0)回 sender，这样就把 window 给关闭了，也阻止了 sender 再发数据过来，等到 receiver 端处理了一些数据后windows size大于等于了 MSS，或者，receiver buffer有一半为空，就可以把 window 打开让 sender 发送数据过来。</p><p>如果这个问题是由 Sender 端引起的，那么就会使用著名的Nagle’s algorithm。这个算法的思路也是延时处理，他有两个主要的条件：</p><p>要等到 Window Size &gt;= MSS 或是 Data Size &gt;= MSS<br>收到之前发送数据的 ack 回包，他才会发数据，否则就是在攒数据</p><h2 id="发送窗口的维护"><a href="#发送窗口的维护" class="headerlink" title="@发送窗口的维护"></a>@发送窗口的维护</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                     +-------&gt; sndWnd &lt;-------+</span><br><span class="line">                     |                          |</span><br><span class="line">---------------------+-------------+----------+--------------------</span><br><span class="line">|      acked         | * * * * * * | # # # # #|   unable send</span><br><span class="line">---------------------+-------------+----------+--------------------</span><br><span class="line">                     ^             ^</span><br><span class="line">                     |               |</span><br><span class="line">                   sndUna        sndNxt</span><br><span class="line">***** in flight data</span><br><span class="line">##### able send date</span><br></pre></td></tr></table></figure><p>发送窗口主要维护这些变量，sndBufSize、sndBufUsed、sndUna、sndNxt 和 sndWnd。sndUna 表示是下一个未确认的序列号，sndNxt 是要发送的下一个段的序列号，sndWnd 是接受端通告的窗口大小。 首先是处理接收方的窗口通告，当收到报文时，一定会带接收窗口和确认号，此时先更新发送器的发送窗口大小为接收窗口大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write writes data to the endpoint's peer.</span></span><br><span class="line"><span class="comment">// 接收上层的数，通过tcp连接发送到对端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">Write</span><span class="params">(p tcpip.Payload, opts tcpip.WriteOptions)</span> <span class="params">(<span class="keyword">uintptr</span>, &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, *tcpip.Error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Linux completely ignores any address passed to sendto(2) for TCP sockets</span></span><br><span class="line">    <span class="comment">// (without the MSG_FASTOPEN flag). Corking is unimplemented, so opts.More</span></span><br><span class="line">    <span class="comment">// and opts.EndOfRecord are also ignored.</span></span><br><span class="line"></span><br><span class="line">    e.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> e.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The endpoint cannot be written to if it's not connected.</span></span><br><span class="line">    <span class="comment">// 判断tcp状态，必须已经建立了连接才能发送数据</span></span><br><span class="line">    <span class="keyword">if</span> e.state != stateConnected &#123;</span><br><span class="line">        <span class="keyword">switch</span> e.state &#123;</span><br><span class="line">        <span class="keyword">case</span> stateError:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, e.hardError</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, tcpip.ErrClosedForSend</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Nothing to do if the buffer is empty.</span></span><br><span class="line">    <span class="comment">// 检查负载的长度，如果为0，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> p.Size() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e.sndBufMu.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the connection has already been closed for sends.</span></span><br><span class="line">    <span class="keyword">if</span> e.sndClosed &#123;</span><br><span class="line">        e.sndBufMu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, tcpip.ErrClosedForSend</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against the limit.</span></span><br><span class="line">    <span class="comment">// tcp流量控制：未被占用发送缓存还剩多少，如果发送缓存已经被用光了，返回 ErrWouldBlock</span></span><br><span class="line">    avail := e.sndBufSize - e.sndBufUsed</span><br><span class="line">    <span class="keyword">if</span> avail &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        e.sndBufMu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, tcpip.ErrWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v, perr := p.Get(avail)</span><br><span class="line">    <span class="keyword">if</span> perr != <span class="literal">nil</span> &#123;</span><br><span class="line">        e.sndBufMu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, perr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> err *tcpip.Error</span><br><span class="line">    <span class="keyword">if</span> p.Size() &gt; avail &#123;</span><br><span class="line">        err = tcpip.ErrWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line">    l := <span class="built_in">len</span>(v)</span><br><span class="line">    s := newSegmentFromView(&amp;e.route, e.id, v)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add data to the send queue.</span></span><br><span class="line">    <span class="comment">// 插入发送队列</span></span><br><span class="line">    e.sndBufUsed += l</span><br><span class="line">    e.sndBufInQueue += seqnum.Size(l)</span><br><span class="line">    e.sndQueue.PushBack(s)</span><br><span class="line"></span><br><span class="line">    e.sndBufMu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据，最终会调用 sender sendData 来发送数据。</span></span><br><span class="line">    <span class="keyword">if</span> e.workMu.TryLock() &#123;</span><br><span class="line">        <span class="comment">// Do the work inline.</span></span><br><span class="line">        e.handleWrite()</span><br><span class="line">        e.workMu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Let the protocol goroutine do the work.</span></span><br><span class="line">        e.sndWaker.Assert()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">uintptr</span>(l), <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到tcp段时调用 handleRcvdSegment; 它负责更新与发送相关的状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sender)</span> <span class="title">handleRcvdSegment</span><span class="params">(seg *segment)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放当前窗口大小。</span></span><br><span class="line">    s.sndWnd = seg.window</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取确认号</span></span><br><span class="line">    ack := seg.ackNumber</span><br><span class="line">    <span class="comment">// 如果ack在最小未确认的seq和下一seg的seq之间</span></span><br><span class="line">    <span class="keyword">if</span> (ack - <span class="number">1</span>).InRange(s.sndUna, s.sndNxt) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Remove all acknowledged data from the write list.</span></span><br><span class="line">        acked := s.sndUna.Size(ack)</span><br><span class="line">        s.sndUna = ack</span><br><span class="line"></span><br><span class="line">        ackLeft := acked</span><br><span class="line">        originalOutstanding := s.outstanding</span><br><span class="line">        <span class="keyword">for</span> ackLeft &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// We use logicalLen here because we can have FIN</span></span><br><span class="line">            <span class="comment">// segments (which are always at the end of list) that</span></span><br><span class="line">            <span class="comment">// have no data, but do consume a sequence number.</span></span><br><span class="line">            seg := s.writeList.Front()</span><br><span class="line">            datalen := seg.logicalLen()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> datalen &gt; ackLeft &#123;</span><br><span class="line">                seg.data.TrimFront(<span class="keyword">int</span>(ackLeft))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> s.writeNext == seg &#123;</span><br><span class="line">                s.writeNext = seg.Next()</span><br><span class="line">            &#125;</span><br><span class="line">            s.writeList.Remove(seg)</span><br><span class="line">            s.outstanding--</span><br><span class="line">            seg.decRef()</span><br><span class="line">            ackLeft -= datalen</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the send buffer usage and notify potential waiters.</span></span><br><span class="line">        s.ep.updateSndBufferUsage(<span class="keyword">int</span>(acked))</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接受窗口的维护"><a href="#接受窗口的维护" class="headerlink" title="@接受窗口的维护"></a>@接受窗口的维护</h2><p>接收窗口主要维护这几个变量，rcvBufSize、rcvBufUsed、rcvNxt 和 rcvAcc，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tcp流量控制：计算未被占用的接收缓存大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">receiveBufferAvailable</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    e.rcvListMu.Lock()</span><br><span class="line">    size := e.rcvBufSize</span><br><span class="line">    used := e.rcvBufUsed</span><br><span class="line">    e.rcvListMu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We may use more bytes than the buffer size when the receive buffer</span></span><br><span class="line">    <span class="comment">// shrinks.</span></span><br><span class="line">    <span class="keyword">if</span> used &gt;= size &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size - used</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">receiveBufferSize</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    e.rcvListMu.Lock()</span><br><span class="line">    size := e.rcvBufSize</span><br><span class="line">    e.rcvListMu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zeroReceiveWindow 根据可用缓冲区的数量和接收窗口缩放，检查现在要宣布的接收窗口是否为零。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">zeroReceiveWindow</span><span class="params">(scale <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e.rcvBufUsed &gt;= e.rcvBufSize &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((e.rcvBufSize - e.rcvBufUsed) &gt;&gt; scale) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tcp流量控制：判断 segSeq 在窗口內</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *receiver)</span> <span class="title">acceptable</span><span class="params">(segSeq seqnum.Value, segLen seqnum.Size)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    rcvWnd := r.rcvNxt.Size(r.rcvAcc)</span><br><span class="line">    <span class="keyword">if</span> rcvWnd == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> segLen == <span class="number">0</span> &amp;&amp; segSeq == r.rcvNxt</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> segSeq.InWindow(r.rcvNxt, rcvWnd) ||</span><br><span class="line">        seqnum.Overlap(r.rcvNxt, rcvWnd, segSeq, segLen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tcp流量控制：当接收窗口从零增长到非零时，调用 nonZeroWindow;在这种情况下，</span></span><br><span class="line"><span class="comment">// 我们可能需要发送一个 ack，以便向对端表明它可以恢复发送数据。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *receiver)</span> <span class="title">nonZeroWindow</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (r.rcvAcc-r.rcvNxt)&gt;&gt;r.rcvWndScale != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// We never got around to announcing a zero window size, so we</span></span><br><span class="line">        <span class="comment">// don't need to immediately announce a nonzero one.</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Immediately send an ack.</span></span><br><span class="line">    r.ep.snd.sendAck()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从tcp的接收队列中读取数据，并从接收队列中删除已读数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">readLocked</span><span class="params">()</span> <span class="params">(buffer.View, *tcpip.Error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e.rcvBufUsed == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.rcvClosed || e.state != stateConnected &#123;</span><br><span class="line">            <span class="keyword">return</span> buffer.View&#123;&#125;, tcpip.ErrClosedForReceive</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.View&#123;&#125;, tcpip.ErrWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s := e.rcvList.Front()</span><br><span class="line">    views := s.data.Views()</span><br><span class="line">    v := views[s.viewToDeliver]</span><br><span class="line">    s.viewToDeliver++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s.viewToDeliver &gt;= <span class="built_in">len</span>(views) &#123;</span><br><span class="line">        e.rcvList.Remove(s)</span><br><span class="line">        s.decRef()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scale := e.rcv.rcvWndScale</span><br><span class="line">    <span class="comment">// tcp流量控制：检测接收窗口是否为0</span></span><br><span class="line">    wasZero := e.zeroReceiveWindow(scale)</span><br><span class="line">    e.rcvBufUsed -= <span class="built_in">len</span>(v)</span><br><span class="line">    <span class="comment">// 检测糊涂窗口，主动发送窗口不为0的通告给对方</span></span><br><span class="line">    <span class="keyword">if</span> wasZero &amp;&amp; !e.zeroReceiveWindow(scale) &#123;</span><br><span class="line">        e.notifyProtocolGoroutine(notifyNonZeroReceiveWindow)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接收端在给发送端回 ACK 中会汇报自己的 AdvertisedWindow，而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。&lt;br&gt;要明确的是滑动窗口分为两个窗口，接收窗口和发送窗口&lt;/p&gt;
&lt;h2 id=&quot;接受窗口&quot;&gt;&lt;a href=&quot;#接受窗口&quot; c
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>连接状态</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/4.%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/tcp/4.连接状态/</id>
    <published>2019-11-04T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fin-wait1-状态"><a href="#fin-wait1-状态" class="headerlink" title="@fin_wait1 状态"></a>@fin_wait1 状态</h2><p>四次挥手中，主动关闭方发送fin报文后，进入find_wait1状态</p><h2 id="close-wait"><a href="#close-wait" class="headerlink" title="@close_wait"></a>@close_wait</h2><p>四次挥手中，表示接受到对方fin报文，并发送对方ack回复，从此进入close_wait状态，等待发送对方fin报文</p><p>这中状态在开发中容易遇见，而且是灾难性的，因为这种状态会在网络中持续<code>2*MSL（Max Segment Lifetime，最大分段生存期，指一个 TCP 报文在 Internet 上的最长生存时间。每个具体的 TCP 协议实现都必须选择一个确定的 MSL 值，RFC 1122 建议是 2 分钟，但 BSD 传统实现采用了 30 秒，Linux 可以 cat /proc/sys/net/ipv4/tcp_fin_timeout 看到本机的这个值）</code>导致系统资源不会被释放</p><p>一般是由于服务端发生异常，导致未向客户端回复fin报文关闭连接进入time_wait状态</p><h2 id="fin-wait2-状态"><a href="#fin-wait2-状态" class="headerlink" title="@fin_wait2 状态"></a>@fin_wait2 状态</h2><p>四次挥手中，表示发送对方fin报文，并接收到对方ack回复，进入到fin_wait2状态</p><h2 id="time-wait-状态"><a href="#time-wait-状态" class="headerlink" title="@time_wait 状态"></a>@time_wait 状态</h2><p>四次挥手中，表示发送对方fin报文，并且受到ack报文和fin报文后进入time_wait状态</p><h2 id="last-ack-状态"><a href="#last-ack-状态" class="headerlink" title="@last_ack 状态"></a>@last_ack 状态</h2><p>刚好和close_wait相反，四次挥手中，最后一次报文迟迟没有回复，客户端没有回复服务端ack确认</p><p>LAST_ACK 当被动关闭的一方在发送 FIN 报文后，等待对方的 ACK 报文的时候，就处于 LAST_ACK 状态。当收到对方的 ACK 报文后，也就可以进入到 CLOSED 可用状态了。</p><h2 id="closing-状态"><a href="#closing-状态" class="headerlink" title="@closing 状态"></a>@closing 状态</h2><p>在四次挥手中，一般不会出现closing状态，因为主动关闭方发送Fin报文后，一般会先收到ack报文，随后在收到fin报文则进入time_wait状态</p><p>但是如果双方同时发送fin报文断开连接的话，就会出现fin报文先到，而ack报文在后面，也就是导致fin_wait2的状态直接进入closing状态</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;fin-wait1-状态&quot;&gt;&lt;a href=&quot;#fin-wait1-状态&quot; class=&quot;headerlink&quot; title=&quot;@fin_wait1 状态&quot;&gt;&lt;/a&gt;@fin_wait1 状态&lt;/h2&gt;&lt;p&gt;四次挥手中，主动关闭方发送fin报文后，进入find_w
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>校验和计算</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/udp/2.%E6%A3%80%E9%AA%8C%E5%92%8C%E8%AE%A1%E7%AE%97/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/udp/2.检验和计算/</id>
    <published>2019-11-02T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<p>UDP 计算校验和的方法和 IP 数据报首部校验和的方法相似。不同的是：IP 数据报校验和只校验 IP 数据报的首部，但 UDP 的校验和是把首部和数据部分一起都检验。</p><p>UDP 的校验和需要计算 UDP 首部加数据荷载部分，但也需要加上 UDP 伪首部。这个伪首部指，源地址、目的地址、UDP 数据长度、协议类型（0x11），协议类型就一个字节，但需要补一个字节的 0x0，构成 12 个字节。伪首部+UDP 首部+数据一起计算校验和。</p><p>UDP 检验和的计算方法是：<br>按每 16 位求和得出一个 32 位的数；<br>如果这个 32 位的数，高 16 位不为 0，则高 16 位加低 16 位再得到一个 32 位的数；<br>重复第 2 步直到高 16 位为 0，将低 16 位取反，得到校验和。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UDP 计算校验和的方法和 IP 数据报首部校验和的方法相似。不同的是：IP 数据报校验和只校验 IP 数据报的首部，但 UDP 的校验和是把首部和数据部分一起都检验。&lt;/p&gt;
&lt;p&gt;UDP 的校验和需要计算 UDP 首部加数据荷载部分，但也需要加上 UDP 伪首部。这个伪
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="udp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/udp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
      <category term="transport" scheme="http://blog.huido.site/tags/transport/"/>
    
  </entry>
  
  <entry>
    <title>协议分层模型</title>
    <link href="http://blog.huido.site/wiki/net-protocol/1.%E5%89%8D%E8%A8%80/2.%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>http://blog.huido.site/wiki/net-protocol/1.前言/2.协议分层模型/</id>
    <published>2019-11-02T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="协议运作"><a href="#协议运作" class="headerlink" title="协议运作"></a>协议运作</h2><p>其实就是将对应协议之间关联到协议都要先注册。在分流器中统一管理，数据包到达后一层一层解刨在转发到对应到业务层处理</p><ol><li>例如监听tcp服务，需要注册 <code>ipv4</code> <code>arp</code> <code>tcp</code> 等。</li><li>链路层 收到网卡原始数据后，通过分流器定位到ipv4协议，然后将数据包转发到ipv4协议处理</li><li><p>网络层ipv4层接受到数据后，在通过分流器找到传输层协议，将数据发往传输层</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.dispatcher.DeliverTransportPacket(r, p, vv)</span><br></pre></td></tr></table></figure></li><li><p>注册到分流器后，数据包到来，后一层一层转发到传输层tcp处理</p></li></ol><h2 id="分流器"><a href="#分流器" class="headerlink" title="分流器"></a>分流器</h2><p>也就是每个协议层之间当协作转发关系。也就是分发网络协议到对应到协议栈处理<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/ 网络层协议号和传输层协议号的组合，当作分流器的key值</span><br><span class="line"><span class="keyword">type</span> protocolIDs <span class="keyword">struct</span> &#123;</span><br><span class="line">    network   tcpip.NetworkProtocolNumber</span><br><span class="line">    transport tcpip.TransportProtocolNumber</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// transportEndpoints 管理给定协议的所有端点。</span></span><br><span class="line"><span class="keyword">type</span> transportEndpoints <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu        sync.RWMutex</span><br><span class="line">    endpoints <span class="keyword">map</span>[TransportEndpointID]TransportEndpoint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// transportDemuxer 解复用针对传输端点的数据包（即，在它们被网络层解析之后）。</span></span><br><span class="line"><span class="comment">// 它执行两级解复用：首先基于网络层协议和传输协议，然后基于端点ID。</span></span><br><span class="line"><span class="keyword">type</span> transportDemuxer <span class="keyword">struct</span> &#123;</span><br><span class="line">    protocol <span class="keyword">map</span>[protocolIDs]*transportEndpoints</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到分流器是个两级结构，第一级是<code>protocolIDs</code>，它是网络层协议号和传输层协议号的组合。第二级是个传输层 <code>ID-TransportEndpointID</code>，表示传输层端的四元组：源 IP、源端口、目的 IP、目的端口。分流器执行两级解复用，首先基于网络层协议和传输协议，然后基于端点 ID。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;协议运作&quot;&gt;&lt;a href=&quot;#协议运作&quot; class=&quot;headerlink&quot; title=&quot;协议运作&quot;&gt;&lt;/a&gt;协议运作&lt;/h2&gt;&lt;p&gt;其实就是将对应协议之间关联到协议都要先注册。在分流器中统一管理，数据包到达后一层一层解刨在转发到对应到业务层处理&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="1.前言" scheme="http://blog.huido.site/categories/net-protocol/1-%E5%89%8D%E8%A8%80/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
  </entry>
  
  <entry>
    <title>以太网协议</title>
    <link href="http://blog.huido.site/wiki/net-protocol/5.%E9%93%BE%E8%B7%AF%E5%B1%82/1.%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%8D%8F%E8%AE%AE/"/>
    <id>http://blog.huido.site/wiki/net-protocol/5.链路层/1.以太网协议/</id>
    <published>2019-10-31T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以太网头部"><a href="#以太网头部" class="headerlink" title="以太网头部"></a>以太网头部</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0               1               2               3               4               5               6</span><br><span class="line">0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                          DESTINATION      MAC    6字节目的mac地址                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                          ORIGINALSRC      MAC    6字节源 mac地址                                |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|       2 字节 网络层协议类型      |     46 - 1500 字节（ip包头 + 传输层包头 + 应用层数据）              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>目的mac地址:<code>6 字节 物理地址</code></p><p>源 mac地址:<code>6 字节 物理地址</code></p><p>数据包协议类型: <code>为0x8000时为 IPv4 协议包，为0x8060时，后面为 ARP 协议包。</code></p><p>数据包     :网卡输送能力上限 <code>MTU</code>(1500字节),对网络层 ip协议对封装，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;以太网头部&quot;&gt;&lt;a href=&quot;#以太网头部&quot; class=&quot;headerlink&quot; title=&quot;以太网头部&quot;&gt;&lt;/a&gt;以太网头部&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="5.链路层" scheme="http://blog.huido.site/categories/net-protocol/5-%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="eth" scheme="http://blog.huido.site/tags/eth/"/>
    
  </entry>
  
  <entry>
    <title>业务说明</title>
    <link href="http://blog.huido.site/wiki/swoft-im/%E5%89%8D%E8%A8%80/%E4%B8%9A%E5%8A%A1%E8%AF%B4%E6%98%8E/"/>
    <id>http://blog.huido.site/wiki/swoft-im/前言/业务说明/</id>
    <published>2019-10-30T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;流程&quot;&gt;&lt;a href=&quot;#流程&quot; class=&quot;headerlink&quot; title=&quot;流程&quot;&gt;&lt;/a&gt;流程&lt;/h2&gt;&lt;h2 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; title=&quot;架构&quot;&gt;&lt;/a&gt;架构&lt;/h2&gt;
      
    
    </summary>
    
      <category term="swoft-im" scheme="http://blog.huido.site/categories/swoft-im/"/>
    
      <category term="前言" scheme="http://blog.huido.site/categories/swoft-im/%E5%89%8D%E8%A8%80/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
  </entry>
  
  <entry>
    <title>微服务应用</title>
    <link href="http://blog.huido.site/wiki/swoft-im/index/"/>
    <id>http://blog.huido.site/wiki/swoft-im/index/</id>
    <published>2019-10-28T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Swoft-cloud微服务架构-Im通讯平台"><a href="#基于Swoft-cloud微服务架构-Im通讯平台" class="headerlink" title="基于Swoft-cloud微服务架构-Im通讯平台"></a>基于Swoft-cloud微服务架构-Im通讯平台</h1><h2 id="概述"><a href="#概述" class="headerlink" title="@概述"></a>@概述</h2><ul><li>对swoole-im进行服务拆分，进行微服务架构(<a href="https://www.github.com/brewlin/swoole-im.git">https://www.github.com/brewlin/swoole-im.git</a>)</li><li>基于Swoft-cloud 进行服务化治理服务治理、熔断器、服务降级、Rpc调用、服务网关、<br>Cosul服务注册与发现、Mysql连接池、Redis连接池、异步任务、websocket推送</li><li>底层采用Swoole通讯引擎,多进程、异步任务，开发模式：Aop，依赖注入，Bean容器，全注解</li><li>服务间配置独立，使用composer进行依赖管理，进行composer组件化开发，公用的Rpc接口封<br>装为独立composer包。<ul><li>拆分有群组Rpc服务，聊天日志Rpc服务，用户基础Rpc服务，消息处理服务</li><li>Httpserver网关api服务，websocket服务</li></ul></li><li>请使用swoole扩展2.1.3+ 以及<code>php 7.1</code>!</li><li>快速开始<ul><li>针对每个服务使用composer更新依赖<code>make install</code></li><li>开启所有服务 <code>make start</code></li><li>关闭所有服务 <code>make stop</code></li></ul></li><li>docker启动<ul><li><code>docker-compose up</code></li></ul></li><li>演示地址 <ul><li><a href="http://chat.huido.site">http://chat.huido.site</a>  (可以注册) </li><li><a href="http://cloud.huido.site">http://cloud.huido.site</a> (soon..)</li></ul></li></ul><h2 id="gateway-api-cloud-soon"><a href="#gateway-api-cloud-soon" class="headerlink" title="@gateway-api-cloud (soon)"></a>@gateway-api-cloud (<code>soon</code>)</h2><ul><li>新增im-cloud版本，接入<a href="https://github.com/brewlin/im-cloud"><code>im-cloud</code></a>分布式推送中间件作为推送中心。</li><li>新网关中心可替代原有的网关服务，接入im-cloud分布式推送服务</li><li><code>im-cloud</code> 基于swoole原生开发的分布式中间件</li><li>done soon..</li></ul><h2 id="架构图"><a href="#架构图" class="headerlink" title="@架构图"></a>@架构图</h2><h3 id="服务依赖"><a href="#服务依赖" class="headerlink" title="服务依赖"></a>服务依赖</h3><p><img src="./resource/services.png" alt=""></p><h3 id="前端服务"><a href="#前端服务" class="headerlink" title="前端服务"></a>前端服务</h3><p><img src="./resource/api.png" alt=""></p><h3 id="服务处理"><a href="#服务处理" class="headerlink" title="服务处理"></a>服务处理</h3><p><img src="./resource/swoole.png" alt=""></p><h1 id="服务开发"><a href="#服务开发" class="headerlink" title="服务开发"></a>服务开发</h1><h3 id="Rpc-接口依赖"><a href="#Rpc-接口依赖" class="headerlink" title="Rpc 接口依赖"></a>Rpc 接口依赖</h3><pre><code>&quot;repositories&quot;: {    &quot;0&quot;:{        &quot;type&quot;:&quot;vcs&quot;,//git源        &quot;url&quot;:&quot;http://www.github.com/brewlin/service-components&quot; //公用composer包    },    &quot;packagist&quot;: {        &quot;type&quot;: &quot;composer&quot;,        &quot;url&quot;: &quot;https://packagist.laravel-china.org&quot;    }}</code></pre><h3 id="Gateway-Api-amp-amp-Websocket-中心网关服务"><a href="#Gateway-Api-amp-amp-Websocket-中心网关服务" class="headerlink" title="Gateway-Api &amp;&amp; Websocket 中心网关服务"></a>Gateway-Api &amp;&amp; Websocket 中心网关服务</h3><pre><code>接受web端webocket长连接通讯、api请求.处理基础数据，对外中心api网关.服务调用方(Rpc 调用),调用群组服务、用户基础服务等`</code></pre><ul><li>依赖: <code>user-service</code>、<code>group-service</code>、<code>services-components</code>、<code>redis-service</code>、<code>group-service</code>、<code>msg-service</code></li><li>配置: <code>worker</code>:2，<code>task_worker</code>:2,<code>port</code>:8090,<code>熔断器</code>，<code>服务降级</code>,Rpc<code>连接池</code>，<code>useProvider</code>:false,</li><li><p>服务启动：</p><p>  <code>cd gateway-api/</code> </p><p>  <code>composer install</code>更新依赖</p><p>  <code>php bin/swoft ws:start</code> –d可选守护进程模式</p></li></ul><h3 id="Redis-缓存处理服务"><a href="#Redis-缓存处理服务" class="headerlink" title="Redis 缓存处理服务"></a>Redis 缓存处理服务</h3><pre><code>处理用用户的业务缓存，使用swoft redis连接池独立服务处理用户群组缓存、好友聊天缓存</code></pre><ul><li>依赖:<code>services-compoents</code>、<code>swoft-cloud*</code></li><li><p>服务启动：</p><p>  <code>cd/redis-service</code> </p><p>  <code>composer install</code>更新依赖</p><p>  <code>php bin/swoft rpc:start</code> –d可选守护进程模式<br>配置: <code>worker</code>:2，<code>task_worker</code>:2,<code>port</code>:8091,SyncRedis<code>连接池</code>，<code>useProvider</code>:false,</p></li></ul><h3 id="Group-群组数据处理服务"><a href="#Group-群组数据处理服务" class="headerlink" title="Group 群组数据处理服务"></a>Group 群组数据处理服务</h3><pre><code>处理用群组基础信息，群组聊天等业务处理</code></pre><ul><li>依赖:<code>services-compoents</code>、<code>swoft-cloud*</code>、<code>redis-service</code></li><li><p>服务启动：</p><p>  <code>cd/group-service</code> </p><p>  <code>composer install</code>更新依赖</p><p>  <code>php bin/swoft rpc:start</code> –d可选守护进程模式<br>配置: <code>worker</code>:2，<code>task_worker</code>:2,<code>port</code>:8092,SyncRedis<code>连接池</code>，<code>useProvider</code>:false,mysql<code>连接池</code></p></li></ul><h3 id="Msg-消息处理服务"><a href="#Msg-消息处理服务" class="headerlink" title="Msg 消息处理服务"></a>Msg 消息处理服务</h3><pre><code>处理系统消息，收发请求消息存储</code></pre><ul><li>依赖:<code>services-compoents</code>、<code>swoft-cloud*</code></li><li><p>服务启动：</p><p>  <code>cd ./msg-service</code> </p><p>  <code>composer install</code>更新依赖</p><p>  <code>php bin/swoft rpc:start</code> –d可选守护进程模式<br>配置: <code>worker</code>:2，<code>task_worker</code>:2,<code>port</code>:8093,<code>useProvider</code>:false,mysql<code>连接池</code></p></li></ul><h3 id="User-用户中心服务"><a href="#User-用户中心服务" class="headerlink" title="User 用户中心服务"></a>User 用户中心服务</h3><pre><code>用户基础信息处理用户好友聊天处理用户业务功能封装</code></pre><ul><li>依赖:<code>services-compoents</code>、<code>swoft-cloud*</code>、<code>redis-service</code>,<code>msg-service</code>,<code>group-service</code></li><li><p>服务启动：</p><p>  <code>cd ./user-service</code> </p><p>  <code>composer install</code>更新依赖</p><p>  <code>php bin/swoft rpc:start</code> –d可选守护进程模式<br>配置: <code>worker</code>:2，<code>task_worker</code>:2,<code>port</code>:8094,<code>useProvider</code>:false,mysql<code>连接池</code></p><h3 id="启动和服务进程预览"><a href="#启动和服务进程预览" class="headerlink" title="启动和服务进程预览"></a>启动和服务进程预览</h3><p><img src="./resource/start.png" alt=""><br><img src="./resource/process.png" alt=""></p><h1 id="开发进度-amp-amp-实现功能"><a href="#开发进度-amp-amp-实现功能" class="headerlink" title="开发进度 &amp;&amp; 实现功能"></a>开发进度 &amp;&amp; 实现功能</h1></li><li>好友单聊</li><li>添加好友</li><li>websocket token 机制</li><li>好友右键菜单操作功能<ul><li>发送好友信息</li><li>查看好友资料</li><li>查看好友聊天记录</li><li>好友备注功能</li><li>移动好友分组</li><li>删除好友功能</li></ul></li><li>发现中心<ul><li>搜索好友</li><li>推荐好友 添加好友</li><li>创建群</li></ul></li><li>消息中心<ul><li>好友离线上线通知,好友上线离线消息推送</li><li>系统消息推送,好友申请处理操作</li></ul></li></ul><h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><ul><li>消息处理中心，消息盒子<br><img src="https://github.com/Lxido/swoole-im/blob/master/img/QQ%E6%88%AA%E5%9B%BE20190106210353.png?raw=true" alt=""></li><li>发现中心，推荐好友群，搜索好友群，创建群<br><img src="https://github.com/Lxido/swoole-im/blob/master/img/QQ%E6%88%AA%E5%9B%BE20190106210451.png?raw=true" alt=""></li><li>单聊，群聊 聊天界面，聊天记录<br><img src="https://github.com/Lxido/swoole-im/blob/master/img/QQ%E6%88%AA%E5%9B%BE20190106210543.png?raw=true" alt=""></li><li>主面板<br><img src="https://github.com/Lxido/swoole-im/blob/master/img/QQ%E6%88%AA%E5%9B%BE20190106210553.png?raw=true" alt=""></li><li>右键功能（好友管理，分组管理，群管理）<br><img src="https://github.com/Lxido/swoole-im/blob/master/img/QQ%E6%88%AA%E5%9B%BE20190106212344.png?raw=true" alt=""></li><li>整体预览图<br><img src="https://github.com/Lxido/swoole-im/blob/master/img/QQ%E6%88%AA%E5%9B%BE20190106210500.png?raw=true" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于Swoft-cloud微服务架构-Im通讯平台&quot;&gt;&lt;a href=&quot;#基于Swoft-cloud微服务架构-Im通讯平台&quot; class=&quot;headerlink&quot; title=&quot;基于Swoft-cloud微服务架构-Im通讯平台&quot;&gt;&lt;/a&gt;基于Swoft-clo
      
    
    </summary>
    
      <category term="swoft-im" scheme="http://blog.huido.site/categories/swoft-im/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="im" scheme="http://blog.huido.site/tags/im/"/>
    
  </entry>
  
  <entry>
    <title>服务发现</title>
    <link href="http://blog.huido.site/wiki/im-cloud/3.%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    <id>http://blog.huido.site/wiki/im-cloud/3.应用实现/2.服务发现/</id>
    <published>2019-10-28T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注册服务"><a href="#注册服务" class="headerlink" title="@注册服务"></a>@注册服务</h2><p>file:<code>app/Process/Discovery.php</code><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义子进程 执行入口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Process $process</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">(Process $process)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        swoole_set_process_name(sprintf(<span class="string">'php-im-cloud discovery process (%s)'</span>,ROOT));</span><br><span class="line">        $registerStatus = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!$registerStatus)&#123;</span><br><span class="line">            $registerStatus = provider()-&gt;select()-&gt;registerService();</span><br><span class="line">            <span class="keyword">if</span>(!$registerStatus)&#123;</span><br><span class="line">                CLog::error(<span class="string">"consul register false sleep 1 sec to reregiseter"</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $config = config(<span class="string">"discovery"</span>);</span><br><span class="line">        $discovery = $config[<span class="string">"consul"</span>][<span class="string">"discovery"</span>][<span class="string">"name"</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            $services = provider()-&gt;select()-&gt;getServiceList($discovery);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">empty</span>($services))&#123;</span><br><span class="line">                Log::error(<span class="string">"not find any instance node:$discovery"</span>);</span><br><span class="line">                LogicClient::updateService([]);</span><br><span class="line">                <span class="keyword">goto</span> SLEEP;</span><br><span class="line">            &#125;</span><br><span class="line">            LogicClient::updateService($services);</span><br><span class="line">SLEEP:</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>1.注册服务 注册失败后重试</li><li>2.发现服务 进行更新本地服务列表</li></ul><h2 id="更新服务"><a href="#更新服务" class="headerlink" title="@更新服务"></a>@更新服务</h2><p>发现服务到频率越高表示同步到时间约精确，这里会有一个问题，php到array数组是<code>非线程安全</code>更新和读取都在进行，并发是会很大几率出现错误，单纯都加锁反而会降低性能</p><p><code>swoole table</code> 应运而生，底层是原子操作，多进程共享变量，完整的解决来问题</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class LogicClient</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Bean</span>()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> App\Lib</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogicClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * servicelist</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> MemoryTable</span></span><br><span class="line"><span class="comment">     * [</span></span><br><span class="line"><span class="comment">     *   ip =&gt; [addr =&gt; ip]</span></span><br><span class="line"><span class="comment">     *   "127.0.0.1:9500" =&gt; ["Address" =&gt; "127.0.0.1","Port" =&gt; "9500"]</span></span><br><span class="line"><span class="comment">     * ]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $table = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LogicClient constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $memorySize = (int)env(<span class="string">"MEMORY_TABLE"</span>,<span class="number">1000</span>);</span><br><span class="line">        $column = [</span><br><span class="line">            <span class="string">"Address"</span> =&gt; [Type::String,<span class="number">20</span>],</span><br><span class="line">            <span class="string">"Port"</span>    =&gt; [Type::String,<span class="number">10</span>],</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">self</span>::$table = Table::create($memorySize,$column);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个可用的grpc 客户端 和logic 节点进行交互</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed|null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getLogicClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">self</span>::$table-&gt;count() == <span class="number">0</span>)&#123;</span><br><span class="line">            Log::error(<span class="string">"not logic node find"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $node = \bean(RandomBalancer::class)-&gt;select(<span class="keyword">self</span>::$table-&gt;getKeys());</span><br><span class="line">        <span class="keyword">return</span> $node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * automic operation insert|update|del</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">updateService</span><span class="params">(array $server)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//insert if not exist | update if not equal</span></span><br><span class="line">        $serverList = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($server <span class="keyword">as</span> $ser) &#123;</span><br><span class="line">            $addr = $ser[<span class="string">"Address"</span>].<span class="string">":"</span>.$ser[<span class="string">"Port"</span>];</span><br><span class="line">            $serverList[] = $addr;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">self</span>::$table-&gt;exist($addr))</span><br><span class="line">                <span class="keyword">self</span>::$table-&gt;set($addr,$ser);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//del not exist</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">self</span>::$table <span class="keyword">as</span> $k =&gt; $ser) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!in_array($k, $serverList)) &#123;</span><br><span class="line">                <span class="keyword">self</span>::$table-&gt;del($k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>table 内存表的创建使用原生封装的库<code>core/table</code></li><li>需要加上<code>@bean()</code>注解，因为内存表需要在swoole启动之前创建，也就是注解扫描阶段就需要建立</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;注册服务&quot;&gt;&lt;a href=&quot;#注册服务&quot; class=&quot;headerlink&quot; title=&quot;@注册服务&quot;&gt;&lt;/a&gt;@注册服务&lt;/h2&gt;&lt;p&gt;file:&lt;code&gt;app/Process/Discovery.php&lt;/code&gt;&lt;br&gt;&lt;figure class
      
    
    </summary>
    
      <category term="im-cloud" scheme="http://blog.huido.site/categories/im-cloud/"/>
    
      <category term="3.应用实现" scheme="http://blog.huido.site/categories/im-cloud/3-%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="rabbitmq" scheme="http://blog.huido.site/tags/rabbitmq/"/>
    
      <category term="consul" scheme="http://blog.huido.site/tags/consul/"/>
    
  </entry>
  
  <entry>
    <title>连接池实现</title>
    <link href="http://blog.huido.site/wiki/im-cloud/4.%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/1.%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.huido.site/wiki/im-cloud/4.组件实现/1.连接池实现/</id>
    <published>2019-10-28T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>基于swoole channel实现，channel大小默认为10,每次获取连接时判断如果连接池为空，则新建连接，并在结束时放回channel中，放回时注意如果大于channel则销毁该连接，同理如果获取连接时小于5，也需要新建连接。只有 满足<code>pool &gt;=5</code> 才从channel中获取该连接。放回时 满足 <code>pool &lt; 10&amp;</code>。而且需要检查该连接是否断开</p><p><code>pkg/core/src/pool/poolfactory.php</code>:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $option</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">getPool</span><span class="params">(string $name,$option = <span class="string">""</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $channelName = $option.$name;</span><br><span class="line">    <span class="comment">//检查当前进程 全局静态池里 是否存在该连接池</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;pools[$channelName]) || <span class="keyword">$this</span>-&gt;pools[$channelName] === <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;pools[$channelName] = <span class="keyword">new</span> Channel(<span class="keyword">$this</span>-&gt;maxActive);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查连接池里 可用连接是否小于最小连接，如果小于则走新建逻辑，最后在回归池里</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;pools[$channelName]-&gt;length() &lt; <span class="keyword">$this</span>-&gt;minActive)&#123;</span><br><span class="line">        <span class="keyword">return</span> container()-&gt;get($name)-&gt;create($option);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取连接，pop一个连接</span></span><br><span class="line">    $connection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">$this</span>-&gt;pools[$channelName]-&gt;isEmpty())&#123;</span><br><span class="line">        $connection = <span class="keyword">$this</span>-&gt;pools[$channelName]-&gt;pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接返回</span></span><br><span class="line">    <span class="keyword">if</span>($connection !== <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> $connection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//channel is empty or not reach maxActive return new create</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;pools[$channelName]-&gt;length() &lt; <span class="keyword">$this</span>-&gt;maxActive)&#123;</span><br><span class="line">        <span class="keyword">return</span> container()-&gt;get($name)-&gt;create($option);</span><br><span class="line">    &#125;</span><br><span class="line">    $connection = <span class="keyword">$this</span>-&gt;pools[$channelName]-&gt;pop(<span class="keyword">$this</span>-&gt;maxWaitTime);</span><br><span class="line">    <span class="keyword">if</span>($connection === <span class="keyword">false</span>)&#123;</span><br><span class="line">        CLog::error(<span class="string">"channel pop timeout name:$name"</span>);</span><br><span class="line">        <span class="keyword">return</span> container()-&gt;get($name)-&gt;create($option);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h2 id=&quot;实现机制&quot;&gt;&lt;a href=&quot;#实现机制&quot; class=&quot;headerlink&quot; title=&quot;实现机制&quot;&gt;&lt;/a&gt;实现机制&lt;/h
      
    
    </summary>
    
      <category term="im-cloud" scheme="http://blog.huido.site/categories/im-cloud/"/>
    
      <category term="4.组件实现" scheme="http://blog.huido.site/categories/im-cloud/4-%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="rabbitmq" scheme="http://blog.huido.site/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>推送实现</title>
    <link href="http://blog.huido.site/wiki/im-cloud/3.%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0/1.%E6%8E%A8%E9%80%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.huido.site/wiki/im-cloud/3.应用实现/1.推送实现/</id>
    <published>2019-10-28T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推送流程"><a href="#推送流程" class="headerlink" title="推送流程"></a>推送流程</h2><p>总的来说logic暴露api接口服务，处理推送http请求，并通过队列的方式让job来消费该任务。最后通过grpc通知cloud节点推送实际的链接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logic -&gt; job -&gt; cloud</span><br></pre></td></tr></table></figure></p><h3 id="logic"><a href="#logic" class="headerlink" title="@logic"></a>@logic</h3><p>file:<code>app/Service/Dao/Queue.php</code></p><p>简短粗暴的直接丢到队列 rabbitmq即可<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * pushMsg</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> int $op</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> string $server</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> array $keys</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> $msg</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> \Throwable</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">pushMsg</span><span class="params">(int $operation,string $server,array $keys, $msg)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     $type = PushMsg\Type::PUSH;</span><br><span class="line">     $pushmsg = compact(<span class="string">"type"</span>,<span class="string">"operation"</span>,<span class="string">"server"</span>,<span class="string">"keys"</span>,<span class="string">"msg"</span>);</span><br><span class="line">     Log::info(<span class="string">"push msg to job node data:"</span>.json_encode($pushmsg));</span><br><span class="line">     <span class="comment">/** <span class="doctag">@var</span> Producer $producers */</span></span><br><span class="line">     $producers = \bean(Producer::class);</span><br><span class="line">     <span class="comment">//发送到队列里</span></span><br><span class="line">     producer()-&gt;produce($producers-&gt;producer($pushmsg));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="job"><a href="#job" class="headerlink" title="@job"></a>@job</h2><p>file:<code>app/Task/pushKey.php</code><br>job节点直接消费数据，去连接池获取链接，直接push到cloud节点<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行grpc 和 cloud 节点通讯</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $operation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $server</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array $subkey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $body</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">(int $operation ,string $server , array $subkey , $body)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $proto = <span class="keyword">new</span> Proto();</span><br><span class="line">    $proto-&gt;setOp($operation);</span><br><span class="line">    $proto-&gt;setVer(<span class="number">1</span>);</span><br><span class="line">    $proto-&gt;setBody($body);</span><br><span class="line"></span><br><span class="line">    $pushMsg = <span class="keyword">new</span> PushMsgReq();</span><br><span class="line">    $pushMsg-&gt;setKeys($subkey);</span><br><span class="line">    $pushMsg-&gt;setProto($proto);</span><br><span class="line">    $pushMsg-&gt;setProtoOp($operation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!CloudClient::$table-&gt;exist($server))&#123;</span><br><span class="line">        Log::error(<span class="string">"pushkey not exist grpc client server: $server "</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GrpcCloudClient::PushMsg($server,$pushMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="cloud"><a href="#cloud" class="headerlink" title="@cloud"></a>@cloud</h2><p>file:<code>app/Grpc/Cloud.php</code><br>grpc服务端获取到请求后，去swooletable 内存表拿到对应到链接信息，进行推送<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受 logic节点 job节点grpc请求，单点推送消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">pushMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Log::debug(<span class="string">"cloud node: pushmsg"</span>);</span><br><span class="line">    $pushMsgRpy = Parser::serializeMessage(<span class="keyword">new</span> PushMsgReply());</span><br><span class="line">    <span class="comment">/** <span class="doctag">@var</span> PushMsgReq $pushMsgReq */</span></span><br><span class="line">    $pushMsgReq = Parser::deserializeMessage([PushMsgReq::class,<span class="keyword">null</span>],request()-&gt;getRawBody());</span><br><span class="line">    response()-&gt;withContent($pushMsgRpy)-&gt;end();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">empty</span>($pushMsgReq-&gt;getKeys()) || <span class="keyword">empty</span>($pushMsgReq-&gt;getProto()))&#123;</span><br><span class="line">        Log::error(<span class="string">"cloud grpc pushmsg keys proto is empty raw data:"</span>.json_encode($pushMsgReq));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@var</span> array $keys */</span></span><br><span class="line">    $keys = $pushMsgReq-&gt;getKeys();</span><br><span class="line">    $op = $pushMsgReq-&gt;getProtoOp();</span><br><span class="line">    $body = $pushMsgReq-&gt;getProto()-&gt;getBody();</span><br><span class="line">    <span class="comment">//coroutine do</span></span><br><span class="line">    <span class="keyword">foreach</span> ($keys <span class="keyword">as</span> $key)&#123;</span><br><span class="line">        <span class="comment">/** <span class="doctag">@var</span> Task $task */</span></span><br><span class="line">        \bean(Task::class)-&gt;deliver(Push::class,<span class="string">"push"</span>,[$key,$op,$body]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;推送流程&quot;&gt;&lt;a href=&quot;#推送流程&quot; class=&quot;headerlink&quot; title=&quot;推送流程&quot;&gt;&lt;/a&gt;推送流程&lt;/h2&gt;&lt;p&gt;总的来说logic暴露api接口服务，处理推送http请求，并通过队列的方式让job来消费该任务。最后通过grpc通知clo
      
    
    </summary>
    
      <category term="im-cloud" scheme="http://blog.huido.site/categories/im-cloud/"/>
    
      <category term="3.应用实现" scheme="http://blog.huido.site/categories/im-cloud/3-%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="rabbitmq" scheme="http://blog.huido.site/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>im-cloud</title>
    <link href="http://blog.huido.site/wiki/im-cloud/2.%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1.im-cloud/"/>
    <id>http://blog.huido.site/wiki/im-cloud/2.底层实现/1.im-cloud/</id>
    <published>2019-10-25T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="im-cloud-基于swoole-原生协程构建分布式推送中间件"><a href="#im-cloud-基于swoole-原生协程构建分布式推送中间件" class="headerlink" title="im-cloud 基于swoole 原生协程构建分布式推送中间件"></a>im-cloud 基于swoole 原生协程构建分布式推送中间件</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><blockquote><p>基于<code>swoole</code>原生协程构建商业化即时推送im服务中间件,不进行业务处理，单独作为中间件使用，可弹性扩充节点增加性能处理.不依赖外部框架，核心代码为原生swoole构建的组件</p></blockquote><p>借鉴goim(<code>bilibili出品,生产级百万消息秒级推送</code>)，使用swoole实现基于php的高性能分布式im中间件，提升高并发性能的推送</p><h2 id="二、服务业务节点"><a href="#二、服务业务节点" class="headerlink" title="二、服务业务节点"></a>二、服务业务节点</h2><blockquote><p><code>cloud,job,logic</code> 等节点都可以水平扩容</p><ul><li>例如在消费能力不足时可以启动n个<code>job</code>节点提高并消费能力</li><li>启动多个cloud节点作为client客户端负载均衡，将多个<code>websocket</code>，<code>tcp</code> client分布到多个cloud节点中，提高cloud节点中心处理能力</li><li><code>logic</code> 提供对外restapi 作为主要业务节点</li><li><code>高性能</code> 协程化、水平扩容、分布式服务架构、接入服务治理</li></ul></blockquote><h3 id="cloud"><a href="#cloud" class="headerlink" title="@cloud"></a>@cloud</h3><p><a href="./app/cloud"><code>cloud</code></a> 作为中心服务节点 <code>grpc-server</code> 节点，对外接收TCP、Websocket客户端进行<code>长连接</code>,可以水平扩容至多个节点 并注册到服务中心，例如<code>consul</code>。每个cloud节点维护自己的客户端</p><h3 id="job"><a href="#job" class="headerlink" title="@job"></a>@job</h3><p><a href="./app/-job"><code>job</code></a> 节点作为消费节点 消费队列数据 然后进行<code>grpc</code> 和cloud服务进行通讯 进行 <code>push</code> <code>push room</code> <code>broadcast</code>,作为节点中间件，消费<code>kafaka</code>，<code>rockermq。。。</code>之类，可以扩展多个节点提高并发消费能力</p><h3 id="logic"><a href="#logic" class="headerlink" title="@logic"></a>@logic</h3><p><a href="./app/logic"><code>logic</code></a> 节点 提供rest api接口，作为生产节点 和  grpc客户端,可写入队列作为生产者，也可以扩展自己的业务进行grpc直接调用cloud节点中心进行推送</p><h2 id="三、组件依赖包-package"><a href="#三、组件依赖包-package" class="headerlink" title="三、组件依赖包 package"></a>三、组件依赖包 <code>package</code></h2><blockquote><p>服务间配置独立，使用composer进行依赖管理，进行composer组件化开发</p><ul><li><a href="./package/im-core"><code>im-core</code></a> 为核心基础组件，底层设计借鉴 <code>swoft</code>源码设计</li><li><a href="./package/im-grpc"><code>im-grpc</code></a> 定义grpc接口规范composer包,使用<code>protobuf</code>构建,封装有连接池</li><li><a href="./package/im-discovery"><code>im-discovery</code></a> 服务发现注册组件，注册<code>grpc-server</code>，发现服务等封装</li><li><a href="./package/im-process"><code>im-process</code></a> 进程管理模块，可以注册启动自定义进程，并交由swoole master进程管理声明周期</li><li><a href="./package/im-queue"><code>im-queue</code></a> 消息队列管理模块，提供消息队列接口，底层实现了<code>连接池</code>接口，无需管理连接，根据类型可以切换不同的消息队列(<code>done rabbitmq</code>,soon kafak)</li><li><a href="./package/im-redis"><code>im-redis</code></a> 封装了连接池版本的redis client</li><li><a href="./package/im-task"><code>im-task</code></a> 异步任务组件，封装投递task进程任务的接口，目前仅支持投递<code>worker-&gt;task</code>,不支持自定义进程投递以及投递到自定义进程</li></ul></blockquote><h2 id="四、数据流程"><a href="#四、数据流程" class="headerlink" title="四、数据流程"></a>四、数据流程</h2><h2 id="im-cloud-连接流程图"><a href="#im-cloud-连接流程图" class="headerlink" title="im-cloud 连接流程图"></a>im-cloud 连接流程图</h2><p><img src="/images/im-cloud/im-cloud-connect.png" alt=""></p><h2 id="im-cloud-数据流程图"><a href="#im-cloud-数据流程图" class="headerlink" title="im-cloud 数据流程图"></a>im-cloud 数据流程图</h2><p><img src="/images/im-cloud/im-cloud-process.png" alt=""></p><h2 id="im-cloud-业务流程"><a href="#im-cloud-业务流程" class="headerlink" title="im-cloud 业务流程"></a>im-cloud 业务流程</h2><p><img src="/images/im-cloud/im-cloudt-task.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;im-cloud-基于swoole-原生协程构建分布式推送中间件&quot;&gt;&lt;a href=&quot;#im-cloud-基于swoole-原生协程构建分布式推送中间件&quot; class=&quot;headerlink&quot; title=&quot;im-cloud 基于swoole 原生协程构建分布式推
      
    
    </summary>
    
      <category term="im-cloud" scheme="http://blog.huido.site/categories/im-cloud/"/>
    
      <category term="2.底层实现" scheme="http://blog.huido.site/categories/im-cloud/2-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="rabbitmq" scheme="http://blog.huido.site/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>icmp协议</title>
    <link href="http://blog.huido.site/wiki/net-protocol/4.%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%8D%8F%E8%AE%AE_icmp/"/>
    <id>http://blog.huido.site/wiki/net-protocol/4.网络层/协议_icmp/</id>
    <published>2019-10-24T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h1><p>ICMP 的全称是 Internet Control Message Protocol 。与 IP 协议一样同属 TCP/IP 模型中的网络层，并且 ICMP 数据包是包裹在 IP 数据包中的。他的作用是报告一些网络传输过程中的错误与做一些同步工作。ICMP 数据包有许多类型。每一个数据包只有前 4 个字节是相同域的，剩余的字段有不同的数据包类型的不同而不同。ICMP 数据包的格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">https://tools.ietf.org/html/rfc792</span><br><span class="line"></span><br><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |     Code      |          Checksum             |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">|                   不同的Type和Code有不同的内容                    |         </span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>从技术角度来说，ICMP 就是一个“错误侦测与回报机制”， 其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性﹐其功能主要有：</p><ul><li>侦测远端主机是否存在。</li><li>建立及维护路由信息。</li><li>重导数据传送路径（ICMP 重定向）。</li><li>数据流量控制。<br>ICMP 在沟通之中，主要是透过不同的类别(Type)与代码(Code) 让机器来识别不同的连线状况。</li></ul><h2 id="完整类型列表"><a href="#完整类型列表" class="headerlink" title="完整类型列表"></a>完整类型列表</h2><table><thead><tr><th>TYPE</th><th>CODE</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>Echo Reply——回显应答（Ping 应答）</td></tr><tr><td>3</td><td>0</td><td>Network Unreachable——网络不可达</td></tr><tr><td>3</td><td>1</td><td>Host Unreachable——主机不可达</td></tr><tr><td>3</td><td>2</td><td>Protocol Unreachable——协议不可达</td></tr><tr><td>3</td><td>3</td><td>Port Unreachable——端口不可达</td></tr><tr><td>3</td><td>4</td><td>Fragmentation needed but no frag. bit set——需要进行分片但设置不分片标志</td></tr><tr><td>3</td><td>5</td><td>Source routing failed——源站选路失败</td></tr><tr><td>3</td><td>6</td><td>Destination network unknown——目的网络未知</td></tr><tr><td>3</td><td>7</td><td>Destination host unknown——目的主机未知</td></tr><tr><td>3</td><td>8</td><td>Source host isolated (obsolete)——源主机被隔离（作废不用）</td></tr><tr><td>3</td><td>9</td><td>Destination network administratively prohibited——目的网络被强制禁止</td></tr><tr><td>3</td><td>10</td><td>Destination host administratively prohibited——目的主机被强制禁止</td></tr><tr><td>3</td><td>11</td><td>Network unreachable for TOS——由于服务类型 TOS，网络不可达</td></tr><tr><td>3</td><td>12</td><td>Host unreachable for TOS——由于服务类型 TOS，主机不可达</td></tr><tr><td>3</td><td>13</td><td>Communication administratively prohibited by filtering——由于过滤，通信被强制禁止</td></tr><tr><td>3</td><td>14</td><td>Host precedence violation——主机越权</td></tr><tr><td>3</td><td>15</td><td>Precedence cutoff in effect——优先中止生效</td></tr><tr><td>4</td><td>0</td><td>Source quench——源端被关闭（基本流控制）</td></tr><tr><td>5</td><td>0</td><td>Redirect for network——对网络重定向</td></tr><tr><td>5</td><td>1</td><td>Redirect for host——对主机重定向</td></tr><tr><td>5</td><td>2</td><td>Redirect for TOS and network——对服务类型和网络重定向</td></tr><tr><td>5</td><td>3</td><td>Redirect for TOS and host——对服务类型和主机重定向</td></tr><tr><td>8</td><td>0</td><td>Echo request——回显请求（Ping 请求）</td></tr><tr><td>9</td><td>0</td><td>Router advertisement——路由器通告</td></tr><tr><td>10</td><td>0</td><td>Route solicitation——路由器请求</td></tr><tr><td>11</td><td>0</td><td>TTL equals 0 during transit——传输期间生存时间为 0</td></tr><tr><td>11</td><td>1</td><td>TTL equals 0 during reassembly——在数据报组装期间生存时间为 0</td></tr><tr><td>12</td><td>0</td><td>IP header bad (catchall error)——坏的 IP 首部（包括各种差错）</td></tr><tr><td>12</td><td>1</td><td>Required options missing——缺少必需的选项</td></tr><tr><td>13</td><td>0</td><td>Timestamp request (obsolete)——时间戳请求（作废不用）</td></tr><tr><td>14</td><td></td><td>Timestamp reply (obsolete)——时间戳应答（作废不用）</td></tr><tr><td>15</td><td>0</td><td>Information request (obsolete)——信息请求（作废不用）</td></tr><tr><td>16</td><td>0</td><td>Information reply (obsolete)——信息应答（作废不用）</td></tr><tr><td>17</td><td>0</td><td>Address mask request——地址掩码请求</td></tr><tr><td>18</td><td>0</td><td>Address mask</td></tr></tbody></table><p>ICMP 是个非常有用的协议，尤其是当我们要对网路连接状况进行判断的时候。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ICMP-协议&quot;&gt;&lt;a href=&quot;#ICMP-协议&quot; class=&quot;headerlink&quot; title=&quot;ICMP 协议&quot;&gt;&lt;/a&gt;ICMP 协议&lt;/h1&gt;&lt;p&gt;ICMP 的全称是 Internet Control Message Protocol 。与 IP 
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="4.网络层" scheme="http://blog.huido.site/categories/net-protocol/4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>端口机制</title>
    <link href="http://blog.huido.site/wiki/net-protocol/4.%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%8D%8F%E8%AE%AE_%E7%AB%AF%E5%8F%A3/"/>
    <id>http://blog.huido.site/wiki/net-protocol/4.网络层/协议_端口/</id>
    <published>2019-10-24T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><h2 id="端口在tcp协议中的体现"><a href="#端口在tcp协议中的体现" class="headerlink" title="端口在tcp协议中的体现"></a>端口在tcp协议中的体现</h2><p>端口一般在tcp首部前四个字节中，前2字节表示源端口 后两字节表示目标端口<br><img src="5F5BC33465194D9E82C737A5030A7808" alt="image"></p><p>1.周知端口（Well Known Ports）<br>周知端口是众所周知的端口号，范围从 0 到 1023，其中 80 端口分配给 WWW 服务，21 端口分配给 FTP 服务等。我们在 IE 的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下 WWW 服务的端口是”80”。网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在 地址栏上指定端口号，方法是在地址后面加上冒号”:”，再加上端口号。比如使用”8080”作为 WWW 服务的端口，则需要在地址栏里输入”网址:8080”。但是有些系统协议使用固定的端口号，它是不能被改变的，比如 139 端口专门用于 NetBIOS 与 TCP/IP 之间的通信，不能手动改变。</p><p>2.注册端口（Registered Ports）<br>端口 1024 到 49151，分配给用户进程或应用程序。这些进程主要是用户选择安装的一些应用程序，而不是已经分配好了公认端口的常用程序。这些端口在没有被服务器资源占用的时候，可以用用户端动态选用为源端口。</p><p>3.动态端口（Dynamic Ports）<br>动态端口的范围是从 49152 到 65535。之所以称为动态端口，是因为它 一般不固定分配某种服务，而是动态分配。比如本地想和远端建立 TCP 连接，如果没有指定本地源端口，系统就会给你自动分配一个未占用的源端口，这个端口值就是动态的，当你断开再次建立连接的时候，很有可能你的源端口和上次得到的端口不一样。</p><p>一些常见的端口号及其用途如下：</p><ul><li>TCP21 端口：FTP 文件传输服务</li><li>TCP22 端口：SSH 安全外壳协议</li><li>TCP23 端口：TELNET 终端仿真服务</li><li>TCP25 端口：SMTP 简单邮件传输服务</li><li>UDP53 端口：DNS 域名解析服务</li><li>UDP67 端口：DHCP 的服务端端口 UDP68 端口：DHCP 的客户端端口 TCP80 端口：HTTP 超文本传输服务</li><li>TCP110 端 口：POP3“邮局协议版本 3”使用的端口</li><li>TCP443 端口：HTTPS 加密的超文本传输服务</li></ul><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>端口是<code>网络层协议地址+传输层协议号+端口号</code>来区分的，比如：</p><p><code>ipv4的tcp 80</code>端口和<code>ipv4的udp 8</code>0端口不会冲突。</p><p>如果你主机有两个 ip 地址 ip1 和 ip2，那么你同时监听<code>ip1:80</code>和<code>ip2:80</code>不会冲突。</p><p><code>ipv4的tcp 80</code>端口和ipv6的<code>tcp 80</code>端口不会冲突。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;端口&quot;&gt;&lt;a href=&quot;#端口&quot; class=&quot;headerlink&quot; title=&quot;端口&quot;&gt;&lt;/a&gt;端口&lt;/h1&gt;&lt;h2 id=&quot;端口在tcp协议中的体现&quot;&gt;&lt;a href=&quot;#端口在tcp协议中的体现&quot; class=&quot;headerlink&quot; title=&quot;端
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="4.网络层" scheme="http://blog.huido.site/categories/net-protocol/4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>ip协议</title>
    <link href="http://blog.huido.site/wiki/net-protocol/4.%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%8D%8F%E8%AE%AE_ip/"/>
    <id>http://blog.huido.site/wiki/net-protocol/4.网络层/协议_ip/</id>
    <published>2019-10-24T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP-报文协议"><a href="#IP-报文协议" class="headerlink" title="IP 报文协议"></a>IP 报文协议</h1><p>首部协议格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0               1               2               3               4</span><br><span class="line">0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Version|  LHL  | Type of Service |        Total Length         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Identification(fragment Id)    |Flags|  Fragment Offset      |</span><br><span class="line">|           16 bits               |R|D|M|       13 bits         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| Time-To-Live  |   Protocol      |      Header Checksum        |</span><br><span class="line">| ttl(8 bits)   |    8 bits       |          16 bits            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|               Source IP Address (32 bits)                     |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|              Destination Ip Address (32 bits)                 |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options (*** bits)          |  Padding     |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    transport data...                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p><code>版本（Version）:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">版本字段占 4bit，通信双方使用的版本必须一致。对于 IPv4，字段的值是 4。</span><br></pre></td></tr></table></figure><p><code>首部长度（Internet Header Length， IHL）:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">占 4bit，首部长度说明首部有多少 32 位字（4字节）。</span><br><span class="line">由于 IPv4首部可能包含数目不定的选项，这个字段也用来确定数据的偏移量。</span><br><span class="line">这个字段的最小值是 5（二进制 0101），相当于 5*4=20 字节（RFC 791），最大十进制值是 15。</span><br></pre></td></tr></table></figure><p><code>区分服务（Differentiated Services，DS):</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">占 8bit，最初被定义为服务类型字段，实际上并未使用，但 1998 年被 IETF 重定义为区分服务 RFC 2474。</span><br><span class="line">只有在使用区分服务时，这个字段才起作用，在一般的情况 下都不使用这个字段。例如需要实时数据流的技术会应用这个字段，一个例子是 VoIP。</span><br></pre></td></tr></table></figure><p><code>显式拥塞通告（ Explicit Congestion Notification，ECN）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 RFC 3168 中定义，允许在不丢弃报文的同时通知对方网络拥塞的发生。</span><br><span class="line">ECN 是一种可选的功能，仅当两端都支持并希望使用，且底层网络支持时才被使用。</span><br></pre></td></tr></table></figure></p><p><code>全长（Total Length）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个 16 位字段定义了报文总长，包含首部和数据，单位为字节。</span><br><span class="line">这个字段的最小值是 20（20 字节首部+0 字节数据），最大值是 216-1=65,535。</span><br><span class="line">IP 规定所有主机都必须支持最小 576 字节的报文，这是假定上层数据长度 512 字节，加上最长 IP 首部 60 字节，加上 4 字节富裕量，</span><br><span class="line">得出 576 字节，但大多数现代主机支持更大的报文。</span><br><span class="line">当下层的数据链路协议的最大传输单元（MTU）字段的值小于 IP 报文长度时间，报文就必须被分片，详细见下个标题。</span><br></pre></td></tr></table></figure></p><p><code>标识符（Identification):</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">占 16 位，这个字段主要被用来唯一地标识一个报文的所有分片，因为分片不一定按序到达，所以在重组时需要知道分片所属的报文。</span><br><span class="line">每产生一个数据报，计数器加 1，并赋值给此字段。一些实验性的工作建议将此字段用于其它目的，例如增加报文跟踪信息以协助探测伪造的源地址。</span><br></pre></td></tr></table></figure></p><p><code>标志 （Flags）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这个 3 位字段用于控制和识别分片，它们是：</span><br><span class="line">位 0：保留，必须为 0； </span><br><span class="line">位 1：禁止分片（Don’t Fragment，DF），当 DF=0 时才允许分片； </span><br><span class="line">位 2：更多分片（More Fragment，MF），MF=1 代表后面还有分片，MF=0 代表已经是最后一个分片。 </span><br><span class="line">如果 DF 标志被设置为 1，但路由要求必须分片报文，此报文会被丢弃。这个标志可被用于发往没有能力组装分片的主机。</span><br><span class="line">当一个报文被分片，除了最后一片外的所有分片都设置 MF 为 1。</span><br><span class="line">最后一个片段具有非零片段偏移字段，将其与未分片数据包区分开，未分片的偏移字段为 0。</span><br></pre></td></tr></table></figure></p><p><code>分片偏移 （Fragment Offset）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个 13 位字段指明了每个分片相对于原始报文开头的偏移量，以 8 字节作单位。</span><br></pre></td></tr></table></figure></p><p><code>存活时间（Time To Live，TTL）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个 8 位字段避免报文在互联网中永远存在（例如陷入路由环路）。</span><br><span class="line">存活时间以秒为单位，但小于一秒的时间均向上取整到一秒。</span><br><span class="line">在现实中，这实际上成了一个跳数计数器：报文经过的每个路由器都将此字段减 1，当此字段等于 0 时，报文不再向下一跳传送并被丢弃，最大值是 255。</span><br><span class="line">常规地，一份 ICMP 报文被发回报文发送端说明其发送的报文已被丢弃。这也是 traceroute 的核心原理。</span><br></pre></td></tr></table></figure></p><p><code>协议 （Protocol）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">占 8bit，这个字段定义了该报文数据区使用的协议。IANA 维护着一份协议列表（最初由 RFC 790 定义），详细参见 IP 协议号列表。</span><br></pre></td></tr></table></figure></p><p><code>首部检验和 （Header Checksum）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个 16 位检验和字段只对首部查错，不包括数据部分。</span><br><span class="line">在每一跳，路由器都要重新计算出的首部检验和并与此字段进行比对，如果不一致，此报文将会被丢弃。</span><br><span class="line">重新计算的必要性是因为每一跳的一些首部字段（如 TTL、Flag、Offset 等）都有可能发生变化，不检查数据部分是为了减少工作量。</span><br><span class="line">数据区的错误留待上层协议处理——用户数据报协议（UDP）和传输控制协议（TCP）都有检验和字段。此处的检验计算方法不使用 CRC。</span><br></pre></td></tr></table></figure></p><p><code>源地址</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个 IPv4 地址由四个字节共 32 位构成，此字段的值是将每个字节转为二进制并拼在一起所得到的 32 位值。</span><br><span class="line">例如，10.9.8.7 是 00001010000010010000100000000111。</span><br><span class="line">但请注意，因为 NAT 的存在，这个地址并不总是报文的真实发送端，因此发往此地址的报文会被送往 NAT 设备，并由它被翻译为真实的地址。</span><br></pre></td></tr></table></figure><p><code>目的地址</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与源地址格式相同，但指出报文的接收端。</span><br></pre></td></tr></table></figure></p><p><code>选项:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">附加的首部字段可能跟在目的地址之后，但这并不被经常使用，从 1 到 40 个字节不等。</span><br><span class="line">请注意首部长度字段必须包括足够的 32 位字来放下所有的选项（包括任何必须的填充以使首部长度能够被 32 位整除）。</span><br><span class="line">当选项列表的结尾不是首部的结尾时，EOL（选项列表结束，0x00）选项被插入列表末尾。下表列出了可能。</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>字段</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td>备份</td><td>1</td><td>当此选项需要被备份到所有分片中时，设为 1。</td></tr><tr><td>类</td><td>2</td><td>常规的选项类别，0 为“控制”，2 为“查错和措施”，1 和 3 保留。</td></tr><tr><td>数字</td><td>5</td><td>指明一个选项。</td></tr><tr><td>长度</td><td>8</td><td>指明整个选项的长度，对于简单的选项此字段可能不存在。</td></tr><tr><td>数据</td><td>可变</td><td>选项相关数据，对于简单的选项此字段可能不存在。</td></tr></tbody></table><blockquote><p>注：如果首部长度大于 5，那么选项字段必然存在并必须被考虑。<br>注：备份、类和数字经常被一并称呼为“类型”。</p></blockquote><ul><li>数据 数据字段不是首部的一部分，因此并不被包含在首部检验和中。数据的格式在协议首部字段中被指明，并可以是任意的传输层协议。 一些常见协议的协议字段值被列在下面</li></ul><table><thead><tr><th>协议字段值</th><th>协议名</th><th>缩写</th></tr></thead><tbody><tr><td>1</td><td>互联网控制消息协议</td><td>ICMP</td></tr><tr><td>2</td><td>互联网组管理协议</td><td>IGMP</td></tr><tr><td>6</td><td>传输控制协议</td><td>TCP</td></tr><tr><td>17</td><td>用户数据报协议</td><td>UDP</td></tr><tr><td>41</td><td>IPv6 封装</td><td>ENCAP</td></tr><tr><td>89</td><td>开放式最短路径优先</td><td>OSPF</td></tr><tr><td>132</td><td>流控制传输协议</td><td>SCTP</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IP 层最重要的目的是让两个主机之间通信，无论他们相隔多远。<br>IP 协议理论上允许的最大 IP 数据报为 <code>65535</code> 字节（16 位来表示包总长）。<br>但是因为协议栈网络层下面的数据链路层一般允许的帧长远远小于这个值，例如以太网的 MTU 通常在 <code>1500</code> 字节左右。<br>所以较大的 IP 数据包会被<code>分片传</code>递给数据链路层发送，分片的 IP 数据报可能会以不同的路径传输到接收主机，接收主机通过一系列的<code>重组</code>，将其还原为一个完整的 IP 数据报，再提交给上层协议处理。<br>IP 分片会带来一定的问题，分片和重组会消耗发送方、接收方一定的 CPU 等资源，如果存在大量的分片报文的话，可能会造成较为严重的资源消耗；分片丢包导致的重传问题；分片攻击；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IP-报文协议&quot;&gt;&lt;a href=&quot;#IP-报文协议&quot; class=&quot;headerlink&quot; title=&quot;IP 报文协议&quot;&gt;&lt;/a&gt;IP 报文协议&lt;/h1&gt;&lt;p&gt;首部协议格式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="4.网络层" scheme="http://blog.huido.site/categories/net-protocol/4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>arp协议</title>
    <link href="http://blog.huido.site/wiki/net-protocol/4.%E7%BD%91%E7%BB%9C%E5%B1%82/arp%E5%8D%8F%E8%AE%AE/"/>
    <id>http://blog.huido.site/wiki/net-protocol/4.网络层/arp协议/</id>
    <published>2019-10-24T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><p>基于arp协议，获取对应的物理mac地址</p><p><img src="/images/arp.png" alt="image"><br>上层tcp/ip协议报文只包含<code>目标服务器的ip地址</code>，而下层链路层以太网协议需要知道目标服务器的<code>mac地址</code>，则arp的协议是指当前主机发送ARP查询（广播）查询该mac地址，如果目标地址不是在同一个局域网，则该mac地址则是局域网外的路由器mac地址，该所有帧都将发往该路由器地址</p><blockquote><p>总之以太网协议中得到的上层数据中只有IP地址，需要使用arp协议去获得mac地址，arp协议会在链路层进行广播，只有目标地址会回应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARP Paclket Format </span><br><span class="line">arp协议数据包格式</span><br><span class="line">6字节(以太网目的地址)  +  6字节（以太网源地址）   + 2 字节（帧类型）  + 28字节（arp请求回应包）</span><br></pre></td></tr></table></figure></p></blockquote><p>28字节包格式</p><ul><li>2字节硬件类型：1 =&gt; 以太网地址</li><li>2字节协议类型：0x800 表示ipv4协议</li><li>1字节地址长度：单位长度，一般为6  表示以太网地址的长度6字节</li><li>1字节协议地址长度：一般为4，ipv4地址长度</li><li>2字节操作码：1 =&gt; arp请求   2 =&gt; arp应答  3 =&gt; rarp请求  4 =&gt; rarp应答</li><li>6字节原mac地址：源mac地址</li><li>4字节源协议地址：源ip地址 如192.168.0.1</li><li>6字节目标mac地址：mac地址</li></ul><blockquote><p>不用担心每次请求都会触发arp查询广播，机器是有arp高速缓存的 <code>arp -a</code></p></blockquote><h3 id="type"><a href="#type" class="headerlink" title="@type"></a>@type</h3><p>type:0x8060 表示arp协议</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ARP-协议&quot;&gt;&lt;a href=&quot;#ARP-协议&quot; class=&quot;headerlink&quot; title=&quot;ARP 协议&quot;&gt;&lt;/a&gt;ARP 协议&lt;/h2&gt;&lt;p&gt;基于arp协议，获取对应的物理mac地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/arp.png&quot;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="4.网络层" scheme="http://blog.huido.site/categories/net-protocol/4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>udp协议</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/udp/1.%E5%8D%8F%E8%AE%AE/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/udp/1.协议/</id>
    <published>2019-10-22T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="udp协议"><a href="#udp协议" class="headerlink" title="udp协议"></a>udp协议</h1><h2 id="udp协议-包体"><a href="#udp协议-包体" class="headerlink" title="udp协议 包体"></a>udp协议 包体</h2><p><img src="C5DAEAF2697B45D6927F108780C6324E" alt="image"></p><ol><li>源端口 源端口号</li><li>目的端口 目的端口号</li><li>长度 UDP 数据报的长度，包含首部，最小为 8</li><li>检验和 UDP 数据报的校验和，如果接收到检验和不正确的情况下，直接丢弃该报文。</li></ol><h2 id="计算校验和算法"><a href="#计算校验和算法" class="headerlink" title="计算校验和算法"></a>计算校验和算法</h2><p>UDP 计算校验和的方法和 IP 数据报首部校验和的方法相似。不同的是：IP 数据报校验和只校验 IP 数据报的首部，但 UDP 的校验和是把首部和数据部分一起都检验。</p><p>UDP 的校验和需要计算 UDP 首部加数据荷载部分，但也需要加上 UDP 伪首部。这个伪首部指，源地址、目的地址、UDP 数据长度、协议类型（0x11），协议类型就一个字节，但需要补一个字节的 0x0，构成 12 个字节。伪首部+UDP 首部+数据一起计算校验和。</p><p>UDP 检验和的计算方法是：<br>按每 16 位求和得出一个 32 位的数；<br>如果这个 32 位的数，高 16 位不为 0，则高 16 位加低 16 位再得到一个 32 位的数；<br>重复第 2 步直到高 16 位为 0，将低 16 位取反，得到校验和。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;udp协议&quot;&gt;&lt;a href=&quot;#udp协议&quot; class=&quot;headerlink&quot; title=&quot;udp协议&quot;&gt;&lt;/a&gt;udp协议&lt;/h1&gt;&lt;h2 id=&quot;udp协议-包体&quot;&gt;&lt;a href=&quot;#udp协议-包体&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="udp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/udp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>tcp流量控制</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/2.%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/tcp/2.流量控制/</id>
    <published>2019-10-22T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcp-流量控制"><a href="#tcp-流量控制" class="headerlink" title="tcp 流量控制"></a>tcp 流量控制</h1><p>tcp是由丢包重传的机制的</p><p>那么如果服务端因为负载导致不能接受发送端的数据从而丢弃数据</p><p>发送端接受到ack确认为丢包后导致重传</p><p>然后服务端导致负载更加严重，从而一个劲的重发数据，对网络造成更大的伤害。于是就提出了拥塞控制，当拥塞发生的时候，要做自我牺牲，降低发送速率。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tcp-流量控制&quot;&gt;&lt;a href=&quot;#tcp-流量控制&quot; class=&quot;headerlink&quot; title=&quot;tcp 流量控制&quot;&gt;&lt;/a&gt;tcp 流量控制&lt;/h1&gt;&lt;p&gt;tcp是由丢包重传的机制的&lt;/p&gt;
&lt;p&gt;那么如果服务端因为负载导致不能接受发送端的数据从而
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>tcp头部</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/1.%E5%A4%B4%E9%83%A8/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/tcp/1.头部/</id>
    <published>2019-10-22T13:28:59.000Z</published>
    <updated>2019-11-10T08:01:21.257Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="传输层-tcp-协议-实现"><a href="#传输层-tcp-协议-实现" class="headerlink" title="传输层 tcp 协议 实现"></a>传输层 tcp 协议 实现</h1><p><img src="43E0E23D5D324B8CA750C4F99EF4E3A7" alt="image"></p><h2 id="首部协议格式"><a href="#首部协议格式" class="headerlink" title="首部协议格式"></a>首部协议格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |           |G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><h3 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h3><p>各占 2 个字节，分别 tcp 连接的源端口和目的端口。关于端口的概念之前已经介绍过了。</p><h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>占 4 字节，序号范围是[0，2^32 - 1]，共 2^32（即 4294967296）个序号。序号增加到 2^32-1 后，下一个序号就又回到 0。TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号（ISN）必须在连接建立时设置。<code>首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号</code>。例如，一报文段的序号是 301，而接待的数据共有 100 字节。这就表明：本报文段的数据的第一个字节的序号是 301，最后一个字节的序号是 400。显然，下一个报文段（如果还有的话）的数据序号应当从 401 开始，即下一个报文段的序号字段值应为 401。</p><h3 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h3><p>占 4 字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B 正确收到了 A 发送过来的一个报文段，其序号字段值是 501，而数据长度是 200 字节（序号 501~700），这表明 B 正确收到了 A 发送的到序号 700 为止的数据。因此，B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701。注意，现在确认号不是 501，也不是 700，而是 701。<br>总之：若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。TCP 除了第一个 SYN 报文之外，所有 TCP 报文都需要携带 ACK 状态位。</p><h3 id="数据偏移"><a href="#数据偏移" class="headerlink" title="数据偏移"></a>数据偏移</h3><p>占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。<code>这个字段实际上是指出 TCP 报文段的首部长度</code>。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是 4 个字节，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节。</p><h3 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h3><p>占 6 位，保留为今后使用，但目前应置为 0。</p><h3 id="控制报文标志"><a href="#控制报文标志" class="headerlink" title="控制报文标志"></a>控制报文标志</h3><h4 id="紧急URG（URGent）"><a href="#紧急URG（URGent）" class="headerlink" title="紧急URG（URGent）"></a>紧急URG（URGent）</h4><p>当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收 TCP 的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。<br>当 URG 置为 1 时，发送应用进程就告诉发送方的 TCP 有紧急数据要传送。于是发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。</p><h4 id="确认ACK（ACKnowledgment）"><a href="#确认ACK（ACKnowledgment）" class="headerlink" title="确认ACK（ACKnowledgment）"></a>确认ACK（ACKnowledgment）</h4><p>仅当 ACK=1 时确认号字段才有效，当 ACK=0 时确认号无效。TCP 规定，在连接建立后所有的传送的报文段都必须把 ACK 置为 1。</p><h4 id="推送-PSH（PuSH）"><a href="#推送-PSH（PuSH）" class="headerlink" title="推送 PSH（PuSH）"></a>推送 PSH（PuSH）</h4><p>当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH=1 的报文段，就尽快地交付接收应用进程。<br>复位RST（ReSeT）<br>当 RST=1 时，表名 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST 置为 1 用来拒绝一个非法的报文段或拒绝打开一个连接。</p><h4 id="同步SYN（SYNchronization）"><a href="#同步SYN（SYNchronization）" class="headerlink" title="同步SYN（SYNchronization）"></a>同步SYN（SYNchronization）</h4><p>在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN=1 和 ACK=1，因此 SYN 置为 1 就表示这是一个连接请求或连接接受报文。</p><h4 id="终止FIN（FINis，意思是“完”“终”）"><a href="#终止FIN（FINis，意思是“完”“终”）" class="headerlink" title="终止FIN（FINis，意思是“完”“终”）"></a>终止FIN（FINis，意思是“完”“终”）</h4><p>用来释放一个连接。当 FIN=1 时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p><h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>占 2 字节，窗口值是[0，2^16-1]之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据，作为流量控制的依据，后面会详细介绍。<br>总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。</p><h3 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h3><p>占 2 字节，检验和字段检验的范围包括首部和数据这两部分。和 UDP 用户数据报一样，在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。伪首部的格式和 UDP 用户数据报的伪首部一样。但应把伪首部第 4 个字段中的 17 改为 6（TCP 的协议号是 6）；把第 5 字段中的 UDP 中的长度改为 TCP 长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用 IPv6，则相应的伪首部也要改变。</p><h3 id="紧急指针"><a href="#紧急指针" class="headerlink" title="紧急指针"></a>紧急指针</h3><p>占 2 字节，紧急指针仅在 URG=1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据) 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为 0 时也可以发送紧急数据。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>选项长度可变，最长可达 40 字节。当没有使用“选项”时，TCP 的首部长度是 20 字节。TCP 首部总长度由 TCP 头中的“数据偏移”字段决定，前面说了，最长偏移为 60 字节。那么“tcp 选项”的长度最大为 60-20=40 字节。</p><h4 id="选项的一般结构体"><a href="#选项的一般结构体" class="headerlink" title="选项的一般结构体"></a>选项的一般结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  1byte    1byte        nbytes</span><br><span class="line">+--------+--------+------------------+ </span><br><span class="line">| Kind   | Length |       Info       |</span><br><span class="line">+--------+--------+------------------+</span><br></pre></td></tr></table></figure><p>TCP 最初只规定了一种选项，即最大报文段长度 MSS（Maximum Segment Szie）。后来又增加了几个选项如窗口扩大选项、时间戳选项等，下面说明常用的选项。</p><p>kind=0 是选项表结束选项。</p><p>kind=1 是空操作（nop）选项<br>没有特殊含义，一般用于将 TCP 选项的总长度填充为 4 字节的整数倍，为啥需要 4 字节整数倍？因为前面讲了数据偏移字段的单位是 4 个字节。</p><p>kind=2 是最大报文段长度选项<br>TCP 连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP 模块通常将 MSS 设置为（MTU-40）字节（减掉的这 40 字节包括 20 字节的 TCP 头部和 20 字节的 IP 头部）。这样携带 TCP 报文段的 IP 数据报的长度就不会超过 MTU（假设 TCP 头部和 IP 头部都不包含选项字段，并且这也是一般情况），从而避免本机发生 IP 分片。对以太网而言，MSS 值是 1460（1500-40）字节。</p><p>kind=3 是窗口扩大因子选项<br>TCP 连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在 TCP 的头部中，接收通告窗口大小是用 16 位表示的，故最大为 65535 字节，但实际上 TCP 模块允许的接收通告窗口大小远不止这个数（为了提高 TCP 通信的吞吐量）。窗口扩大因子解决了这个问题。假设 TCP 头部中的接收通告窗口大小是 N，窗口扩大因子（移位数）是 M，那么 TCP 报文段的实际接收通告窗口大小是 N 乘 2M，或者说 N 左移 M 位。注意，M 的取值范围是 0～14。</p><p>和 MSS 选项一样，窗口扩大因子选项只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该 TCP 报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。关于窗口扩大因子选项的细节，可参考标准文档 RFC 1323。</p><p>kind=4 是选择性确认（Selective Acknowledgment，SACK）选项<br>TCP 通信时，如果某个 TCP 报文段丢失，则 TCP 模块会重传最后被确认的 TCP 报文段后续的所有报文段，这样原先已经正确传输的 TCP 报文段也可能重复发送，从而降低了 TCP 性能。SACK 技术正是为改善这种情况而产生的，它使 TCP 模块只重新发送丢失的 TCP 报文段，不用发送所有未被确认的 TCP 报文段。选择性确认选项用在连接初始化时，表示是否支持 SACK 技术。</p><p>kind=5 是 SACK 实际工作的选项<br>该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿（edge of block）参数包含一个 4 字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用 8 字节，所以 TCP 头部选项中实际上最多可以包含 4 个这样的不连续数据块（考虑选项类型和长度占用的 2 字节）。</p><p>kind=8 是时间戳选项<br>该选项提供了较为准确的计算通信双方之间的回路时间（Round Trip Time，RTT）的方法，从而为 TCP 流量控制提供重要信息。</p><h2 id="多种状态的标志"><a href="#多种状态的标志" class="headerlink" title="多种状态的标志"></a>多种状态的标志</h2><h3 id="发起连接时的报文状态"><a href="#发起连接时的报文状态" class="headerlink" title="发起连接时的报文状态"></a>发起连接时的报文状态</h3><p>在连接建立时用来同步序号。当 <code>SYN=1</code> 而 <code>ACK=0</code> 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 <code>SYN=1</code> 和 <code>ACK=1</code>，因此 <code>SYN 置为 1</code> 就表示这是一个连接请求或连接接受报文。</p><h3 id="终端连接的报文状态"><a href="#终端连接的报文状态" class="headerlink" title="终端连接的报文状态"></a>终端连接的报文状态</h3><p>用来释放一个连接。当 FIN=1 时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;传输层-tcp-协议-实现&quot;&gt;&lt;a href=&quot;#传输层-tcp-协议-实现&quot; class=&quot;headerlink&quot; title=&quot;传输层 tcp 协议 实现&quot;&gt;&lt;/a&gt;传输层 tcp 协议 实现&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;43E
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
  </entry>
  
</feed>
