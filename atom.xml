<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Brewlin&#39;s Wiki</title>
  
  <subtitle>found everthing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.huido.site/"/>
  <updated>2019-12-11T09:16:14.369Z</updated>
  <id>http://blog.huido.site/</id>
  
  <author>
    <name>brewlin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shamem.h</title>
    <link href="http://blog.huido.site/wiki/other/share-mem/shamem.h/"/>
    <id>http://blog.huido.site/wiki/other/share-mem/shamem.h/</id>
    <published>2019-12-11T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SHMEM_H_INCLUDED_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SHMEM_H_INCLUDED_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  OK          0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ERROR      -1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"server.h"</span></span></span><br><span class="line"><span class="keyword">typedef</span> server serv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u_char      *addr;</span><br><span class="line">    <span class="keyword">size_t</span>       <span class="built_in">size</span>;</span><br><span class="line">    u_char    name;</span><br><span class="line">    serv   *server;</span><br><span class="line">&#125; <span class="keyword">shm_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shm_alloc</span><span class="params">(<span class="keyword">shm_t</span> *shm)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shm_free</span><span class="params">(<span class="keyword">shm_t</span> *shm)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _SHMEM_H_INCLUDED_ */</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="other" scheme="http://blog.huido.site/categories/other/"/>
    
      <category term="share-mem" scheme="http://blog.huido.site/categories/other/share-mem/"/>
    
    
      <category term="linux" scheme="http://blog.huido.site/tags/linux/"/>
    
      <category term="share" scheme="http://blog.huido.site/tags/share/"/>
    
      <category term="memory" scheme="http://blog.huido.site/tags/memory/"/>
    
      <category term="syscall" scheme="http://blog.huido.site/tags/syscall/"/>
    
  </entry>
  
  <entry>
    <title>shamem.c</title>
    <link href="http://blog.huido.site/wiki/other/share-mem/shamem.c/"/>
    <id>http://blog.huido.site/wiki/other/share-mem/shamem.c/</id>
    <published>2019-12-11T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shmem.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"log.h"</span></span></span><br><span class="line"><span class="comment">//采用 mmap 方式申请共享内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (HAVE_MAP_ANON)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shm_alloc</span><span class="params">(<span class="keyword">shm_t</span> *shm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shm-&gt;addr = (u_char *) mmap(<span class="literal">NULL</span>, shm-&gt;<span class="built_in">size</span>,</span><br><span class="line">                                PROT_READ|PROT_WRITE,</span><br><span class="line">                                MAP_ANON|MAP_SHARED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shm-&gt;addr == MAP_FAILED) &#123;</span><br><span class="line">        log_error(shm-&gt;server, <span class="string">"mmap(MAP_ANON|MAP_SHARED, %d) failed"</span>, shm-&gt;<span class="built_in">size</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    log_info(shm-&gt;server, <span class="string">"mmap(MAP_ANON|MAP_SHARED, %d) success"</span>, shm-&gt;<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shm_free</span><span class="params">(<span class="keyword">shm_t</span> *shm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (munmap((<span class="keyword">void</span> *) shm-&gt;addr, shm-&gt;<span class="built_in">size</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        log_error(shm-&gt;server, <span class="string">"munmap(%s, %d) failed"</span>, shm-&gt;addr, shm-&gt;<span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    log_info(shm-&gt;server, <span class="string">"munmap( %d) success"</span>,  shm-&gt;<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//采用 文件映射方式申请共享内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (HAVE_MAP_DEVZERO)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int_t</span> shm_alloc(<span class="keyword">shm_t</span> *shm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fd_t</span>  fd;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"/dev/zero"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        log_error(shm-&gt;server, <span class="string">"open(\"/dev/zero\") failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shm-&gt;addr = (u_char *) mmap(<span class="literal">NULL</span>, shm-&gt;<span class="built_in">size</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                                MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shm-&gt;addr == MAP_FAILED) &#123;</span><br><span class="line">        log_error(shm-&gt;server, <span class="string">"mmap(/dev/zero, MAP_SHARED, %d) failed"</span>, shm-&gt;<span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">close</span>(fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        log_error(shm-&gt;server,<span class="string">"close(\"/dev/zero\") failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (shm-&gt;addr == MAP_FAILED) ? ERROR : OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shm_free</span><span class="params">(<span class="keyword">shm_t</span> *shm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (munmap((<span class="keyword">void</span> *) shm-&gt;addr, shm-&gt;<span class="built_in">size</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        log_error(shm-&gt;server,<span class="string">"munmap(%s, %d) failed"</span>, shm-&gt;addr, shm-&gt;<span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//采用 shmget 系统调用方式申请共享内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (HAVE_SYSVSHM)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int_t</span> shm_alloc(<span class="keyword">shm_t</span> *shm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>  id;</span><br><span class="line"></span><br><span class="line">    id = shmget(IPC_PRIVATE, shm-&gt;<span class="built_in">size</span>, (SHM_R|SHM_W|IPC_CREAT));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">-1</span>) &#123;</span><br><span class="line">        log_error(shm-&gt;server,<span class="string">"shmget(%d) failed"</span>, shm-&gt;<span class="built_in">size</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_info(shm-&gt;server,, <span class="string">"shmget id: %d"</span>, id);</span><br><span class="line"></span><br><span class="line">    shm-&gt;addr = shmat(id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shm-&gt;addr == (<span class="keyword">void</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        log_error(shm-&gt;server, <span class="string">"shmat() failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shmctl(id, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        log_error(shm-&gt;server,<span class="string">"shmctl(IPC_RMID) failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (shm-&gt;addr == (<span class="keyword">void</span> *) <span class="number">-1</span>) ? ERROR : OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shm_free</span><span class="params">(<span class="keyword">shm_t</span> *shm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shmdt(shm-&gt;addr) == <span class="number">-1</span>) &#123;</span><br><span class="line">        log_error(shm-&gt;server,<span class="string">"shmdt(%s) failed"</span>, shm-&gt;addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="other" scheme="http://blog.huido.site/categories/other/"/>
    
      <category term="share-mem" scheme="http://blog.huido.site/categories/other/share-mem/"/>
    
    
      <category term="linux" scheme="http://blog.huido.site/tags/linux/"/>
    
      <category term="share" scheme="http://blog.huido.site/tags/share/"/>
    
      <category term="memory" scheme="http://blog.huido.site/tags/memory/"/>
    
      <category term="syscall" scheme="http://blog.huido.site/tags/syscall/"/>
    
  </entry>
  
  <entry>
    <title>共享内存的实现</title>
    <link href="http://blog.huido.site/wiki/other/share-mem/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    <id>http://blog.huido.site/wiki/other/share-mem/共享内存/</id>
    <published>2019-12-11T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>本质为通过系统调用申请一块内存，由系统调用，该内存可以跨进程间使用，有是那种共享内存的申请方式</p><ul><li><ol><li>采用mmap 方式申请共享内存 </li></ol></li><li><ol start="2"><li>采用文件映射方式申请共享内存</li></ol></li><li><ol start="3"><li>采用 shmget 系统调用方式申请共享内存</li></ol></li></ul><p>上面三种方式在本次实验中分别对应三种宏</p><ul><li><ol><li>HAVE_MAP_ANON</li></ol></li><li><ol start="2"><li>HAVE_MAP_DEVZERO</li></ol></li><li><ol start="3"><li>HAVE_SYSVSHM<h2 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//申请共享内存</span></span><br><span class="line"><span class="keyword">shm_t</span> shm;</span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="built_in">size</span> = <span class="number">8</span> * <span class="number">16</span>;<span class="comment">//分配128字节内存</span></span><br><span class="line">shm.<span class="built_in">size</span> = <span class="built_in">size</span>;</span><br><span class="line">shm.name  = (u_char *)<span class="string">"nginx_shared_zone"</span>;</span><br><span class="line">shm.server = serv;</span><br><span class="line">shm_alloc(&amp;shm);</span><br><span class="line"><span class="keyword">int</span>* count = (<span class="keyword">int</span> *)(shm.addr + <span class="number">8</span>);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>上面的例子中，<code>shm_alloc</code>方法分配了 128字节内存</p></li><li>申请成功后，<code>shm.addr</code> 即是共享的内存首地址，需要自己分配管理</li><li><code>int *count</code> 截取了前8个字节分配使用。转换为8字节int指针使用，<h2 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h2>通过申请一块共享内存地址，分配一个int指针，模拟http多进程处理请求并统计请求总数.如下为请求样例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">static void eventloop(server *serv) &#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    struct sigaction sa;</span><br><span class="line">    connection *con;</span><br><span class="line">    //申请共享内存</span><br><span class="line">   shm_t shm;</span><br><span class="line">   size_t size;</span><br><span class="line">   size = 8 * 16;//分配128字节内存</span><br><span class="line">   shm.size = size;</span><br><span class="line">   shm.name  = (u_char *)&quot;nginx_shared_zone&quot;;</span><br><span class="line">   shm.server = serv;</span><br><span class="line">   shm_alloc(&amp;shm);</span><br><span class="line">   int* count = (int *)(shm.addr + 8);</span><br><span class="line"></span><br><span class="line">    sa.sa_handler = sigchld_handler;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_RESTART;</span><br><span class="line"></span><br><span class="line">    if (sigaction(SIGCHLD, &amp;sa, NULL) == -1) &#123;</span><br><span class="line">        perror(&quot;sigaction&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        if ((con = connection_accept(serv)) == NULL) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((pid = fork()) == 0) &#123;</span><br><span class="line"></span><br><span class="line">            // 子进程中处理HTTP请求</span><br><span class="line">            close(serv-&gt;sockfd);</span><br><span class="line">           *count += 1;</span><br><span class="line">           printf(&quot;request count is %d\n&quot;,*count);</span><br><span class="line">            connection_handler(serv, con);</span><br><span class="line">            connection_close(con);</span><br><span class="line"></span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;child process: %d\n&quot;, pid);</span><br><span class="line">        connection_close(con);</span><br><span class="line">    &#125;</span><br><span class="line">   shm_free(&amp;shm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>统计结果：<code>ab -c 10 -n 10 http://127.0.0.1:8080/</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request count is 7</span><br><span class="line">request count is 8</span><br><span class="line">socket: 5</span><br><span class="line">socket: 5</span><br><span class="line">request count is 9</span><br><span class="line">request count is 10</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;共享内存&quot;&gt;&lt;a href=&quot;#共享内存&quot; class=&quot;headerlink&quot; title=&quot;共享内存&quot;&gt;&lt;/a&gt;共享内存&lt;/h2&gt;&lt;p&gt;本质为通过系统调用申请一块内存，由系统调用，该内存可以跨进程间使用，有是那种共享内存的申请方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
      <category term="other" scheme="http://blog.huido.site/categories/other/"/>
    
      <category term="share-mem" scheme="http://blog.huido.site/categories/other/share-mem/"/>
    
    
      <category term="linux" scheme="http://blog.huido.site/tags/linux/"/>
    
      <category term="share" scheme="http://blog.huido.site/tags/share/"/>
    
      <category term="memory" scheme="http://blog.huido.site/tags/memory/"/>
    
      <category term="syscall" scheme="http://blog.huido.site/tags/syscall/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.huido.site/wiki/net-protocol/6.%E7%89%A9%E7%90%86%E5%B1%82/tap/"/>
    <id>http://blog.huido.site/wiki/net-protocol/6.物理层/tap/</id>
    <published>2019-12-11T09:16:14.369Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="6.物理层" scheme="http://blog.huido.site/categories/net-protocol/6-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    
    
  </entry>
  
  <entry>
    <title>websocket-客户端</title>
    <link href="http://blog.huido.site/wiki/net-protocol/7.%E5%AE%A2%E6%88%B7%E7%AB%AF/websocekt-%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>http://blog.huido.site/wiki/net-protocol/7.客户端/websocekt-客户端/</id>
    <published>2019-12-06T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="客户端创建"><a href="#客户端创建" class="headerlink" title="@客户端创建"></a>@客户端创建</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/pkg/logging"</span></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/protocol/application/websocket"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;</span><br><span class="line">logging.Setup()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">wscli ,_ := websocket.NewClient(<span class="string">"http://10.0.2.15:8080/ws"</span>)</span><br><span class="line"><span class="keyword">defer</span> wscli.Close()</span><br><span class="line"><span class="comment">//升级 http协议为websocket</span></span><br><span class="line"><span class="keyword">if</span> err := wscli.Upgrade();err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环接受数据</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := wscli.Push(<span class="string">"test"</span>);err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">data,_ := wscli.Recv()</span><br><span class="line">fmt.Println(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现了基本的websocket客户端,升级http协议，发送数据，接受数据等方法</li><li>依赖tap虚拟网卡，所以需要启动网卡依赖</li><li>依赖<code>ARP</code>,<code>TCP</code>,<code>IPV4</code>等协议，所以默认注册了该协议</li><li>注意：<ul><li>1.外网请求需要使用<code>tool/up</code> 方式启动网卡配置数据包转发</li><li>2.未实现dns查询域名，必须使用ip测试</li></ul></li></ul><h2 id="NewClient-创建客户端"><a href="#NewClient-创建客户端" class="headerlink" title="@NewClient 创建客户端"></a>@NewClient 创建客户端</h2><p>构造函数传入url,默认返回一个*Client 指针<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli,err := http.NewClient(<span class="string">"http://10.0.2.15:8080/ws"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="Close-关闭连接"><a href="#Close-关闭连接" class="headerlink" title="@Close 关闭连接"></a>@Close 关闭连接</h2><p>结束后，需要手动关闭连接，底层进行tcp四次挥手结束两端状态<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> wscli.Close()</span><br></pre></td></tr></table></figure></p><h2 id="Upgrade-升级协议"><a href="#Upgrade-升级协议" class="headerlink" title="@Upgrade 升级协议"></a>@Upgrade 升级协议</h2><p>该方法主要执行两个步骤</p><ul><li><ol><li>发起http情况，告诉服务端为websocket协议</li></ol></li><li><ol start="2"><li>对服务端返回的http响应，进行校验，校验通过后保持tcp连接，升级为websocket协议<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升级 http协议为websocket</span></span><br><span class="line"><span class="keyword">if</span> err := wscli.Upgrade();err != <span class="literal">nil</span> &#123;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="push-推送数据"><a href="#push-推送数据" class="headerlink" title="@push 推送数据"></a>@push 推送数据</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscli.Push(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure><p>添加数据</p><h2 id="Recv-获取数据"><a href="#Recv-获取数据" class="headerlink" title="@Recv 获取数据"></a>@Recv 获取数据</h2><p>读取该websocket流 接受的数据，本质为tcp流数据，经过websocket协议解包后处理<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data,_ := wscli.Recv()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;客户端创建&quot;&gt;&lt;a href=&quot;#客户端创建&quot; class=&quot;headerlink&quot; title=&quot;@客户端创建&quot;&gt;&lt;/a&gt;@客户端创建&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="7.客户端" scheme="http://blog.huido.site/categories/net-protocol/7-%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="http" scheme="http://blog.huido.site/tags/http/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
      <category term="client" scheme="http://blog.huido.site/tags/client/"/>
    
      <category term="request" scheme="http://blog.huido.site/tags/request/"/>
    
      <category term="response" scheme="http://blog.huido.site/tags/response/"/>
    
      <category term="websocket" scheme="http://blog.huido.site/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>快速开始</title>
    <link href="http://blog.huido.site/wiki/net-protocol/1.%E5%89%8D%E8%A8%80/1.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/"/>
    <id>http://blog.huido.site/wiki/net-protocol/1.前言/1.快速开始/</id>
    <published>2019-12-05T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="demo案例"><a href="#demo案例" class="headerlink" title="demo案例"></a>demo案例</h2><p><code>cmd</code>:该目录下为各协议的实现demo，提供api调用实现以及测试</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ol><li>需要配置相关的参数 <code>config/net.go</code></li><li>如果应用层协议要与外网通讯，必须配置本地物理网卡作为网关使用</li><li>推荐使用<code>too/up.go</code>工具，创建tap网卡和配置环境</li></ol><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><h3 id="1-外网通讯问题"><a href="#1-外网通讯问题" class="headerlink" title="1.外网通讯问题"></a>1.外网通讯问题</h3><p><code>请看目录8问题反馈:</code></p><p>目前外网通讯采用的是，使用本地物理网卡开启<code>ip_forward</code> 和<code>nat</code>转发达到外网通讯，测试发现多次无法收到外网的回复包，导致client等调用超时，</p><p>具体可以通过抓包物理网卡观察</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;demo案例&quot;&gt;&lt;a href=&quot;#demo案例&quot; class=&quot;headerlink&quot; title=&quot;demo案例&quot;&gt;&lt;/a&gt;demo案例&lt;/h2&gt;&lt;p&gt;&lt;code&gt;cmd&lt;/code&gt;:该目录下为各协议的实现demo，提供api调用实现以及测试&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="1.前言" scheme="http://blog.huido.site/categories/net-protocol/1-%E5%89%8D%E8%A8%80/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
  </entry>
  
  <entry>
    <title>http-客户端</title>
    <link href="http://blog.huido.site/wiki/net-protocol/7.%E5%AE%A2%E6%88%B7%E7%AB%AF/http-%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>http://blog.huido.site/wiki/net-protocol/7.客户端/http-客户端/</id>
    <published>2019-12-05T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="客户端创建"><a href="#客户端创建" class="headerlink" title="@客户端创建"></a>@客户端创建</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/pkg/logging"</span></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/protocol/application/http"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;</span><br><span class="line">logging.Setup()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cli,err := http.NewClient(<span class="string">"http://10.0.2.15:8080/test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">cli.SetMethod(<span class="string">"GET"</span>)</span><br><span class="line">cli.SetData(<span class="string">"test"</span>)</span><br><span class="line">res,err := cli.GetResult()</span><br><span class="line">fmt.Println(res)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现了基本的http客户端,发起请求和接收响应等get post方法</li><li>依赖tap虚拟网卡，所以需要启动网卡依赖</li><li>依赖<code>ARP</code>,<code>TCP</code>,<code>IPV4</code>等协议，所以默认注册了该协议</li><li>注意：<ul><li>1.外网请求需要使用<code>tool/up</code> 方式启动网卡配置数据包转发</li><li>2.未实现dns查询域名，必须使用ip测试</li></ul></li></ul><h2 id="NewClient-创建客户端"><a href="#NewClient-创建客户端" class="headerlink" title="@NewClient 创建客户端"></a>@NewClient 创建客户端</h2><p>构造函数传入url,默认返回一个*Client 指针<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli,err := http.NewClient(<span class="string">"http://10.0.2.15:8080/test"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="设置请求方法"><a href="#设置请求方法" class="headerlink" title="@设置请求方法"></a>@设置请求方法</h2><p>设置请求的http方法 <code>GET,POST</code>等<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli.SetMethod(<span class="string">"GET"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="添加请求数据"><a href="#添加请求数据" class="headerlink" title="@添加请求数据"></a>@添加请求数据</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli.SetData(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure><p>添加数据</p><h2 id="获取响应结果"><a href="#获取响应结果" class="headerlink" title="@获取响应结果"></a>@获取响应结果</h2><p>该方法真正执行tcp连接，发送数据，和读取响应数据<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res,err := cli.GetResult()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;客户端创建&quot;&gt;&lt;a href=&quot;#客户端创建&quot; class=&quot;headerlink&quot; title=&quot;@客户端创建&quot;&gt;&lt;/a&gt;@客户端创建&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="7.客户端" scheme="http://blog.huido.site/categories/net-protocol/7-%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="http" scheme="http://blog.huido.site/tags/http/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
      <category term="client" scheme="http://blog.huido.site/tags/client/"/>
    
      <category term="request" scheme="http://blog.huido.site/tags/request/"/>
    
      <category term="response" scheme="http://blog.huido.site/tags/response/"/>
    
  </entry>
  
  <entry>
    <title>Tun/Tap虚拟网卡外网通讯</title>
    <link href="http://blog.huido.site/wiki/net-protocol/8.%E9%97%AE%E9%A2%98%E5%8F%8D%E9%A6%88/tun_tap/"/>
    <id>http://blog.huido.site/wiki/net-protocol/8.问题反馈/tun_tap/</id>
    <published>2019-12-04T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>tap属于2层协议，也就是他能够像读取文件一样获取拥有完整的数据包，包括以太网封装的mac目的地址和源地址等。拥有自己的<code>ip地址和网段</code>、<code>mac地址</code>、等信息，可以当做完整独立的网卡</p><p>tun数据2层协议，也就是只能获取ip数据包结构，不能获得mac地址等等网络层以下的数据信息</p><ol><li>默认tap网卡有自己的<code>网段</code>，和本地物理网卡<code>不在同一个网段</code>，那么收发的数据包需要路由配置，但是无法转发到网关路由器</li><li>有两种方法可以让tap网卡收发外网数据包，</li></ol><ul><li><code>新建一个网桥bridge,并把tap和物理网卡桥接到该网桥下</code></li><li><code>tap网卡的数据包所有的都转发到本地物理网卡上</code>，让物理网卡替tap 收发数据包到网关</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------------------------------------------+</span><br><span class="line">|                                                                |</span><br><span class="line">|       +------------------------------------------------+       |</span><br><span class="line">|       |             Newwork Protocol Stack             |       |</span><br><span class="line">|       +------------------------------------------------+       |</span><br><span class="line">|              ↑                                ↑                |</span><br><span class="line">|..............|................................|................|</span><br><span class="line">|              ↓                                ↓                |</span><br><span class="line">|        +----------+                     +------------+         |</span><br><span class="line">|        |   eth0   |                     |     tap0   |         |</span><br><span class="line">|        +----------+                     +------------+         |</span><br><span class="line">|    10.0.2.15 ↑                        192.168.1.1              |</span><br><span class="line">|              |                                                 |</span><br><span class="line">|              |                                                 |</span><br><span class="line">+--------------|-------------------------------------------------+</span><br><span class="line">               ↓</span><br><span class="line">         Physical Network</span><br></pre></td></tr></table></figure><p>可以看到新建的tap虚拟网卡，可以自己定义协议栈和收发数据，但是却无法和物理网卡通讯</p><h2 id="1-ip转发方式实现外网通讯"><a href="#1-ip转发方式实现外网通讯" class="headerlink" title="1. ip转发方式实现外网通讯"></a>1. ip转发方式实现外网通讯</h2><p>本质来说，就是让tap和 本地网卡通讯，只是目的ip依然为<code>外网ip</code>,那么本地网卡收到数据包后，判断ip为外网后替你转发到网卡后，进行一下跳，直到收到对方的包，然后在回复给tap网卡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------------------------------------------+</span><br><span class="line">|                                                                |</span><br><span class="line">|   +-------------------------  |  -----------------------+      |</span><br><span class="line">|   |             Newwork Prot  |  ocol Stack             |      |</span><br><span class="line">|   +-------------------------  |  -----------------------+      |</span><br><span class="line">|              ↑                                ↑                |</span><br><span class="line">|..............|................................|................|</span><br><span class="line">|              ↓                                ↓                |</span><br><span class="line">|        +----------+                     +------------+         |</span><br><span class="line">|        |   eth0   |     &lt;-------&gt;       |     tap0   |         |</span><br><span class="line">|        +----------+                     +------------+         |</span><br><span class="line">|    10.0.2.15 ↑                        192.168.1.1              |</span><br><span class="line">|              |                                                 |</span><br><span class="line">|              |                                                 |</span><br><span class="line">+--------------|-------------------------------------------------+</span><br><span class="line">               ↓</span><br><span class="line">         Physical Network</span><br></pre></td></tr></table></figure></p><p>总的来说就是所有的数据包都发给<code>eth0</code>,<code>mac目的地址</code>填eth0的MAC地址，<code>目的ip地址</code>保持不变，传给eth0 让他去判断后转发给网关,最后转发到外网去。</p><h3 id="开启物理网卡的ip转发"><a href="#开启物理网卡的ip转发" class="headerlink" title="@开启物理网卡的ip转发"></a>@开启物理网卡的ip转发</h3><p>临时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;1&quot;&gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><p>永久</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># nano /etc/sysctl.conf</span><br><span class="line">net.ipv4.ip_forward=1//取消注释</span><br><span class="line"># sysctl -p//保存</span><br></pre></td></tr></table></figure><p>第三种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo sysctl net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure><h3 id="配置网卡防火墙规则"><a href="#配置网卡防火墙规则" class="headerlink" title="@配置网卡防火墙规则"></a>@配置网卡防火墙规则</h3><p>配置物理网卡接受来自tap网段的数据包，并进行nat转发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># iptables -F//清除所有的iptables规则</span><br><span class="line"># iptables -P INPUT ACCEPT//允许接收</span><br><span class="line"># iptables -P FORWARD ACCEPT//允许发送数据包</span><br><span class="line"># iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j MASQUERADE //MASQUERADE方式配置nat</span><br></pre></td></tr></table></figure><h2 id="2-桥接网卡模式"><a href="#2-桥接网卡模式" class="headerlink" title="2. 桥接网卡模式"></a>2. 桥接网卡模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------------------------------------------+</span><br><span class="line">|                                                                |</span><br><span class="line">|       +------------------------------------------------+       |</span><br><span class="line">|       |             Newwork Protocol Stack             |       |</span><br><span class="line">|       +------------------------------------------------+       |</span><br><span class="line">|                         ↑                           ↑          |</span><br><span class="line">|.........................|...........................|..........|</span><br><span class="line">|                         ↓                           ↓          |</span><br><span class="line">|        +------+     +--------+     +-------+    |</span><br><span class="line">|        |      |     | .2.15  |     |192.168.1.0    |</span><br><span class="line">|        +------+     +--------+  &lt;----------   +-------+    |</span><br><span class="line">|        | eth0 |&lt;---&gt;|   br0  || tap|    |</span><br><span class="line">|        +------+     +--------+     +-------+    |</span><br><span class="line">|            ↑                                      |</span><br><span class="line">|            |                            |</span><br><span class="line">|            |                            |</span><br><span class="line">|            |                                                   |</span><br><span class="line">+------------|---------------------------------------------------+</span><br><span class="line">             ↓</span><br><span class="line">     Physical Network</span><br></pre></td></tr></table></figure><p>可以看到，tap网卡所有的写入数据都会转发到网桥br0上，处理，也能发送到网关连通外网，但是我的tap网卡却收不到网桥发回的数据，</p><p>比如tap发送一个tcp sync 包到外网ip<code>114.148.199.89</code>(瞎编的)，那么他的流程实际是这样</p><ol><li>tap -&gt; br0  br0收到目的ip不是本机，则发给网关，并带上源mac地址为br0地址</li><li>br0 -&gt; gateway 网关收到数据后进行下一跳，直到发送给<code>114.148.199.89</code></li><li><code>114.148.199.89</code> -&gt; br0  114.148.199.89收到sync包，并发送ack给br0</li><li>br0 收到了该ack包，但是发现目的ip也就是tap的ip地址路由不到，就会发送icmp rst复位数据包告诉 <code>114.148.199.89</code> 连接错误</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在没有解决为什么tap网卡收不到外网包的问题!</span><br></pre></td></tr></table></figure><h3 id="配置桥接"><a href="#配置桥接" class="headerlink" title="配置桥接"></a>配置桥接</h3><ol><li>桥接物理网卡到网桥上</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- `brctl addbr br0`                 #创建网桥</span><br><span class="line">- `brctl addif br0 eth0`            #将eth0先加入网桥</span><br><span class="line">- `ifconfig br0 10.0.2.15 up`    #启动网桥并分配IP</span><br><span class="line">- `ifconfig eth0 0.0.0.0`           #eth0现在不需要IP地址了</span><br></pre></td></tr></table></figure><ol start="2"><li>创建tap网卡</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- sudo ip tuntap add mode tap tap0</span><br><span class="line">- sudo ip link set tap0 up</span><br><span class="line">- sudo ip addr add 192.168.1.1/24 dev tap0</span><br></pre></td></tr></table></figure><ol start="3"><li>桥接tap网</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- brctl addif br0 tap0</span><br></pre></td></tr></table></figure><ol start="4"><li>转移网关到网桥上</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- ip route add defalut via 10.0.2.2 dev br0</span><br></pre></td></tr></table></figure><ol start="5"><li>配置nat 防火墙转发</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o br0 -j MASQUERADE</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;tap属于2层协议，也就是他能够像读取文件一样获取拥有完整的数据包，包括以太网封装的mac目的地址和源地址等。拥有自己的&lt;code&gt;ip地址
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="8.问题反馈" scheme="http://blog.huido.site/categories/net-protocol/8-%E9%97%AE%E9%A2%98%E5%8F%8D%E9%A6%88/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tap" scheme="http://blog.huido.site/tags/tap/"/>
    
      <category term="tun" scheme="http://blog.huido.site/tags/tun/"/>
    
      <category term="bridge" scheme="http://blog.huido.site/tags/bridge/"/>
    
  </entry>
  
  <entry>
    <title>Logic 节点开放接口</title>
    <link href="http://blog.huido.site/wiki/im-cloud/6.%E5%BC%80%E6%94%BE%E6%8E%A5%E5%8F%A3/logic%E5%BC%80%E6%94%BE%E6%8E%A5%E5%8F%A3/"/>
    <id>http://blog.huido.site/wiki/im-cloud/6.开放接口/logic开放接口/</id>
    <published>2019-11-24T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http-api接口"><a href="#http-api接口" class="headerlink" title="http api接口"></a>http api接口</h2><p>开放api推送接口,暴露http接口，提供用户业务推送功能<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpRouter::post(<span class="string">"/im/push/keys"</span>,<span class="string">"/Api/PushKeyController/keys"</span>);</span><br><span class="line">HttpRouter::post(<span class="string">"/im/push/mids"</span>,<span class="string">"/Api/PushMidController/mids"</span>);</span><br><span class="line">HttpRouter::post(<span class="string">"/im/push/room"</span>,<span class="string">"/Api/PushRoomController/room"</span>);</span><br><span class="line">HttpRouter::post(<span class="string">"/im/push/all"</span>,<span class="string">"/Api/PushAllController/all"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="push-keys"><a href="#push-keys" class="headerlink" title="@push/keys"></a>@push/keys</h3><p>根据<code>keys</code> 为id推送消息，key为client在注册cloud节点时分配的唯一值，每个端点（pc,android,ios）等注册等连接key值不同，所以会进行全部推送</p><p>[post] request:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;keys&quot;:[x,x,x,x,],</span><br><span class="line">    &quot;msg&quot;:&quot;bytes&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="push-mids"><a href="#push-mids" class="headerlink" title="@push/mids"></a>@push/mids</h3><p>根据<code>mids</code> 为id推送对应client消息，mid为业务方自行管理，同一用户每个端点等mid唯一</p><p>[post] request:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;mids&quot;:[x,x,x,x,],</span><br><span class="line">    &quot;msg&quot;:&quot;bytes&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="push-room"><a href="#push-room" class="headerlink" title="@push/room"></a>@push/room</h3><p>进行房间广播，<code>type</code> + <code>room</code> 组合为房间唯一id<br>[post] request:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;:&quot;product1&quot;,</span><br><span class="line">    &quot;room&quot;:&quot;room1&quot;,</span><br><span class="line">    &quot;msg&quot;:&quot;bytes&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="push-all"><a href="#push-all" class="headerlink" title="@push/all"></a>@push/all</h3><p>广播消息，推送所有端点所有连接</p><p>[post] request:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;msg&quot;:&quot;bytes&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="grpc-接口"><a href="#grpc-接口" class="headerlink" title="grpc 接口"></a>grpc 接口</h2><p>提供cloud节点用户连接注册grpc接口，多节点可以采用负载均衡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpRouter::post(&apos;/im.logic.Logic/Connect&apos;, &apos;/Grpc/Logic/connect&apos;);</span><br><span class="line">HttpRouter::post(&apos;/im.logic.Logic/Disconnect&apos;, &apos;/Grpc/Logic/disConnect&apos;);</span><br><span class="line">HttpRouter::post(&apos;/im.logic.Logic/Heartbeat&apos;, &apos;/Grpc/Logic/heartBeat&apos;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;http-api接口&quot;&gt;&lt;a href=&quot;#http-api接口&quot; class=&quot;headerlink&quot; title=&quot;http api接口&quot;&gt;&lt;/a&gt;http api接口&lt;/h2&gt;&lt;p&gt;开放api推送接口,暴露http接口，提供用户业务推送功能&lt;br&gt;&lt;figu
      
    
    </summary>
    
      <category term="im-cloud" scheme="http://blog.huido.site/categories/im-cloud/"/>
    
      <category term="6.开放接口" scheme="http://blog.huido.site/categories/im-cloud/6-%E5%BC%80%E6%94%BE%E6%8E%A5%E5%8F%A3/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="corotinue" scheme="http://blog.huido.site/tags/corotinue/"/>
    
      <category term="grpc" scheme="http://blog.huido.site/tags/grpc/"/>
    
      <category term="http" scheme="http://blog.huido.site/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>单线程全协程化版</title>
    <link href="http://blog.huido.site/wiki/im-cloud/2.%E7%89%88%E6%9C%AC/2.%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%85%A8%E5%8D%8F%E7%A8%8B%E5%8C%96%E7%89%88/"/>
    <id>http://blog.huido.site/wiki/im-cloud/2.版本/2.单进程全协程化版/</id>
    <published>2019-11-19T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<p><code>im-cloud/apps</code> 为单线程协程化版本，协程server、协程httpserver、协程websocekt协议等实现<code>cloud-s</code>,<code>job-s</code>,<code>logic-s</code></p><p>协程化server暂且不清楚是否能够跨cpu调度，testing。。。。</p><h2 id="cloud-s-协程版cloud节点"><a href="#cloud-s-协程版cloud节点" class="headerlink" title="@cloud-s 协程版cloud节点"></a>@cloud-s 协程版cloud节点</h2><p>该节点根据<code>SWOOLE 4.4.12+</code> 最新支持http2协议为基础构建，底层为单进程协程server：<code>\Swoole\Coroutine\Server</code>构建协程tcp服务器，暴露tcp方式注册cloud中心</p><p>GRPC中心根据http_server:<code>\Swoole\Coroutine\Http\Server</code>构建基于http2协程的grpc中心，提供业务接口处理，并在该协程模式下实现<code>websocket</code>协议提供websocekt注册中心</p><h2 id="job-s-协程版job节点"><a href="#job-s-协程版job节点" class="headerlink" title="@job-s 协程版job节点"></a>@job-s 协程版job节点</h2><p>基于单进程版消费队列数据，并推送cloud节点处理，无特殊处理，可以采用多进程版本配合使用</p><h2 id="logic-s-协程版logic节点"><a href="#logic-s-协程版logic节点" class="headerlink" title="@logic-s 协程版logic节点"></a>@logic-s 协程版logic节点</h2><p>该节点采用<code>\Swoole\Coroutine\Http\Server</code>构建，并暴露接口提供client推送</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;im-cloud/apps&lt;/code&gt; 为单线程协程化版本，协程server、协程httpserver、协程websocekt协议等实现&lt;code&gt;cloud-s&lt;/code&gt;,&lt;code&gt;job-s&lt;/code&gt;,&lt;code&gt;logic-s&lt;/code&gt;&lt;/
      
    
    </summary>
    
      <category term="im-cloud" scheme="http://blog.huido.site/categories/im-cloud/"/>
    
      <category term="2.版本" scheme="http://blog.huido.site/categories/im-cloud/2-%E7%89%88%E6%9C%AC/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="corotinue" scheme="http://blog.huido.site/tags/corotinue/"/>
    
  </entry>
  
  <entry>
    <title>版本兼容</title>
    <link href="http://blog.huido.site/wiki/im-cloud/2.%E7%89%88%E6%9C%AC/1.%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9/"/>
    <id>http://blog.huido.site/wiki/im-cloud/2.版本/1.版本兼容/</id>
    <published>2019-11-19T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<p>多进程与单线程协程版本都依赖与 <code>pkg/Core</code> 核心组件</p><p>单线程协程版 重写了<code>App/Application -&gt; run()</code>方法，并替换掉协程模式的server达到兼容整体架构的运行，更多细节请查看源码</p><p>多进程版本，根据需要在<code>config/server.php</code> 中配置进程数和task进程数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多进程与单线程协程版本都依赖与 &lt;code&gt;pkg/Core&lt;/code&gt; 核心组件&lt;/p&gt;
&lt;p&gt;单线程协程版 重写了&lt;code&gt;App/Application -&amp;gt; run()&lt;/code&gt;方法，并替换掉协程模式的server达到兼容整体架构的运行，更多细节请查看
      
    
    </summary>
    
      <category term="im-cloud" scheme="http://blog.huido.site/categories/im-cloud/"/>
    
      <category term="2.版本" scheme="http://blog.huido.site/categories/im-cloud/2-%E7%89%88%E6%9C%AC/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="corotinue" scheme="http://blog.huido.site/tags/corotinue/"/>
    
  </entry>
  
  <entry>
    <title>多进程worker版本</title>
    <link href="http://blog.huido.site/wiki/im-cloud/2.%E7%89%88%E6%9C%AC/3.%E5%A4%9A%E8%BF%9B%E7%A8%8Bworker%E7%89%88/"/>
    <id>http://blog.huido.site/wiki/im-cloud/2.版本/3.多进程worker版/</id>
    <published>2019-11-19T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<p><code>im-cloud/appm</code> 为多进程Worker-Task模型构建服务，基于<code>Swoole\Server,Swoole\Http\Server</code>等实现<code>cloud-m</code>,<code>job-m</code>,<code>logic-m</code>节点</p><h2 id="cloud-m-多进程版cloud节点"><a href="#cloud-m-多进程版cloud节点" class="headerlink" title="@cloud-m 多进程版cloud节点"></a>@cloud-m 多进程版cloud节点</h2><p>多进程采用 task进程-worker进程 等多进程处理请求方法，提升节点处理能力.cloud节点提供tcp、websocket等长连接注册到cloud中心，并提供grpc接口提供内部负载均衡推送</p><h2 id="job-m-多进程版job节点"><a href="#job-m-多进程版job节点" class="headerlink" title="@job-m 多进程版job节点"></a>@job-m 多进程版job节点</h2><p>job为多进程消费队列数据，能更好的消费数据，提高并发处理能力</p><h2 id="logic-m-多进程版logic节点"><a href="#logic-m-多进程版logic节点" class="headerlink" title="@logic-m 多进程版logic节点"></a>@logic-m 多进程版logic节点</h2><p>logic接口为用户业务接口节点，提供api接口推送数据，并缓存cloud用户连接数据到redis中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;im-cloud/appm&lt;/code&gt; 为多进程Worker-Task模型构建服务，基于&lt;code&gt;Swoole\Server,Swoole\Http\Server&lt;/code&gt;等实现&lt;code&gt;cloud-m&lt;/code&gt;,&lt;code&gt;job-m&lt;/code
      
    
    </summary>
    
      <category term="im-cloud" scheme="http://blog.huido.site/categories/im-cloud/"/>
    
      <category term="2.版本" scheme="http://blog.huido.site/categories/im-cloud/2-%E7%89%88%E6%9C%AC/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="process" scheme="http://blog.huido.site/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>arp子网查询&amp;跨子网查询</title>
    <link href="http://blog.huido.site/wiki/net-protocol/4.%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%A8%E5%AD%90%E7%BD%91arp%E6%9F%A5%E8%AF%A2&amp;%E5%AD%90%E7%BD%91arp%E6%9F%A5%E8%AF%A2/"/>
    <id>http://blog.huido.site/wiki/net-protocol/4.网络层/跨子网arp查询&amp;子网arp查询/</id>
    <published>2019-11-13T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当前网段为：192.168.1.0/24</span><br><span class="line">当前网络ip：192.168.1.1</span><br><span class="line">源mac地址 ：aa:00:01:01:01:01</span><br><span class="line">广播地址  ：ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure><h2 id="子网查询"><a href="#子网查询" class="headerlink" title="@子网查询"></a>@子网查询</h2><h3 id="1-广播"><a href="#1-广播" class="headerlink" title="1.广播"></a>1.广播</h3><p>下面为一个查询<code>192.168.1.2</code> mac地址的arp请求<br>6字节 |  6字节|2字节|2字节|2字节|1字节|1字节|2字节|6字节|4字节|6字节|4字节<br>—|—       |—- |—|—|—|—|—|—|—|—|–|—|—-|<br>源Mac地址 | 目的Mac地址|以太网帧类型|硬件类型|协议类型|地址长度|协议地址长度|操作码|源mac地址|源ip地址|目的mac地址|目的ip地址<br>aa:00:01:01:01:01|ff:ff:ff:ff:ff:ff|0x806|1|0x800|6|4|1|aa:00:01:01:01:01|192.168.1.1|?|192.168.1.2</p><p>可以看到在arp报文中，目的mac地址留空，期待arp回复的时候填满，这样就拿到了mac地址</p><h2 id="跨子网查询"><a href="#跨子网查询" class="headerlink" title="@跨子网查询"></a>@跨子网查询</h2><h3 id="1-广播-1"><a href="#1-广播-1" class="headerlink" title="1.广播"></a>1.广播</h3><p>下面为一个查询<code>115.159.254.64</code> mac地址的arp请求,跨子网通信区别在于目的mac地址为<code>网关mac地址</code><br>6字节 |  6字节|2字节|2字节|2字节|1字节|1字节|2字节|6字节|4字节|6字节|4字节<br>—|—       |—- |—|—|—|—|—|—|—|—|–|—|—-|<br>源Mac地址 | 网关mac地址|以太网帧类型|硬件类型|协议类型|地址长度|协议地址长度|操作码|源mac地址|源ip地址|目的mac地址|目的ip地址<br>aa:00:01:01:01:01|<strong><strong><strong><strong>*</strong></strong></strong></strong>|0x806|1|0x800|6|4|1|aa:00:01:01:01:01|192.168.1.1|?|192.168.1.2</p><p>直接将数据发往网关，网关在根据一下跳地址继续发往目的地</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="4.网络层" scheme="http://blog.huido.site/categories/net-protocol/4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="arp" scheme="http://blog.huido.site/tags/arp/"/>
    
  </entry>
  
  <entry>
    <title>tcp-客户端</title>
    <link href="http://blog.huido.site/wiki/net-protocol/7.%E5%AE%A2%E6%88%B7%E7%AB%AF/tcp-%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>http://blog.huido.site/wiki/net-protocol/7.客户端/tcp-客户端/</id>
    <published>2019-11-10T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="客户端创建"><a href="#客户端创建" class="headerlink" title="@客户端创建"></a>@客户端创建</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/pkg/logging"</span></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/protocol/transport/tcp/client"</span></span><br><span class="line">_ <span class="string">"github.com/brewlin/net-protocol/stack/stackinit"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">logging.Setup()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//注意不可以 目标IP为 127.0.0.1 导致无法发送 数据包</span></span><br><span class="line">con := client.NewClient(<span class="string">"10.0.2.15"</span>, <span class="number">8080</span>)</span><br><span class="line"><span class="keyword">if</span> err := con.Connect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    con.Write([]<span class="keyword">byte</span>(<span class="string">"send msg"</span>))</span><br><span class="line">    <span class="comment">//阻塞等待读</span></span><br><span class="line">res, _ := con.Read()</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(res))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现了基本的tcp客户端连接读写等函数</li><li>依赖tap虚拟网卡，所以需要启动网卡依赖</li><li>依赖<code>ARP</code>,<code>TCP</code>,<code>IPV4</code>等协议，所以默认注册了该协议</li><li>注意：<code>默认本地地址为192.168.1.0/24 网段，如果目标ip为127.0.0.1 导致无法arp查询物理层地址,请填写局域网物理机器ip,或者外网ip</code></li></ul><h2 id="NewClient-创建客户端"><a href="#NewClient-创建客户端" class="headerlink" title="@NewClient 创建客户端"></a>@NewClient 创建客户端</h2><p>构造函数传入目的ip,端口等参数，默认返回一个*Client 指针<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con := client.NewClient(<span class="string">"10.0.2.15"</span>, <span class="number">8080</span>)</span><br></pre></td></tr></table></figure></p><p>注意:<code>默认本地地址为192.168.1.0/24 网段，如果目标ip为127.0.0.1 导致无法arp查询物理层地址</code></p><h2 id="Connect-tcp连接握手"><a href="#Connect-tcp连接握手" class="headerlink" title="@Connect tcp连接握手"></a>@Connect tcp连接握手</h2><p>该函数主要处理两个任务</p><ul><li>1.检查tap网卡是否启动，没有则默认初始化启动一个tap网卡拿到<code>fd</code></li><li>2.进行tcp三次握手<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := con.Connect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">       fmt.Println(err)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>连接失败的情况举例:<br>1.<code>err = no remote link address</code></p><ul><li>这种情况一般表示该ip地址的arp查询失败，没有找到对应的mac地址<br>2.<code>err = connection was refused</code></li><li>这个和linux socket 错误码一致 表示 对端未监听该端口,连接拒绝</li></ul><h2 id="Write-写入数据"><a href="#Write-写入数据" class="headerlink" title="@Write 写入数据"></a>@Write 写入数据</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.Write([]<span class="keyword">byte</span>(<span class="string">"send msg"</span>))</span><br></pre></td></tr></table></figure><p>直接向对端连接写入数据，错误返回err</p><h2 id="Read-读取数据"><a href="#Read-读取数据" class="headerlink" title="@Read 读取数据"></a>@Read 读取数据</h2><p>一次只读取一次数据，如果缓存没有读取完，则会返回 <code>ErrWouldBlock</code>错误，可以 在此监听该读方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   //阻塞等待读</span><br><span class="line">res, _ := con.Read()</span><br></pre></td></tr></table></figure></p><h2 id="Readn-读取n字节数据"><a href="#Readn-读取n字节数据" class="headerlink" title="@Readn 读取n字节数据"></a>@Readn 读取n字节数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// var p [8]byte</span><br><span class="line">// res, _ := con.Readn(p[:1])</span><br><span class="line">// fmt.Println(p)</span><br></pre></td></tr></table></figure><p>可以根据传入参数填充对应的字节数数据，如果不够则会阻塞等待数据填充满为止</p><p>golang 的slice底层是一个指针，所以虽然传值，但是实际会复制指针，那么该slice实际值会在Readn（）函数里被改变填充完后返回</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;客户端创建&quot;&gt;&lt;a href=&quot;#客户端创建&quot; class=&quot;headerlink&quot; title=&quot;@客户端创建&quot;&gt;&lt;/a&gt;@客户端创建&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="7.客户端" scheme="http://blog.huido.site/categories/net-protocol/7-%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
      <category term="client" scheme="http://blog.huido.site/tags/client/"/>
    
  </entry>
  
  <entry>
    <title>流量控制-滑动窗口</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/5.%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/tcp/5.流量控制的实现-滑动窗口/</id>
    <published>2019-11-05T12:20:20.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<p>接收端在给发送端回 ACK 中会汇报自己的 AdvertisedWindow，而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。<br>要明确的是滑动窗口分为两个窗口，接收窗口和发送窗口</p><h2 id="接受窗口"><a href="#接受窗口" class="headerlink" title="@接受窗口"></a>@接受窗口</h2><p>接收窗口不仅可以限制发送端发送的速率，还可以提高效率，因为接收窗口的机制，可以允许发送端一次多发送几个片段，而不必等候 ACK，而且可以允许等待一定情况下的乱序， 比如说先缓存提前到的数据，然后去等待需要的数据。</p><p>接收的窗口可以分为四段：</p><ul><li>数据已经被 tcp 确认，但用户程序还未读取数据内容</li><li>中间还有些数据没有到达</li><li>数据已经接收到，但 tcp 未确认</li><li>通告窗口，也就是接收端在给发送端回 ACK 中会汇报自己的窗口大小</li></ul><p>当接收端接收到数据包时，会判断该数据包的序列号是不是在接收窗口內，如果不在窗口內会立即回一个 ack 给发送端， 且丢弃该报文。<br>滑动： 当用户程序读取接收窗口的内容后，窗口向右滑行</p><h2 id="发送窗口"><a href="#发送窗口" class="headerlink" title="@发送窗口"></a>@发送窗口</h2><p>发送窗口的值是由接收窗口和拥塞窗口一起决定的，发送窗口的大小也决定了发送的速率。</p><p>发送窗口的上限值 = Min [rwnd, cwnd]，cwnd 拥塞窗口</p><p>f发送窗口可以分成四段:</p><ul><li>已收到 ack 确认的数据</li><li>已经发送，但还没收到 ack 的数据</li><li>在窗口中还没有发出的（接收方还有空间）</li><li>窗口以外的数据（接收方没空间）<br>滑动： 当发送端收到数据 ack 确认时，窗口向右滑</li></ul><p>如果一个处理缓慢的 Server（接收端）是怎么把 Client（发送端）的TCP Sliding Window给降成 0 的。此时，你一定会问，如果 Window 变成 0 了，TCP 会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿 Window size 可用了，怎么通知发送端呢？</p><p>1.当接收方的应用程序读取了接收缓冲区中的数据以后，接收方会发送一个 ACK，通过通告窗口字段告诉发送方自己又可以接收数据了，发送方收到这个 ACK 之后，就知道自己可以继续发送数据了。</p><p>2.同时发送端使用了Zero Window Probe技术，缩写为 ZWP，当接收方的接收窗口为 0 时，每隔一段时间，发送方会主动发送探测包，迫使对端响应来得知其接收窗口有无打开。</p><p>既然接收端会主动通知发送端，为何还需要发送端定时探测？</p><h2 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="@Silly Window Syndrome"></a>@Silly Window Syndrome</h2><p>Silly Window Syndrome翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走 Receive Windows 里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的 window，而我们的发送方会义无反顾地发送这几个字节。</p><p>要知道，我们的 TCP+IP 头有 40 个字节，为了几个字节，要达上这么大的开销，这太不经济了。</p><p>所以，Silly Windows Syndrome这个现像就像是你本来可以坐 200 人的飞机里只做了一两个人。要解决这个问题也不难，就是避免对小的 window size 做出响应，直到有足够大的 window size 再响应，这个思路可以同时实现在 sender 和 receiver 两端。</p><p>如果这个问题是由 Receiver 端引起的，那么就会使用David D Clark’s方案。在 receiver 端，如果收到的数据导致window size小于某个值，可以直接 ack(0)回 sender，这样就把 window 给关闭了，也阻止了 sender 再发数据过来，等到 receiver 端处理了一些数据后windows size大于等于了 MSS，或者，receiver buffer有一半为空，就可以把 window 打开让 sender 发送数据过来。</p><p>如果这个问题是由 Sender 端引起的，那么就会使用著名的Nagle’s algorithm。这个算法的思路也是延时处理，他有两个主要的条件：</p><p>要等到 Window Size &gt;= MSS 或是 Data Size &gt;= MSS<br>收到之前发送数据的 ack 回包，他才会发数据，否则就是在攒数据</p><h2 id="发送窗口的维护"><a href="#发送窗口的维护" class="headerlink" title="@发送窗口的维护"></a>@发送窗口的维护</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                     +-------&gt; sndWnd &lt;-------+</span><br><span class="line">                     |                          |</span><br><span class="line">---------------------+-------------+----------+--------------------</span><br><span class="line">|      acked         | * * * * * * | # # # # #|   unable send</span><br><span class="line">---------------------+-------------+----------+--------------------</span><br><span class="line">                     ^             ^</span><br><span class="line">                     |               |</span><br><span class="line">                   sndUna        sndNxt</span><br><span class="line">***** in flight data</span><br><span class="line">##### able send date</span><br></pre></td></tr></table></figure><p>发送窗口主要维护这些变量，sndBufSize、sndBufUsed、sndUna、sndNxt 和 sndWnd。sndUna 表示是下一个未确认的序列号，sndNxt 是要发送的下一个段的序列号，sndWnd 是接受端通告的窗口大小。 首先是处理接收方的窗口通告，当收到报文时，一定会带接收窗口和确认号，此时先更新发送器的发送窗口大小为接收窗口大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write writes data to the endpoint's peer.</span></span><br><span class="line"><span class="comment">// 接收上层的数，通过tcp连接发送到对端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">Write</span><span class="params">(p tcpip.Payload, opts tcpip.WriteOptions)</span> <span class="params">(<span class="keyword">uintptr</span>, &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, *tcpip.Error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Linux completely ignores any address passed to sendto(2) for TCP sockets</span></span><br><span class="line">    <span class="comment">// (without the MSG_FASTOPEN flag). Corking is unimplemented, so opts.More</span></span><br><span class="line">    <span class="comment">// and opts.EndOfRecord are also ignored.</span></span><br><span class="line"></span><br><span class="line">    e.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> e.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The endpoint cannot be written to if it's not connected.</span></span><br><span class="line">    <span class="comment">// 判断tcp状态，必须已经建立了连接才能发送数据</span></span><br><span class="line">    <span class="keyword">if</span> e.state != stateConnected &#123;</span><br><span class="line">        <span class="keyword">switch</span> e.state &#123;</span><br><span class="line">        <span class="keyword">case</span> stateError:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, e.hardError</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, tcpip.ErrClosedForSend</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Nothing to do if the buffer is empty.</span></span><br><span class="line">    <span class="comment">// 检查负载的长度，如果为0，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> p.Size() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e.sndBufMu.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the connection has already been closed for sends.</span></span><br><span class="line">    <span class="keyword">if</span> e.sndClosed &#123;</span><br><span class="line">        e.sndBufMu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, tcpip.ErrClosedForSend</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against the limit.</span></span><br><span class="line">    <span class="comment">// tcp流量控制：未被占用发送缓存还剩多少，如果发送缓存已经被用光了，返回 ErrWouldBlock</span></span><br><span class="line">    avail := e.sndBufSize - e.sndBufUsed</span><br><span class="line">    <span class="keyword">if</span> avail &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        e.sndBufMu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, tcpip.ErrWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v, perr := p.Get(avail)</span><br><span class="line">    <span class="keyword">if</span> perr != <span class="literal">nil</span> &#123;</span><br><span class="line">        e.sndBufMu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, perr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> err *tcpip.Error</span><br><span class="line">    <span class="keyword">if</span> p.Size() &gt; avail &#123;</span><br><span class="line">        err = tcpip.ErrWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line">    l := <span class="built_in">len</span>(v)</span><br><span class="line">    s := newSegmentFromView(&amp;e.route, e.id, v)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add data to the send queue.</span></span><br><span class="line">    <span class="comment">// 插入发送队列</span></span><br><span class="line">    e.sndBufUsed += l</span><br><span class="line">    e.sndBufInQueue += seqnum.Size(l)</span><br><span class="line">    e.sndQueue.PushBack(s)</span><br><span class="line"></span><br><span class="line">    e.sndBufMu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据，最终会调用 sender sendData 来发送数据。</span></span><br><span class="line">    <span class="keyword">if</span> e.workMu.TryLock() &#123;</span><br><span class="line">        <span class="comment">// Do the work inline.</span></span><br><span class="line">        e.handleWrite()</span><br><span class="line">        e.workMu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Let the protocol goroutine do the work.</span></span><br><span class="line">        e.sndWaker.Assert()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">uintptr</span>(l), <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到tcp段时调用 handleRcvdSegment; 它负责更新与发送相关的状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sender)</span> <span class="title">handleRcvdSegment</span><span class="params">(seg *segment)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放当前窗口大小。</span></span><br><span class="line">    s.sndWnd = seg.window</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取确认号</span></span><br><span class="line">    ack := seg.ackNumber</span><br><span class="line">    <span class="comment">// 如果ack在最小未确认的seq和下一seg的seq之间</span></span><br><span class="line">    <span class="keyword">if</span> (ack - <span class="number">1</span>).InRange(s.sndUna, s.sndNxt) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Remove all acknowledged data from the write list.</span></span><br><span class="line">        acked := s.sndUna.Size(ack)</span><br><span class="line">        s.sndUna = ack</span><br><span class="line"></span><br><span class="line">        ackLeft := acked</span><br><span class="line">        originalOutstanding := s.outstanding</span><br><span class="line">        <span class="keyword">for</span> ackLeft &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// We use logicalLen here because we can have FIN</span></span><br><span class="line">            <span class="comment">// segments (which are always at the end of list) that</span></span><br><span class="line">            <span class="comment">// have no data, but do consume a sequence number.</span></span><br><span class="line">            seg := s.writeList.Front()</span><br><span class="line">            datalen := seg.logicalLen()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> datalen &gt; ackLeft &#123;</span><br><span class="line">                seg.data.TrimFront(<span class="keyword">int</span>(ackLeft))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> s.writeNext == seg &#123;</span><br><span class="line">                s.writeNext = seg.Next()</span><br><span class="line">            &#125;</span><br><span class="line">            s.writeList.Remove(seg)</span><br><span class="line">            s.outstanding--</span><br><span class="line">            seg.decRef()</span><br><span class="line">            ackLeft -= datalen</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the send buffer usage and notify potential waiters.</span></span><br><span class="line">        s.ep.updateSndBufferUsage(<span class="keyword">int</span>(acked))</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接受窗口的维护"><a href="#接受窗口的维护" class="headerlink" title="@接受窗口的维护"></a>@接受窗口的维护</h2><p>接收窗口主要维护这几个变量，rcvBufSize、rcvBufUsed、rcvNxt 和 rcvAcc，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tcp流量控制：计算未被占用的接收缓存大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">receiveBufferAvailable</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    e.rcvListMu.Lock()</span><br><span class="line">    size := e.rcvBufSize</span><br><span class="line">    used := e.rcvBufUsed</span><br><span class="line">    e.rcvListMu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We may use more bytes than the buffer size when the receive buffer</span></span><br><span class="line">    <span class="comment">// shrinks.</span></span><br><span class="line">    <span class="keyword">if</span> used &gt;= size &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size - used</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">receiveBufferSize</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    e.rcvListMu.Lock()</span><br><span class="line">    size := e.rcvBufSize</span><br><span class="line">    e.rcvListMu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zeroReceiveWindow 根据可用缓冲区的数量和接收窗口缩放，检查现在要宣布的接收窗口是否为零。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">zeroReceiveWindow</span><span class="params">(scale <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e.rcvBufUsed &gt;= e.rcvBufSize &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((e.rcvBufSize - e.rcvBufUsed) &gt;&gt; scale) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tcp流量控制：判断 segSeq 在窗口內</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *receiver)</span> <span class="title">acceptable</span><span class="params">(segSeq seqnum.Value, segLen seqnum.Size)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    rcvWnd := r.rcvNxt.Size(r.rcvAcc)</span><br><span class="line">    <span class="keyword">if</span> rcvWnd == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> segLen == <span class="number">0</span> &amp;&amp; segSeq == r.rcvNxt</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> segSeq.InWindow(r.rcvNxt, rcvWnd) ||</span><br><span class="line">        seqnum.Overlap(r.rcvNxt, rcvWnd, segSeq, segLen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tcp流量控制：当接收窗口从零增长到非零时，调用 nonZeroWindow;在这种情况下，</span></span><br><span class="line"><span class="comment">// 我们可能需要发送一个 ack，以便向对端表明它可以恢复发送数据。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *receiver)</span> <span class="title">nonZeroWindow</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (r.rcvAcc-r.rcvNxt)&gt;&gt;r.rcvWndScale != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// We never got around to announcing a zero window size, so we</span></span><br><span class="line">        <span class="comment">// don't need to immediately announce a nonzero one.</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Immediately send an ack.</span></span><br><span class="line">    r.ep.snd.sendAck()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从tcp的接收队列中读取数据，并从接收队列中删除已读数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">readLocked</span><span class="params">()</span> <span class="params">(buffer.View, *tcpip.Error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e.rcvBufUsed == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.rcvClosed || e.state != stateConnected &#123;</span><br><span class="line">            <span class="keyword">return</span> buffer.View&#123;&#125;, tcpip.ErrClosedForReceive</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.View&#123;&#125;, tcpip.ErrWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s := e.rcvList.Front()</span><br><span class="line">    views := s.data.Views()</span><br><span class="line">    v := views[s.viewToDeliver]</span><br><span class="line">    s.viewToDeliver++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s.viewToDeliver &gt;= <span class="built_in">len</span>(views) &#123;</span><br><span class="line">        e.rcvList.Remove(s)</span><br><span class="line">        s.decRef()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scale := e.rcv.rcvWndScale</span><br><span class="line">    <span class="comment">// tcp流量控制：检测接收窗口是否为0</span></span><br><span class="line">    wasZero := e.zeroReceiveWindow(scale)</span><br><span class="line">    e.rcvBufUsed -= <span class="built_in">len</span>(v)</span><br><span class="line">    <span class="comment">// 检测糊涂窗口，主动发送窗口不为0的通告给对方</span></span><br><span class="line">    <span class="keyword">if</span> wasZero &amp;&amp; !e.zeroReceiveWindow(scale) &#123;</span><br><span class="line">        e.notifyProtocolGoroutine(notifyNonZeroReceiveWindow)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接收端在给发送端回 ACK 中会汇报自己的 AdvertisedWindow，而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。&lt;br&gt;要明确的是滑动窗口分为两个窗口，接收窗口和发送窗口&lt;/p&gt;
&lt;h2 id=&quot;接受窗口&quot;&gt;&lt;a href=&quot;#接受窗口&quot; c
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>连接状态</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/4.%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/tcp/4.连接状态/</id>
    <published>2019-11-04T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fin-wait1-状态"><a href="#fin-wait1-状态" class="headerlink" title="@fin_wait1 状态"></a>@fin_wait1 状态</h2><p>四次挥手中，主动关闭方发送fin报文后，进入find_wait1状态</p><h2 id="close-wait"><a href="#close-wait" class="headerlink" title="@close_wait"></a>@close_wait</h2><p>四次挥手中，表示接受到对方fin报文，并发送对方ack回复，从此进入close_wait状态，等待发送对方fin报文</p><p>这中状态在开发中容易遇见，而且是灾难性的，因为这种状态会在网络中持续<code>2*MSL（Max Segment Lifetime，最大分段生存期，指一个 TCP 报文在 Internet 上的最长生存时间。每个具体的 TCP 协议实现都必须选择一个确定的 MSL 值，RFC 1122 建议是 2 分钟，但 BSD 传统实现采用了 30 秒，Linux 可以 cat /proc/sys/net/ipv4/tcp_fin_timeout 看到本机的这个值）</code>导致系统资源不会被释放</p><p>一般是由于服务端发生异常，导致未向客户端回复fin报文关闭连接进入time_wait状态</p><h2 id="fin-wait2-状态"><a href="#fin-wait2-状态" class="headerlink" title="@fin_wait2 状态"></a>@fin_wait2 状态</h2><p>四次挥手中，表示发送对方fin报文，并接收到对方ack回复，进入到fin_wait2状态</p><h2 id="time-wait-状态"><a href="#time-wait-状态" class="headerlink" title="@time_wait 状态"></a>@time_wait 状态</h2><p>四次挥手中，表示发送对方fin报文，并且受到ack报文和fin报文后进入time_wait状态</p><h2 id="last-ack-状态"><a href="#last-ack-状态" class="headerlink" title="@last_ack 状态"></a>@last_ack 状态</h2><p>刚好和close_wait相反，四次挥手中，最后一次报文迟迟没有回复，客户端没有回复服务端ack确认</p><p>LAST_ACK 当被动关闭的一方在发送 FIN 报文后，等待对方的 ACK 报文的时候，就处于 LAST_ACK 状态。当收到对方的 ACK 报文后，也就可以进入到 CLOSED 可用状态了。</p><h2 id="closing-状态"><a href="#closing-状态" class="headerlink" title="@closing 状态"></a>@closing 状态</h2><p>在四次挥手中，一般不会出现closing状态，因为主动关闭方发送Fin报文后，一般会先收到ack报文，随后在收到fin报文则进入time_wait状态</p><p>但是如果双方同时发送fin报文断开连接的话，就会出现fin报文先到，而ack报文在后面，也就是导致fin_wait2的状态直接进入closing状态</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;fin-wait1-状态&quot;&gt;&lt;a href=&quot;#fin-wait1-状态&quot; class=&quot;headerlink&quot; title=&quot;@fin_wait1 状态&quot;&gt;&lt;/a&gt;@fin_wait1 状态&lt;/h2&gt;&lt;p&gt;四次挥手中，主动关闭方发送fin报文后，进入find_w
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>校验和计算</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/udp/2.%E6%A3%80%E9%AA%8C%E5%92%8C%E8%AE%A1%E7%AE%97/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/udp/2.检验和计算/</id>
    <published>2019-11-02T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<p>UDP 计算校验和的方法和 IP 数据报首部校验和的方法相似。不同的是：IP 数据报校验和只校验 IP 数据报的首部，但 UDP 的校验和是把首部和数据部分一起都检验。</p><p>UDP 的校验和需要计算 UDP 首部加数据荷载部分，但也需要加上 UDP 伪首部。这个伪首部指，源地址、目的地址、UDP 数据长度、协议类型（0x11），协议类型就一个字节，但需要补一个字节的 0x0，构成 12 个字节。伪首部+UDP 首部+数据一起计算校验和。</p><p>UDP 检验和的计算方法是：<br>按每 16 位求和得出一个 32 位的数；<br>如果这个 32 位的数，高 16 位不为 0，则高 16 位加低 16 位再得到一个 32 位的数；<br>重复第 2 步直到高 16 位为 0，将低 16 位取反，得到校验和。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UDP 计算校验和的方法和 IP 数据报首部校验和的方法相似。不同的是：IP 数据报校验和只校验 IP 数据报的首部，但 UDP 的校验和是把首部和数据部分一起都检验。&lt;/p&gt;
&lt;p&gt;UDP 的校验和需要计算 UDP 首部加数据荷载部分，但也需要加上 UDP 伪首部。这个伪
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="udp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/udp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
      <category term="transport" scheme="http://blog.huido.site/tags/transport/"/>
    
  </entry>
  
  <entry>
    <title>协议分层模型</title>
    <link href="http://blog.huido.site/wiki/net-protocol/1.%E5%89%8D%E8%A8%80/2.%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>http://blog.huido.site/wiki/net-protocol/1.前言/2.协议分层模型/</id>
    <published>2019-11-02T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="协议运作"><a href="#协议运作" class="headerlink" title="协议运作"></a>协议运作</h2><p>其实就是将对应协议之间关联到协议都要先注册。在分流器中统一管理，数据包到达后一层一层解刨在转发到对应到业务层处理</p><ol><li>例如监听tcp服务，需要注册 <code>ipv4</code> <code>arp</code> <code>tcp</code> 等。</li><li>链路层 收到网卡原始数据后，通过分流器定位到ipv4协议，然后将数据包转发到ipv4协议处理</li><li><p>网络层ipv4层接受到数据后，在通过分流器找到传输层协议，将数据发往传输层</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.dispatcher.DeliverTransportPacket(r, p, vv)</span><br></pre></td></tr></table></figure></li><li><p>注册到分流器后，数据包到来，后一层一层转发到传输层tcp处理</p></li></ol><h2 id="分流器"><a href="#分流器" class="headerlink" title="分流器"></a>分流器</h2><p>也就是每个协议层之间当协作转发关系。也就是分发网络协议到对应到协议栈处理<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/ 网络层协议号和传输层协议号的组合，当作分流器的key值</span><br><span class="line"><span class="keyword">type</span> protocolIDs <span class="keyword">struct</span> &#123;</span><br><span class="line">    network   tcpip.NetworkProtocolNumber</span><br><span class="line">    transport tcpip.TransportProtocolNumber</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// transportEndpoints 管理给定协议的所有端点。</span></span><br><span class="line"><span class="keyword">type</span> transportEndpoints <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu        sync.RWMutex</span><br><span class="line">    endpoints <span class="keyword">map</span>[TransportEndpointID]TransportEndpoint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// transportDemuxer 解复用针对传输端点的数据包（即，在它们被网络层解析之后）。</span></span><br><span class="line"><span class="comment">// 它执行两级解复用：首先基于网络层协议和传输协议，然后基于端点ID。</span></span><br><span class="line"><span class="keyword">type</span> transportDemuxer <span class="keyword">struct</span> &#123;</span><br><span class="line">    protocol <span class="keyword">map</span>[protocolIDs]*transportEndpoints</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到分流器是个两级结构，第一级是<code>protocolIDs</code>，它是网络层协议号和传输层协议号的组合。第二级是个传输层 <code>ID-TransportEndpointID</code>，表示传输层端的四元组：源 IP、源端口、目的 IP、目的端口。分流器执行两级解复用，首先基于网络层协议和传输协议，然后基于端点 ID。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;协议运作&quot;&gt;&lt;a href=&quot;#协议运作&quot; class=&quot;headerlink&quot; title=&quot;协议运作&quot;&gt;&lt;/a&gt;协议运作&lt;/h2&gt;&lt;p&gt;其实就是将对应协议之间关联到协议都要先注册。在分流器中统一管理，数据包到达后一层一层解刨在转发到对应到业务层处理&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="1.前言" scheme="http://blog.huido.site/categories/net-protocol/1-%E5%89%8D%E8%A8%80/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
  </entry>
  
  <entry>
    <title>以太网协议</title>
    <link href="http://blog.huido.site/wiki/net-protocol/5.%E9%93%BE%E8%B7%AF%E5%B1%82/1.%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%8D%8F%E8%AE%AE/"/>
    <id>http://blog.huido.site/wiki/net-protocol/5.链路层/1.以太网协议/</id>
    <published>2019-10-31T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以太网头部"><a href="#以太网头部" class="headerlink" title="以太网头部"></a>以太网头部</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0               1               2               3               4               5               6</span><br><span class="line">0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                          DESTINATION      MAC    6字节目的mac地址                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                          ORIGINALSRC      MAC    6字节源 mac地址                                |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|       2 字节 网络层协议类型      |     46 - 1500 字节（ip包头 + 传输层包头 + 应用层数据）              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>目的mac地址:<code>6 字节 物理地址</code></p><p>源 mac地址:<code>6 字节 物理地址</code></p><p>数据包协议类型: <code>为0x8000时为 IPv4 协议包，为0x8060时，后面为 ARP 协议包。</code></p><p>数据包     :网卡输送能力上限 <code>MTU</code>(1500字节),对网络层 ip协议对封装，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;以太网头部&quot;&gt;&lt;a href=&quot;#以太网头部&quot; class=&quot;headerlink&quot; title=&quot;以太网头部&quot;&gt;&lt;/a&gt;以太网头部&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="5.链路层" scheme="http://blog.huido.site/categories/net-protocol/5-%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="eth" scheme="http://blog.huido.site/tags/eth/"/>
    
  </entry>
  
  <entry>
    <title>tool</title>
    <link href="http://blog.huido.site/wiki/net-protocol/6.%E7%89%A9%E7%90%86%E5%B1%82/tool/"/>
    <id>http://blog.huido.site/wiki/net-protocol/6.物理层/tool/</id>
    <published>2019-10-31T13:28:59.000Z</published>
    <updated>2019-12-11T09:16:14.369Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟网卡tap启动关闭到工具</p><h2 id="up"><a href="#up" class="headerlink" title="up"></a>up</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd path/tool</span><br><span class="line">go build up.go</span><br><span class="line">sudo ./up</span><br></pre></td></tr></table></figure><h2 id="down"><a href="#down" class="headerlink" title="down"></a>down</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd path/tool</span><br><span class="line">go build down.go</span><br><span class="line">sudo ./down</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虚拟网卡tap启动关闭到工具&lt;/p&gt;
&lt;h2 id=&quot;up&quot;&gt;&lt;a href=&quot;#up&quot; class=&quot;headerlink&quot; title=&quot;up&quot;&gt;&lt;/a&gt;up&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="6.物理层" scheme="http://blog.huido.site/categories/net-protocol/6-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="eth" scheme="http://blog.huido.site/tags/eth/"/>
    
      <category term="tap" scheme="http://blog.huido.site/tags/tap/"/>
    
      <category term="tool" scheme="http://blog.huido.site/tags/tool/"/>
    
  </entry>
  
</feed>
