<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Brewlin&#39;s Wiki</title>
  
  <subtitle>found everthing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.huido.site/"/>
  <updated>2019-11-04T14:13:34.427Z</updated>
  <id>http://blog.huido.site/</id>
  
  <author>
    <name>brewlin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>连接状态</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/4.%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/tcp/4.连接状态/</id>
    <published>2019-11-04T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fin-wait1-状态"><a href="#fin-wait1-状态" class="headerlink" title="@fin_wait1 状态"></a>@fin_wait1 状态</h2><p>四次挥手中，主动关闭方发送fin报文后，进入find_wait1状态</p><h2 id="close-wait"><a href="#close-wait" class="headerlink" title="@close_wait"></a>@close_wait</h2><p>四次挥手中，表示接受到对方fin报文，并发送对方ack回复，从此进入close_wait状态，等待发送对方fin报文</p><p>这中状态在开发中容易遇见，而且是灾难性的，因为这种状态会在网络中持续<code>2*MSL（Max Segment Lifetime，最大分段生存期，指一个 TCP 报文在 Internet 上的最长生存时间。每个具体的 TCP 协议实现都必须选择一个确定的 MSL 值，RFC 1122 建议是 2 分钟，但 BSD 传统实现采用了 30 秒，Linux 可以 cat /proc/sys/net/ipv4/tcp_fin_timeout 看到本机的这个值）</code>导致系统资源不会被释放</p><p>一般是由于服务端发生异常，导致未向客户端回复fin报文关闭连接进入time_wait状态</p><h2 id="fin-wait2-状态"><a href="#fin-wait2-状态" class="headerlink" title="@fin_wait2 状态"></a>@fin_wait2 状态</h2><p>四次挥手中，表示发送对方fin报文，并接收到对方ack回复，进入到fin_wait2状态</p><h2 id="time-wait-状态"><a href="#time-wait-状态" class="headerlink" title="@time_wait 状态"></a>@time_wait 状态</h2><p>四次挥手中，表示发送对方fin报文，并且受到ack报文和fin报文后进入time_wait状态</p><h2 id="last-ack-状态"><a href="#last-ack-状态" class="headerlink" title="@last_ack 状态"></a>@last_ack 状态</h2><p>刚好和close_wait相反，四次挥手中，最后一次报文迟迟没有回复，客户端没有回复服务端ack确认</p><p>LAST_ACK 当被动关闭的一方在发送 FIN 报文后，等待对方的 ACK 报文的时候，就处于 LAST_ACK 状态。当收到对方的 ACK 报文后，也就可以进入到 CLOSED 可用状态了。</p><h2 id="closing-状态"><a href="#closing-状态" class="headerlink" title="@closing 状态"></a>@closing 状态</h2><p>在四次挥手中，一般不会出现closing状态，因为主动关闭方发送Fin报文后，一般会先收到ack报文，随后在收到fin报文则进入time_wait状态</p><p>但是如果双方同时发送fin报文断开连接的话，就会出现fin报文先到，而ack报文在后面，也就是导致fin_wait2的状态直接进入closing状态</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;fin-wait1-状态&quot;&gt;&lt;a href=&quot;#fin-wait1-状态&quot; class=&quot;headerlink&quot; title=&quot;@fin_wait1 状态&quot;&gt;&lt;/a&gt;@fin_wait1 状态&lt;/h2&gt;&lt;p&gt;四次挥手中，主动关闭方发送fin报文后，进入find_w
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>协议分层模型</title>
    <link href="http://blog.huido.site/wiki/net-protocol/1.%E5%89%8D%E8%A8%80/2.%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>http://blog.huido.site/wiki/net-protocol/1.前言/2.协议分层模型/</id>
    <published>2019-11-02T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="协议运作"><a href="#协议运作" class="headerlink" title="协议运作"></a>协议运作</h2><p>其实就是将对应协议之间关联到协议都要先注册。在分流器中统一管理，数据包到达后一层一层解刨在转发到对应到业务层处理</p><ol><li>例如监听tcp服务，需要注册 <code>ipv4</code> <code>arp</code> <code>tcp</code> 等。</li><li>链路层 收到网卡原始数据后，通过分流器定位到ipv4协议，然后将数据包转发到ipv4协议处理</li><li><p>网络层ipv4层接受到数据后，在通过分流器找到传输层协议，将数据发往传输层</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.dispatcher.DeliverTransportPacket(r, p, vv)</span><br></pre></td></tr></table></figure></li><li><p>注册到分流器后，数据包到来，后一层一层转发到传输层tcp处理</p></li></ol><h2 id="分流器"><a href="#分流器" class="headerlink" title="分流器"></a>分流器</h2><p>也就是每个协议层之间当协作转发关系。也就是分发网络协议到对应到协议栈处理<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/ 网络层协议号和传输层协议号的组合，当作分流器的key值</span><br><span class="line"><span class="keyword">type</span> protocolIDs <span class="keyword">struct</span> &#123;</span><br><span class="line">    network   tcpip.NetworkProtocolNumber</span><br><span class="line">    transport tcpip.TransportProtocolNumber</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// transportEndpoints 管理给定协议的所有端点。</span></span><br><span class="line"><span class="keyword">type</span> transportEndpoints <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu        sync.RWMutex</span><br><span class="line">    endpoints <span class="keyword">map</span>[TransportEndpointID]TransportEndpoint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// transportDemuxer 解复用针对传输端点的数据包（即，在它们被网络层解析之后）。</span></span><br><span class="line"><span class="comment">// 它执行两级解复用：首先基于网络层协议和传输协议，然后基于端点ID。</span></span><br><span class="line"><span class="keyword">type</span> transportDemuxer <span class="keyword">struct</span> &#123;</span><br><span class="line">    protocol <span class="keyword">map</span>[protocolIDs]*transportEndpoints</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到分流器是个两级结构，第一级是<code>protocolIDs</code>，它是网络层协议号和传输层协议号的组合。第二级是个传输层 <code>ID-TransportEndpointID</code>，表示传输层端的四元组：源 IP、源端口、目的 IP、目的端口。分流器执行两级解复用，首先基于网络层协议和传输协议，然后基于端点 ID。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;协议运作&quot;&gt;&lt;a href=&quot;#协议运作&quot; class=&quot;headerlink&quot; title=&quot;协议运作&quot;&gt;&lt;/a&gt;协议运作&lt;/h2&gt;&lt;p&gt;其实就是将对应协议之间关联到协议都要先注册。在分流器中统一管理，数据包到达后一层一层解刨在转发到对应到业务层处理&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="1.前言" scheme="http://blog.huido.site/categories/net-protocol/1-%E5%89%8D%E8%A8%80/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
  </entry>
  
  <entry>
    <title>校验和计算</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/udp/2.%E6%A3%80%E9%AA%8C%E5%92%8C%E8%AE%A1%E7%AE%97/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/udp/2.检验和计算/</id>
    <published>2019-11-02T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<p>UDP 计算校验和的方法和 IP 数据报首部校验和的方法相似。不同的是：IP 数据报校验和只校验 IP 数据报的首部，但 UDP 的校验和是把首部和数据部分一起都检验。</p><p>UDP 的校验和需要计算 UDP 首部加数据荷载部分，但也需要加上 UDP 伪首部。这个伪首部指，源地址、目的地址、UDP 数据长度、协议类型（0x11），协议类型就一个字节，但需要补一个字节的 0x0，构成 12 个字节。伪首部+UDP 首部+数据一起计算校验和。</p><p>UDP 检验和的计算方法是：<br>按每 16 位求和得出一个 32 位的数；<br>如果这个 32 位的数，高 16 位不为 0，则高 16 位加低 16 位再得到一个 32 位的数；<br>重复第 2 步直到高 16 位为 0，将低 16 位取反，得到校验和。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UDP 计算校验和的方法和 IP 数据报首部校验和的方法相似。不同的是：IP 数据报校验和只校验 IP 数据报的首部，但 UDP 的校验和是把首部和数据部分一起都检验。&lt;/p&gt;
&lt;p&gt;UDP 的校验和需要计算 UDP 首部加数据荷载部分，但也需要加上 UDP 伪首部。这个伪
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="udp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/udp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
      <category term="transport" scheme="http://blog.huido.site/tags/transport/"/>
    
  </entry>
  
  <entry>
    <title>以太网协议</title>
    <link href="http://blog.huido.site/wiki/net-protocol/5.%E9%93%BE%E8%B7%AF%E5%B1%82/1.%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%8D%8F%E8%AE%AE/"/>
    <id>http://blog.huido.site/wiki/net-protocol/5.链路层/1.以太网协议/</id>
    <published>2019-10-31T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以太网头部"><a href="#以太网头部" class="headerlink" title="以太网头部"></a>以太网头部</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0               1               2               3               4               5               6</span><br><span class="line">0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                          DESTINATION      MAC    6字节目的mac地址                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                          ORIGINALSRC      MAC    6字节源 mac地址                                |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|       2 字节 网络层协议类型      |     46 - 1500 字节（ip包头 + 传输层包头 + 应用层数据）              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>目的mac地址:<code>6 字节 物理地址</code></p><p>源 mac地址:<code>6 字节 物理地址</code></p><p>数据包协议类型: <code>为0x8000时为 IPv4 协议包，为0x8060时，后面为 ARP 协议包。</code></p><p>数据包     :网卡输送能力上限 <code>MTU</code>(1500字节),对网络层 ip协议对封装，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;以太网头部&quot;&gt;&lt;a href=&quot;#以太网头部&quot; class=&quot;headerlink&quot; title=&quot;以太网头部&quot;&gt;&lt;/a&gt;以太网头部&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="5.链路层" scheme="http://blog.huido.site/categories/net-protocol/5-%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="eth" scheme="http://blog.huido.site/tags/eth/"/>
    
  </entry>
  
  <entry>
    <title>业务说明</title>
    <link href="http://blog.huido.site/wiki/swoft-im/%E5%89%8D%E8%A8%80/%E4%B8%9A%E5%8A%A1%E8%AF%B4%E6%98%8E/"/>
    <id>http://blog.huido.site/wiki/swoft-im/前言/业务说明/</id>
    <published>2019-10-30T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;流程&quot;&gt;&lt;a href=&quot;#流程&quot; class=&quot;headerlink&quot; title=&quot;流程&quot;&gt;&lt;/a&gt;流程&lt;/h2&gt;&lt;h2 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; title=&quot;架构&quot;&gt;&lt;/a&gt;架构&lt;/h2&gt;
      
    
    </summary>
    
      <category term="swoft-im" scheme="http://blog.huido.site/categories/swoft-im/"/>
    
      <category term="前言" scheme="http://blog.huido.site/categories/swoft-im/%E5%89%8D%E8%A8%80/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
  </entry>
  
  <entry>
    <title>微服务应用</title>
    <link href="http://blog.huido.site/wiki/swoft-im/index/"/>
    <id>http://blog.huido.site/wiki/swoft-im/index/</id>
    <published>2019-10-28T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Swoft-cloud微服务架构-Im通讯平台"><a href="#基于Swoft-cloud微服务架构-Im通讯平台" class="headerlink" title="基于Swoft-cloud微服务架构-Im通讯平台"></a>基于Swoft-cloud微服务架构-Im通讯平台</h1><h2 id="概述"><a href="#概述" class="headerlink" title="@概述"></a>@概述</h2><ul><li>对swoole-im进行服务拆分，进行微服务架构(<a href="https://www.github.com/brewlin/swoole-im.git">https://www.github.com/brewlin/swoole-im.git</a>)</li><li>基于Swoft-cloud 进行服务化治理服务治理、熔断器、服务降级、Rpc调用、服务网关、<br>Cosul服务注册与发现、Mysql连接池、Redis连接池、异步任务、websocket推送</li><li>底层采用Swoole通讯引擎,多进程、异步任务，开发模式：Aop，依赖注入，Bean容器，全注解</li><li>服务间配置独立，使用composer进行依赖管理，进行composer组件化开发，公用的Rpc接口封<br>装为独立composer包。<ul><li>拆分有群组Rpc服务，聊天日志Rpc服务，用户基础Rpc服务，消息处理服务</li><li>Httpserver网关api服务，websocket服务</li></ul></li><li>请使用swoole扩展2.1.3+ 以及<code>php 7.1</code>!</li><li>快速开始<ul><li>针对每个服务使用composer更新依赖<code>make install</code></li><li>开启所有服务 <code>make start</code></li><li>关闭所有服务 <code>make stop</code></li></ul></li><li>docker启动<ul><li><code>docker-compose up</code></li></ul></li><li>演示地址 <ul><li><a href="http://chat.huido.site">http://chat.huido.site</a>  (可以注册) </li><li><a href="http://cloud.huido.site">http://cloud.huido.site</a> (soon..)</li></ul></li></ul><h2 id="gateway-api-cloud-soon"><a href="#gateway-api-cloud-soon" class="headerlink" title="@gateway-api-cloud (soon)"></a>@gateway-api-cloud (<code>soon</code>)</h2><ul><li>新增im-cloud版本，接入<a href="https://github.com/brewlin/im-cloud"><code>im-cloud</code></a>分布式推送中间件作为推送中心。</li><li>新网关中心可替代原有的网关服务，接入im-cloud分布式推送服务</li><li><code>im-cloud</code> 基于swoole原生开发的分布式中间件</li><li>done soon..</li></ul><h2 id="架构图"><a href="#架构图" class="headerlink" title="@架构图"></a>@架构图</h2><h3 id="服务依赖"><a href="#服务依赖" class="headerlink" title="服务依赖"></a>服务依赖</h3><p><img src="./resource/services.png" alt=""></p><h3 id="前端服务"><a href="#前端服务" class="headerlink" title="前端服务"></a>前端服务</h3><p><img src="./resource/api.png" alt=""></p><h3 id="服务处理"><a href="#服务处理" class="headerlink" title="服务处理"></a>服务处理</h3><p><img src="./resource/swoole.png" alt=""></p><h1 id="服务开发"><a href="#服务开发" class="headerlink" title="服务开发"></a>服务开发</h1><h3 id="Rpc-接口依赖"><a href="#Rpc-接口依赖" class="headerlink" title="Rpc 接口依赖"></a>Rpc 接口依赖</h3><pre><code>&quot;repositories&quot;: {    &quot;0&quot;:{        &quot;type&quot;:&quot;vcs&quot;,//git源        &quot;url&quot;:&quot;http://www.github.com/brewlin/service-components&quot; //公用composer包    },    &quot;packagist&quot;: {        &quot;type&quot;: &quot;composer&quot;,        &quot;url&quot;: &quot;https://packagist.laravel-china.org&quot;    }}</code></pre><h3 id="Gateway-Api-amp-amp-Websocket-中心网关服务"><a href="#Gateway-Api-amp-amp-Websocket-中心网关服务" class="headerlink" title="Gateway-Api &amp;&amp; Websocket 中心网关服务"></a>Gateway-Api &amp;&amp; Websocket 中心网关服务</h3><pre><code>接受web端webocket长连接通讯、api请求.处理基础数据，对外中心api网关.服务调用方(Rpc 调用),调用群组服务、用户基础服务等`</code></pre><ul><li>依赖: <code>user-service</code>、<code>group-service</code>、<code>services-components</code>、<code>redis-service</code>、<code>group-service</code>、<code>msg-service</code></li><li>配置: <code>worker</code>:2，<code>task_worker</code>:2,<code>port</code>:8090,<code>熔断器</code>，<code>服务降级</code>,Rpc<code>连接池</code>，<code>useProvider</code>:false,</li><li><p>服务启动：</p><p>  <code>cd gateway-api/</code> </p><p>  <code>composer install</code>更新依赖</p><p>  <code>php bin/swoft ws:start</code> –d可选守护进程模式</p></li></ul><h3 id="Redis-缓存处理服务"><a href="#Redis-缓存处理服务" class="headerlink" title="Redis 缓存处理服务"></a>Redis 缓存处理服务</h3><pre><code>处理用用户的业务缓存，使用swoft redis连接池独立服务处理用户群组缓存、好友聊天缓存</code></pre><ul><li>依赖:<code>services-compoents</code>、<code>swoft-cloud*</code></li><li><p>服务启动：</p><p>  <code>cd/redis-service</code> </p><p>  <code>composer install</code>更新依赖</p><p>  <code>php bin/swoft rpc:start</code> –d可选守护进程模式<br>配置: <code>worker</code>:2，<code>task_worker</code>:2,<code>port</code>:8091,SyncRedis<code>连接池</code>，<code>useProvider</code>:false,</p></li></ul><h3 id="Group-群组数据处理服务"><a href="#Group-群组数据处理服务" class="headerlink" title="Group 群组数据处理服务"></a>Group 群组数据处理服务</h3><pre><code>处理用群组基础信息，群组聊天等业务处理</code></pre><ul><li>依赖:<code>services-compoents</code>、<code>swoft-cloud*</code>、<code>redis-service</code></li><li><p>服务启动：</p><p>  <code>cd/group-service</code> </p><p>  <code>composer install</code>更新依赖</p><p>  <code>php bin/swoft rpc:start</code> –d可选守护进程模式<br>配置: <code>worker</code>:2，<code>task_worker</code>:2,<code>port</code>:8092,SyncRedis<code>连接池</code>，<code>useProvider</code>:false,mysql<code>连接池</code></p></li></ul><h3 id="Msg-消息处理服务"><a href="#Msg-消息处理服务" class="headerlink" title="Msg 消息处理服务"></a>Msg 消息处理服务</h3><pre><code>处理系统消息，收发请求消息存储</code></pre><ul><li>依赖:<code>services-compoents</code>、<code>swoft-cloud*</code></li><li><p>服务启动：</p><p>  <code>cd ./msg-service</code> </p><p>  <code>composer install</code>更新依赖</p><p>  <code>php bin/swoft rpc:start</code> –d可选守护进程模式<br>配置: <code>worker</code>:2，<code>task_worker</code>:2,<code>port</code>:8093,<code>useProvider</code>:false,mysql<code>连接池</code></p></li></ul><h3 id="User-用户中心服务"><a href="#User-用户中心服务" class="headerlink" title="User 用户中心服务"></a>User 用户中心服务</h3><pre><code>用户基础信息处理用户好友聊天处理用户业务功能封装</code></pre><ul><li>依赖:<code>services-compoents</code>、<code>swoft-cloud*</code>、<code>redis-service</code>,<code>msg-service</code>,<code>group-service</code></li><li><p>服务启动：</p><p>  <code>cd ./user-service</code> </p><p>  <code>composer install</code>更新依赖</p><p>  <code>php bin/swoft rpc:start</code> –d可选守护进程模式<br>配置: <code>worker</code>:2，<code>task_worker</code>:2,<code>port</code>:8094,<code>useProvider</code>:false,mysql<code>连接池</code></p><h3 id="启动和服务进程预览"><a href="#启动和服务进程预览" class="headerlink" title="启动和服务进程预览"></a>启动和服务进程预览</h3><p><img src="./resource/start.png" alt=""><br><img src="./resource/process.png" alt=""></p><h1 id="开发进度-amp-amp-实现功能"><a href="#开发进度-amp-amp-实现功能" class="headerlink" title="开发进度 &amp;&amp; 实现功能"></a>开发进度 &amp;&amp; 实现功能</h1></li><li>好友单聊</li><li>添加好友</li><li>websocket token 机制</li><li>好友右键菜单操作功能<ul><li>发送好友信息</li><li>查看好友资料</li><li>查看好友聊天记录</li><li>好友备注功能</li><li>移动好友分组</li><li>删除好友功能</li></ul></li><li>发现中心<ul><li>搜索好友</li><li>推荐好友 添加好友</li><li>创建群</li></ul></li><li>消息中心<ul><li>好友离线上线通知,好友上线离线消息推送</li><li>系统消息推送,好友申请处理操作</li></ul></li></ul><h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><ul><li>消息处理中心，消息盒子<br><img src="https://github.com/Lxido/swoole-im/blob/master/img/QQ%E6%88%AA%E5%9B%BE20190106210353.png?raw=true" alt=""></li><li>发现中心，推荐好友群，搜索好友群，创建群<br><img src="https://github.com/Lxido/swoole-im/blob/master/img/QQ%E6%88%AA%E5%9B%BE20190106210451.png?raw=true" alt=""></li><li>单聊，群聊 聊天界面，聊天记录<br><img src="https://github.com/Lxido/swoole-im/blob/master/img/QQ%E6%88%AA%E5%9B%BE20190106210543.png?raw=true" alt=""></li><li>主面板<br><img src="https://github.com/Lxido/swoole-im/blob/master/img/QQ%E6%88%AA%E5%9B%BE20190106210553.png?raw=true" alt=""></li><li>右键功能（好友管理，分组管理，群管理）<br><img src="https://github.com/Lxido/swoole-im/blob/master/img/QQ%E6%88%AA%E5%9B%BE20190106212344.png?raw=true" alt=""></li><li>整体预览图<br><img src="https://github.com/Lxido/swoole-im/blob/master/img/QQ%E6%88%AA%E5%9B%BE20190106210500.png?raw=true" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于Swoft-cloud微服务架构-Im通讯平台&quot;&gt;&lt;a href=&quot;#基于Swoft-cloud微服务架构-Im通讯平台&quot; class=&quot;headerlink&quot; title=&quot;基于Swoft-cloud微服务架构-Im通讯平台&quot;&gt;&lt;/a&gt;基于Swoft-clo
      
    
    </summary>
    
      <category term="swoft-im" scheme="http://blog.huido.site/categories/swoft-im/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="im" scheme="http://blog.huido.site/tags/im/"/>
    
  </entry>
  
  <entry>
    <title>连接池实现</title>
    <link href="http://blog.huido.site/wiki/im-cloud/4.%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/1.%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.huido.site/wiki/im-cloud/4.组件实现/1.连接池实现/</id>
    <published>2019-10-28T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>基于swoole channel实现，channel大小默认为10,每次获取连接时判断如果连接池为空，则新建连接，并在结束时放回channel中，放回时注意如果大于channel则销毁该连接，同理如果获取连接时小于5，也需要新建连接。只有 满足<code>pool &gt;=5</code> 才从channel中获取该连接。放回时 满足 <code>pool &lt; 10&amp;</code>。而且需要检查该连接是否断开</p><p><code>pkg/core/src/pool/poolfactory.php</code>:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $option</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">getPool</span><span class="params">(string $name,$option = <span class="string">""</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $channelName = $option.$name;</span><br><span class="line">    <span class="comment">//检查当前进程 全局静态池里 是否存在该连接池</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;pools[$channelName]) || <span class="keyword">$this</span>-&gt;pools[$channelName] === <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;pools[$channelName] = <span class="keyword">new</span> Channel(<span class="keyword">$this</span>-&gt;maxActive);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查连接池里 可用连接是否小于最小连接，如果小于则走新建逻辑，最后在回归池里</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;pools[$channelName]-&gt;length() &lt; <span class="keyword">$this</span>-&gt;minActive)&#123;</span><br><span class="line">        <span class="keyword">return</span> container()-&gt;get($name)-&gt;create($option);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取连接，pop一个连接</span></span><br><span class="line">    $connection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">$this</span>-&gt;pools[$channelName]-&gt;isEmpty())&#123;</span><br><span class="line">        $connection = <span class="keyword">$this</span>-&gt;pools[$channelName]-&gt;pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接返回</span></span><br><span class="line">    <span class="keyword">if</span>($connection !== <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> $connection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//channel is empty or not reach maxActive return new create</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;pools[$channelName]-&gt;length() &lt; <span class="keyword">$this</span>-&gt;maxActive)&#123;</span><br><span class="line">        <span class="keyword">return</span> container()-&gt;get($name)-&gt;create($option);</span><br><span class="line">    &#125;</span><br><span class="line">    $connection = <span class="keyword">$this</span>-&gt;pools[$channelName]-&gt;pop(<span class="keyword">$this</span>-&gt;maxWaitTime);</span><br><span class="line">    <span class="keyword">if</span>($connection === <span class="keyword">false</span>)&#123;</span><br><span class="line">        CLog::error(<span class="string">"channel pop timeout name:$name"</span>);</span><br><span class="line">        <span class="keyword">return</span> container()-&gt;get($name)-&gt;create($option);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h2 id=&quot;实现机制&quot;&gt;&lt;a href=&quot;#实现机制&quot; class=&quot;headerlink&quot; title=&quot;实现机制&quot;&gt;&lt;/a&gt;实现机制&lt;/h
      
    
    </summary>
    
      <category term="im-cloud" scheme="http://blog.huido.site/categories/im-cloud/"/>
    
      <category term="4.组件实现" scheme="http://blog.huido.site/categories/im-cloud/4-%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="rabbitmq" scheme="http://blog.huido.site/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>服务发现</title>
    <link href="http://blog.huido.site/wiki/im-cloud/3.%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    <id>http://blog.huido.site/wiki/im-cloud/3.应用实现/2.服务发现/</id>
    <published>2019-10-28T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注册服务"><a href="#注册服务" class="headerlink" title="@注册服务"></a>@注册服务</h2><p>file:<code>app/Process/Discovery.php</code><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义子进程 执行入口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Process $process</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">(Process $process)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        swoole_set_process_name(sprintf(<span class="string">'php-im-cloud discovery process (%s)'</span>,ROOT));</span><br><span class="line">        $registerStatus = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!$registerStatus)&#123;</span><br><span class="line">            $registerStatus = provider()-&gt;select()-&gt;registerService();</span><br><span class="line">            <span class="keyword">if</span>(!$registerStatus)&#123;</span><br><span class="line">                CLog::error(<span class="string">"consul register false sleep 1 sec to reregiseter"</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $config = config(<span class="string">"discovery"</span>);</span><br><span class="line">        $discovery = $config[<span class="string">"consul"</span>][<span class="string">"discovery"</span>][<span class="string">"name"</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            $services = provider()-&gt;select()-&gt;getServiceList($discovery);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">empty</span>($services))&#123;</span><br><span class="line">                Log::error(<span class="string">"not find any instance node:$discovery"</span>);</span><br><span class="line">                LogicClient::updateService([]);</span><br><span class="line">                <span class="keyword">goto</span> SLEEP;</span><br><span class="line">            &#125;</span><br><span class="line">            LogicClient::updateService($services);</span><br><span class="line">SLEEP:</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>1.注册服务 注册失败后重试</li><li>2.发现服务 进行更新本地服务列表</li></ul><h2 id="更新服务"><a href="#更新服务" class="headerlink" title="@更新服务"></a>@更新服务</h2><p>发现服务到频率越高表示同步到时间约精确，这里会有一个问题，php到array数组是<code>非线程安全</code>更新和读取都在进行，并发是会很大几率出现错误，单纯都加锁反而会降低性能</p><p><code>swoole table</code> 应运而生，底层是原子操作，多进程共享变量，完整的解决来问题</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class LogicClient</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Bean</span>()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> App\Lib</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogicClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * servicelist</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> MemoryTable</span></span><br><span class="line"><span class="comment">     * [</span></span><br><span class="line"><span class="comment">     *   ip =&gt; [addr =&gt; ip]</span></span><br><span class="line"><span class="comment">     *   "127.0.0.1:9500" =&gt; ["Address" =&gt; "127.0.0.1","Port" =&gt; "9500"]</span></span><br><span class="line"><span class="comment">     * ]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $table = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LogicClient constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $memorySize = (int)env(<span class="string">"MEMORY_TABLE"</span>,<span class="number">1000</span>);</span><br><span class="line">        $column = [</span><br><span class="line">            <span class="string">"Address"</span> =&gt; [Type::String,<span class="number">20</span>],</span><br><span class="line">            <span class="string">"Port"</span>    =&gt; [Type::String,<span class="number">10</span>],</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">self</span>::$table = Table::create($memorySize,$column);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个可用的grpc 客户端 和logic 节点进行交互</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed|null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getLogicClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">self</span>::$table-&gt;count() == <span class="number">0</span>)&#123;</span><br><span class="line">            Log::error(<span class="string">"not logic node find"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $node = \bean(RandomBalancer::class)-&gt;select(<span class="keyword">self</span>::$table-&gt;getKeys());</span><br><span class="line">        <span class="keyword">return</span> $node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * automic operation insert|update|del</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">updateService</span><span class="params">(array $server)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//insert if not exist | update if not equal</span></span><br><span class="line">        $serverList = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($server <span class="keyword">as</span> $ser) &#123;</span><br><span class="line">            $addr = $ser[<span class="string">"Address"</span>].<span class="string">":"</span>.$ser[<span class="string">"Port"</span>];</span><br><span class="line">            $serverList[] = $addr;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">self</span>::$table-&gt;exist($addr))</span><br><span class="line">                <span class="keyword">self</span>::$table-&gt;set($addr,$ser);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//del not exist</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">self</span>::$table <span class="keyword">as</span> $k =&gt; $ser) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!in_array($k, $serverList)) &#123;</span><br><span class="line">                <span class="keyword">self</span>::$table-&gt;del($k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>table 内存表的创建使用原生封装的库<code>core/table</code></li><li>需要加上<code>@bean()</code>注解，因为内存表需要在swoole启动之前创建，也就是注解扫描阶段就需要建立</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;注册服务&quot;&gt;&lt;a href=&quot;#注册服务&quot; class=&quot;headerlink&quot; title=&quot;@注册服务&quot;&gt;&lt;/a&gt;@注册服务&lt;/h2&gt;&lt;p&gt;file:&lt;code&gt;app/Process/Discovery.php&lt;/code&gt;&lt;br&gt;&lt;figure class
      
    
    </summary>
    
      <category term="im-cloud" scheme="http://blog.huido.site/categories/im-cloud/"/>
    
      <category term="3.应用实现" scheme="http://blog.huido.site/categories/im-cloud/3-%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="rabbitmq" scheme="http://blog.huido.site/tags/rabbitmq/"/>
    
      <category term="consul" scheme="http://blog.huido.site/tags/consul/"/>
    
  </entry>
  
  <entry>
    <title>推送实现</title>
    <link href="http://blog.huido.site/wiki/im-cloud/3.%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0/1.%E6%8E%A8%E9%80%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.huido.site/wiki/im-cloud/3.应用实现/1.推送实现/</id>
    <published>2019-10-28T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推送流程"><a href="#推送流程" class="headerlink" title="推送流程"></a>推送流程</h2><p>总的来说logic暴露api接口服务，处理推送http请求，并通过队列的方式让job来消费该任务。最后通过grpc通知cloud节点推送实际的链接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logic -&gt; job -&gt; cloud</span><br></pre></td></tr></table></figure></p><h3 id="logic"><a href="#logic" class="headerlink" title="@logic"></a>@logic</h3><p>file:<code>app/Service/Dao/Queue.php</code></p><p>简短粗暴的直接丢到队列 rabbitmq即可<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * pushMsg</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> int $op</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> string $server</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> array $keys</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> $msg</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> \Throwable</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">pushMsg</span><span class="params">(int $operation,string $server,array $keys, $msg)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     $type = PushMsg\Type::PUSH;</span><br><span class="line">     $pushmsg = compact(<span class="string">"type"</span>,<span class="string">"operation"</span>,<span class="string">"server"</span>,<span class="string">"keys"</span>,<span class="string">"msg"</span>);</span><br><span class="line">     Log::info(<span class="string">"push msg to job node data:"</span>.json_encode($pushmsg));</span><br><span class="line">     <span class="comment">/** <span class="doctag">@var</span> Producer $producers */</span></span><br><span class="line">     $producers = \bean(Producer::class);</span><br><span class="line">     <span class="comment">//发送到队列里</span></span><br><span class="line">     producer()-&gt;produce($producers-&gt;producer($pushmsg));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="job"><a href="#job" class="headerlink" title="@job"></a>@job</h2><p>file:<code>app/Task/pushKey.php</code><br>job节点直接消费数据，去连接池获取链接，直接push到cloud节点<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行grpc 和 cloud 节点通讯</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $operation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $server</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array $subkey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $body</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">(int $operation ,string $server , array $subkey , $body)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $proto = <span class="keyword">new</span> Proto();</span><br><span class="line">    $proto-&gt;setOp($operation);</span><br><span class="line">    $proto-&gt;setVer(<span class="number">1</span>);</span><br><span class="line">    $proto-&gt;setBody($body);</span><br><span class="line"></span><br><span class="line">    $pushMsg = <span class="keyword">new</span> PushMsgReq();</span><br><span class="line">    $pushMsg-&gt;setKeys($subkey);</span><br><span class="line">    $pushMsg-&gt;setProto($proto);</span><br><span class="line">    $pushMsg-&gt;setProtoOp($operation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!CloudClient::$table-&gt;exist($server))&#123;</span><br><span class="line">        Log::error(<span class="string">"pushkey not exist grpc client server: $server "</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GrpcCloudClient::PushMsg($server,$pushMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="cloud"><a href="#cloud" class="headerlink" title="@cloud"></a>@cloud</h2><p>file:<code>app/Grpc/Cloud.php</code><br>grpc服务端获取到请求后，去swooletable 内存表拿到对应到链接信息，进行推送<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受 logic节点 job节点grpc请求，单点推送消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">pushMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Log::debug(<span class="string">"cloud node: pushmsg"</span>);</span><br><span class="line">    $pushMsgRpy = Parser::serializeMessage(<span class="keyword">new</span> PushMsgReply());</span><br><span class="line">    <span class="comment">/** <span class="doctag">@var</span> PushMsgReq $pushMsgReq */</span></span><br><span class="line">    $pushMsgReq = Parser::deserializeMessage([PushMsgReq::class,<span class="keyword">null</span>],request()-&gt;getRawBody());</span><br><span class="line">    response()-&gt;withContent($pushMsgRpy)-&gt;end();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">empty</span>($pushMsgReq-&gt;getKeys()) || <span class="keyword">empty</span>($pushMsgReq-&gt;getProto()))&#123;</span><br><span class="line">        Log::error(<span class="string">"cloud grpc pushmsg keys proto is empty raw data:"</span>.json_encode($pushMsgReq));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@var</span> array $keys */</span></span><br><span class="line">    $keys = $pushMsgReq-&gt;getKeys();</span><br><span class="line">    $op = $pushMsgReq-&gt;getProtoOp();</span><br><span class="line">    $body = $pushMsgReq-&gt;getProto()-&gt;getBody();</span><br><span class="line">    <span class="comment">//coroutine do</span></span><br><span class="line">    <span class="keyword">foreach</span> ($keys <span class="keyword">as</span> $key)&#123;</span><br><span class="line">        <span class="comment">/** <span class="doctag">@var</span> Task $task */</span></span><br><span class="line">        \bean(Task::class)-&gt;deliver(Push::class,<span class="string">"push"</span>,[$key,$op,$body]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;推送流程&quot;&gt;&lt;a href=&quot;#推送流程&quot; class=&quot;headerlink&quot; title=&quot;推送流程&quot;&gt;&lt;/a&gt;推送流程&lt;/h2&gt;&lt;p&gt;总的来说logic暴露api接口服务，处理推送http请求，并通过队列的方式让job来消费该任务。最后通过grpc通知clo
      
    
    </summary>
    
      <category term="im-cloud" scheme="http://blog.huido.site/categories/im-cloud/"/>
    
      <category term="3.应用实现" scheme="http://blog.huido.site/categories/im-cloud/3-%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="rabbitmq" scheme="http://blog.huido.site/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>im-cloud</title>
    <link href="http://blog.huido.site/wiki/im-cloud/2.%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1.im-cloud/"/>
    <id>http://blog.huido.site/wiki/im-cloud/2.底层实现/1.im-cloud/</id>
    <published>2019-10-25T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="im-cloud-基于swoole-原生协程构建分布式推送中间件"><a href="#im-cloud-基于swoole-原生协程构建分布式推送中间件" class="headerlink" title="im-cloud 基于swoole 原生协程构建分布式推送中间件"></a>im-cloud 基于swoole 原生协程构建分布式推送中间件</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><blockquote><p>基于<code>swoole</code>原生协程构建商业化即时推送im服务中间件,不进行业务处理，单独作为中间件使用，可弹性扩充节点增加性能处理.不依赖外部框架，核心代码为原生swoole构建的组件</p></blockquote><p>借鉴goim(<code>bilibili出品,生产级百万消息秒级推送</code>)，使用swoole实现基于php的高性能分布式im中间件，提升高并发性能的推送</p><h2 id="二、服务业务节点"><a href="#二、服务业务节点" class="headerlink" title="二、服务业务节点"></a>二、服务业务节点</h2><blockquote><p><code>cloud,job,logic</code> 等节点都可以水平扩容</p><ul><li>例如在消费能力不足时可以启动n个<code>job</code>节点提高并消费能力</li><li>启动多个cloud节点作为client客户端负载均衡，将多个<code>websocket</code>，<code>tcp</code> client分布到多个cloud节点中，提高cloud节点中心处理能力</li><li><code>logic</code> 提供对外restapi 作为主要业务节点</li><li><code>高性能</code> 协程化、水平扩容、分布式服务架构、接入服务治理</li></ul></blockquote><h3 id="cloud"><a href="#cloud" class="headerlink" title="@cloud"></a>@cloud</h3><p><a href="./app/cloud"><code>cloud</code></a> 作为中心服务节点 <code>grpc-server</code> 节点，对外接收TCP、Websocket客户端进行<code>长连接</code>,可以水平扩容至多个节点 并注册到服务中心，例如<code>consul</code>。每个cloud节点维护自己的客户端</p><h3 id="job"><a href="#job" class="headerlink" title="@job"></a>@job</h3><p><a href="./app/-job"><code>job</code></a> 节点作为消费节点 消费队列数据 然后进行<code>grpc</code> 和cloud服务进行通讯 进行 <code>push</code> <code>push room</code> <code>broadcast</code>,作为节点中间件，消费<code>kafaka</code>，<code>rockermq。。。</code>之类，可以扩展多个节点提高并发消费能力</p><h3 id="logic"><a href="#logic" class="headerlink" title="@logic"></a>@logic</h3><p><a href="./app/logic"><code>logic</code></a> 节点 提供rest api接口，作为生产节点 和  grpc客户端,可写入队列作为生产者，也可以扩展自己的业务进行grpc直接调用cloud节点中心进行推送</p><h2 id="三、组件依赖包-package"><a href="#三、组件依赖包-package" class="headerlink" title="三、组件依赖包 package"></a>三、组件依赖包 <code>package</code></h2><blockquote><p>服务间配置独立，使用composer进行依赖管理，进行composer组件化开发</p><ul><li><a href="./package/im-core"><code>im-core</code></a> 为核心基础组件，底层设计借鉴 <code>swoft</code>源码设计</li><li><a href="./package/im-grpc"><code>im-grpc</code></a> 定义grpc接口规范composer包,使用<code>protobuf</code>构建,封装有连接池</li><li><a href="./package/im-discovery"><code>im-discovery</code></a> 服务发现注册组件，注册<code>grpc-server</code>，发现服务等封装</li><li><a href="./package/im-process"><code>im-process</code></a> 进程管理模块，可以注册启动自定义进程，并交由swoole master进程管理声明周期</li><li><a href="./package/im-queue"><code>im-queue</code></a> 消息队列管理模块，提供消息队列接口，底层实现了<code>连接池</code>接口，无需管理连接，根据类型可以切换不同的消息队列(<code>done rabbitmq</code>,soon kafak)</li><li><a href="./package/im-redis"><code>im-redis</code></a> 封装了连接池版本的redis client</li><li><a href="./package/im-task"><code>im-task</code></a> 异步任务组件，封装投递task进程任务的接口，目前仅支持投递<code>worker-&gt;task</code>,不支持自定义进程投递以及投递到自定义进程</li></ul></blockquote><h2 id="四、数据流程"><a href="#四、数据流程" class="headerlink" title="四、数据流程"></a>四、数据流程</h2><h2 id="im-cloud-连接流程图"><a href="#im-cloud-连接流程图" class="headerlink" title="im-cloud 连接流程图"></a>im-cloud 连接流程图</h2><p><img src="/images/im-cloud/im-cloud-connect.png" alt=""></p><h2 id="im-cloud-数据流程图"><a href="#im-cloud-数据流程图" class="headerlink" title="im-cloud 数据流程图"></a>im-cloud 数据流程图</h2><p><img src="/images/im-cloud/im-cloud-process.png" alt=""></p><h2 id="im-cloud-业务流程"><a href="#im-cloud-业务流程" class="headerlink" title="im-cloud 业务流程"></a>im-cloud 业务流程</h2><p><img src="/images/im-cloud/im-cloudt-task.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;im-cloud-基于swoole-原生协程构建分布式推送中间件&quot;&gt;&lt;a href=&quot;#im-cloud-基于swoole-原生协程构建分布式推送中间件&quot; class=&quot;headerlink&quot; title=&quot;im-cloud 基于swoole 原生协程构建分布式推
      
    
    </summary>
    
      <category term="im-cloud" scheme="http://blog.huido.site/categories/im-cloud/"/>
    
      <category term="2.底层实现" scheme="http://blog.huido.site/categories/im-cloud/2-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="rabbitmq" scheme="http://blog.huido.site/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>icmp协议</title>
    <link href="http://blog.huido.site/wiki/net-protocol/4.%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%8D%8F%E8%AE%AE_icmp/"/>
    <id>http://blog.huido.site/wiki/net-protocol/4.网络层/协议_icmp/</id>
    <published>2019-10-24T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h1><p>ICMP 的全称是 Internet Control Message Protocol 。与 IP 协议一样同属 TCP/IP 模型中的网络层，并且 ICMP 数据包是包裹在 IP 数据包中的。他的作用是报告一些网络传输过程中的错误与做一些同步工作。ICMP 数据包有许多类型。每一个数据包只有前 4 个字节是相同域的，剩余的字段有不同的数据包类型的不同而不同。ICMP 数据包的格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">https://tools.ietf.org/html/rfc792</span><br><span class="line"></span><br><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |     Code      |          Checksum             |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">|                   不同的Type和Code有不同的内容                    |         </span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>从技术角度来说，ICMP 就是一个“错误侦测与回报机制”， 其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性﹐其功能主要有：</p><ul><li>侦测远端主机是否存在。</li><li>建立及维护路由信息。</li><li>重导数据传送路径（ICMP 重定向）。</li><li>数据流量控制。<br>ICMP 在沟通之中，主要是透过不同的类别(Type)与代码(Code) 让机器来识别不同的连线状况。</li></ul><h2 id="完整类型列表"><a href="#完整类型列表" class="headerlink" title="完整类型列表"></a>完整类型列表</h2><table><thead><tr><th>TYPE</th><th>CODE</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>Echo Reply——回显应答（Ping 应答）</td></tr><tr><td>3</td><td>0</td><td>Network Unreachable——网络不可达</td></tr><tr><td>3</td><td>1</td><td>Host Unreachable——主机不可达</td></tr><tr><td>3</td><td>2</td><td>Protocol Unreachable——协议不可达</td></tr><tr><td>3</td><td>3</td><td>Port Unreachable——端口不可达</td></tr><tr><td>3</td><td>4</td><td>Fragmentation needed but no frag. bit set——需要进行分片但设置不分片标志</td></tr><tr><td>3</td><td>5</td><td>Source routing failed——源站选路失败</td></tr><tr><td>3</td><td>6</td><td>Destination network unknown——目的网络未知</td></tr><tr><td>3</td><td>7</td><td>Destination host unknown——目的主机未知</td></tr><tr><td>3</td><td>8</td><td>Source host isolated (obsolete)——源主机被隔离（作废不用）</td></tr><tr><td>3</td><td>9</td><td>Destination network administratively prohibited——目的网络被强制禁止</td></tr><tr><td>3</td><td>10</td><td>Destination host administratively prohibited——目的主机被强制禁止</td></tr><tr><td>3</td><td>11</td><td>Network unreachable for TOS——由于服务类型 TOS，网络不可达</td></tr><tr><td>3</td><td>12</td><td>Host unreachable for TOS——由于服务类型 TOS，主机不可达</td></tr><tr><td>3</td><td>13</td><td>Communication administratively prohibited by filtering——由于过滤，通信被强制禁止</td></tr><tr><td>3</td><td>14</td><td>Host precedence violation——主机越权</td></tr><tr><td>3</td><td>15</td><td>Precedence cutoff in effect——优先中止生效</td></tr><tr><td>4</td><td>0</td><td>Source quench——源端被关闭（基本流控制）</td></tr><tr><td>5</td><td>0</td><td>Redirect for network——对网络重定向</td></tr><tr><td>5</td><td>1</td><td>Redirect for host——对主机重定向</td></tr><tr><td>5</td><td>2</td><td>Redirect for TOS and network——对服务类型和网络重定向</td></tr><tr><td>5</td><td>3</td><td>Redirect for TOS and host——对服务类型和主机重定向</td></tr><tr><td>8</td><td>0</td><td>Echo request——回显请求（Ping 请求）</td></tr><tr><td>9</td><td>0</td><td>Router advertisement——路由器通告</td></tr><tr><td>10</td><td>0</td><td>Route solicitation——路由器请求</td></tr><tr><td>11</td><td>0</td><td>TTL equals 0 during transit——传输期间生存时间为 0</td></tr><tr><td>11</td><td>1</td><td>TTL equals 0 during reassembly——在数据报组装期间生存时间为 0</td></tr><tr><td>12</td><td>0</td><td>IP header bad (catchall error)——坏的 IP 首部（包括各种差错）</td></tr><tr><td>12</td><td>1</td><td>Required options missing——缺少必需的选项</td></tr><tr><td>13</td><td>0</td><td>Timestamp request (obsolete)——时间戳请求（作废不用）</td></tr><tr><td>14</td><td></td><td>Timestamp reply (obsolete)——时间戳应答（作废不用）</td></tr><tr><td>15</td><td>0</td><td>Information request (obsolete)——信息请求（作废不用）</td></tr><tr><td>16</td><td>0</td><td>Information reply (obsolete)——信息应答（作废不用）</td></tr><tr><td>17</td><td>0</td><td>Address mask request——地址掩码请求</td></tr><tr><td>18</td><td>0</td><td>Address mask</td></tr></tbody></table><p>ICMP 是个非常有用的协议，尤其是当我们要对网路连接状况进行判断的时候。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ICMP-协议&quot;&gt;&lt;a href=&quot;#ICMP-协议&quot; class=&quot;headerlink&quot; title=&quot;ICMP 协议&quot;&gt;&lt;/a&gt;ICMP 协议&lt;/h1&gt;&lt;p&gt;ICMP 的全称是 Internet Control Message Protocol 。与 IP 
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="4.网络层" scheme="http://blog.huido.site/categories/net-protocol/4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>arp协议</title>
    <link href="http://blog.huido.site/wiki/net-protocol/4.%E7%BD%91%E7%BB%9C%E5%B1%82/arp%E5%8D%8F%E8%AE%AE/"/>
    <id>http://blog.huido.site/wiki/net-protocol/4.网络层/arp协议/</id>
    <published>2019-10-24T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><p>基于arp协议，获取对应的物理mac地址</p><p><img src="/images/arp.png" alt="image"><br>上层tcp/ip协议报文只包含<code>目标服务器的ip地址</code>，而下层链路层以太网协议需要知道目标服务器的<code>mac地址</code>，则arp的协议是指当前主机发送ARP查询（广播）查询该mac地址，如果目标地址不是在同一个局域网，则该mac地址则是局域网外的路由器mac地址，该所有帧都将发往该路由器地址</p><blockquote><p>总之以太网协议中得到的上层数据中只有IP地址，需要使用arp协议去获得mac地址，arp协议会在链路层进行广播，只有目标地址会回应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARP Paclket Format </span><br><span class="line">arp协议数据包格式</span><br><span class="line">6字节(以太网目的地址)  +  6字节（以太网源地址）   + 2 字节（帧类型）  + 28字节（arp请求回应包）</span><br></pre></td></tr></table></figure></p></blockquote><p>28字节包格式</p><ul><li>2字节硬件类型：1 =&gt; 以太网地址</li><li>2字节协议类型：0x800 表示ipv4协议</li><li>1字节地址长度：单位长度，一般为6  表示以太网地址的长度6字节</li><li>1字节协议地址长度：一般为4，ipv4地址长度</li><li>2字节操作码：1 =&gt; arp请求   2 =&gt; arp应答  3 =&gt; rarp请求  4 =&gt; rarp应答</li><li>6字节原mac地址：源mac地址</li><li>4字节源协议地址：源ip地址 如192.168.0.1</li><li>6字节目标mac地址：mac地址</li></ul><blockquote><p>不用担心每次请求都会触发arp查询广播，机器是有arp高速缓存的 <code>arp -a</code></p></blockquote><h3 id="type"><a href="#type" class="headerlink" title="@type"></a>@type</h3><p>type:0x8060 表示arp协议</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ARP-协议&quot;&gt;&lt;a href=&quot;#ARP-协议&quot; class=&quot;headerlink&quot; title=&quot;ARP 协议&quot;&gt;&lt;/a&gt;ARP 协议&lt;/h2&gt;&lt;p&gt;基于arp协议，获取对应的物理mac地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/arp.png&quot;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="4.网络层" scheme="http://blog.huido.site/categories/net-protocol/4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>端口机制</title>
    <link href="http://blog.huido.site/wiki/net-protocol/4.%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%8D%8F%E8%AE%AE_%E7%AB%AF%E5%8F%A3/"/>
    <id>http://blog.huido.site/wiki/net-protocol/4.网络层/协议_端口/</id>
    <published>2019-10-24T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><h2 id="端口在tcp协议中的体现"><a href="#端口在tcp协议中的体现" class="headerlink" title="端口在tcp协议中的体现"></a>端口在tcp协议中的体现</h2><p>端口一般在tcp首部前四个字节中，前2字节表示源端口 后两字节表示目标端口<br><img src="5F5BC33465194D9E82C737A5030A7808" alt="image"></p><p>1.周知端口（Well Known Ports）<br>周知端口是众所周知的端口号，范围从 0 到 1023，其中 80 端口分配给 WWW 服务，21 端口分配给 FTP 服务等。我们在 IE 的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下 WWW 服务的端口是”80”。网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在 地址栏上指定端口号，方法是在地址后面加上冒号”:”，再加上端口号。比如使用”8080”作为 WWW 服务的端口，则需要在地址栏里输入”网址:8080”。但是有些系统协议使用固定的端口号，它是不能被改变的，比如 139 端口专门用于 NetBIOS 与 TCP/IP 之间的通信，不能手动改变。</p><p>2.注册端口（Registered Ports）<br>端口 1024 到 49151，分配给用户进程或应用程序。这些进程主要是用户选择安装的一些应用程序，而不是已经分配好了公认端口的常用程序。这些端口在没有被服务器资源占用的时候，可以用用户端动态选用为源端口。</p><p>3.动态端口（Dynamic Ports）<br>动态端口的范围是从 49152 到 65535。之所以称为动态端口，是因为它 一般不固定分配某种服务，而是动态分配。比如本地想和远端建立 TCP 连接，如果没有指定本地源端口，系统就会给你自动分配一个未占用的源端口，这个端口值就是动态的，当你断开再次建立连接的时候，很有可能你的源端口和上次得到的端口不一样。</p><p>一些常见的端口号及其用途如下：</p><ul><li>TCP21 端口：FTP 文件传输服务</li><li>TCP22 端口：SSH 安全外壳协议</li><li>TCP23 端口：TELNET 终端仿真服务</li><li>TCP25 端口：SMTP 简单邮件传输服务</li><li>UDP53 端口：DNS 域名解析服务</li><li>UDP67 端口：DHCP 的服务端端口 UDP68 端口：DHCP 的客户端端口 TCP80 端口：HTTP 超文本传输服务</li><li>TCP110 端 口：POP3“邮局协议版本 3”使用的端口</li><li>TCP443 端口：HTTPS 加密的超文本传输服务</li></ul><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>端口是<code>网络层协议地址+传输层协议号+端口号</code>来区分的，比如：</p><p><code>ipv4的tcp 80</code>端口和<code>ipv4的udp 8</code>0端口不会冲突。</p><p>如果你主机有两个 ip 地址 ip1 和 ip2，那么你同时监听<code>ip1:80</code>和<code>ip2:80</code>不会冲突。</p><p><code>ipv4的tcp 80</code>端口和ipv6的<code>tcp 80</code>端口不会冲突。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;端口&quot;&gt;&lt;a href=&quot;#端口&quot; class=&quot;headerlink&quot; title=&quot;端口&quot;&gt;&lt;/a&gt;端口&lt;/h1&gt;&lt;h2 id=&quot;端口在tcp协议中的体现&quot;&gt;&lt;a href=&quot;#端口在tcp协议中的体现&quot; class=&quot;headerlink&quot; title=&quot;端
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="4.网络层" scheme="http://blog.huido.site/categories/net-protocol/4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>ip协议</title>
    <link href="http://blog.huido.site/wiki/net-protocol/4.%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%8D%8F%E8%AE%AE_ip/"/>
    <id>http://blog.huido.site/wiki/net-protocol/4.网络层/协议_ip/</id>
    <published>2019-10-24T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP-报文协议"><a href="#IP-报文协议" class="headerlink" title="IP 报文协议"></a>IP 报文协议</h1><p>首部协议格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0               1               2               3               4</span><br><span class="line">0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Version|  LHL  | Type of Service |        Total Length         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Identification(fragment Id)    |Flags|  Fragment Offset      |</span><br><span class="line">|           16 bits               |R|D|M|       13 bits         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| Time-To-Live  |   Protocol      |      Header Checksum        |</span><br><span class="line">| ttl(8 bits)   |    8 bits       |          16 bits            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|               Source IP Address (32 bits)                     |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|              Destination Ip Address (32 bits)                 |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options (*** bits)          |  Padding     |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    transport data...                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p><code>版本（Version）:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">版本字段占 4bit，通信双方使用的版本必须一致。对于 IPv4，字段的值是 4。</span><br></pre></td></tr></table></figure><p><code>首部长度（Internet Header Length， IHL）:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">占 4bit，首部长度说明首部有多少 32 位字（4字节）。</span><br><span class="line">由于 IPv4首部可能包含数目不定的选项，这个字段也用来确定数据的偏移量。</span><br><span class="line">这个字段的最小值是 5（二进制 0101），相当于 5*4=20 字节（RFC 791），最大十进制值是 15。</span><br></pre></td></tr></table></figure><p><code>区分服务（Differentiated Services，DS):</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">占 8bit，最初被定义为服务类型字段，实际上并未使用，但 1998 年被 IETF 重定义为区分服务 RFC 2474。</span><br><span class="line">只有在使用区分服务时，这个字段才起作用，在一般的情况 下都不使用这个字段。例如需要实时数据流的技术会应用这个字段，一个例子是 VoIP。</span><br></pre></td></tr></table></figure><p><code>显式拥塞通告（ Explicit Congestion Notification，ECN）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 RFC 3168 中定义，允许在不丢弃报文的同时通知对方网络拥塞的发生。</span><br><span class="line">ECN 是一种可选的功能，仅当两端都支持并希望使用，且底层网络支持时才被使用。</span><br></pre></td></tr></table></figure></p><p><code>全长（Total Length）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个 16 位字段定义了报文总长，包含首部和数据，单位为字节。</span><br><span class="line">这个字段的最小值是 20（20 字节首部+0 字节数据），最大值是 216-1=65,535。</span><br><span class="line">IP 规定所有主机都必须支持最小 576 字节的报文，这是假定上层数据长度 512 字节，加上最长 IP 首部 60 字节，加上 4 字节富裕量，</span><br><span class="line">得出 576 字节，但大多数现代主机支持更大的报文。</span><br><span class="line">当下层的数据链路协议的最大传输单元（MTU）字段的值小于 IP 报文长度时间，报文就必须被分片，详细见下个标题。</span><br></pre></td></tr></table></figure></p><p><code>标识符（Identification):</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">占 16 位，这个字段主要被用来唯一地标识一个报文的所有分片，因为分片不一定按序到达，所以在重组时需要知道分片所属的报文。</span><br><span class="line">每产生一个数据报，计数器加 1，并赋值给此字段。一些实验性的工作建议将此字段用于其它目的，例如增加报文跟踪信息以协助探测伪造的源地址。</span><br></pre></td></tr></table></figure></p><p><code>标志 （Flags）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这个 3 位字段用于控制和识别分片，它们是：</span><br><span class="line">位 0：保留，必须为 0； </span><br><span class="line">位 1：禁止分片（Don’t Fragment，DF），当 DF=0 时才允许分片； </span><br><span class="line">位 2：更多分片（More Fragment，MF），MF=1 代表后面还有分片，MF=0 代表已经是最后一个分片。 </span><br><span class="line">如果 DF 标志被设置为 1，但路由要求必须分片报文，此报文会被丢弃。这个标志可被用于发往没有能力组装分片的主机。</span><br><span class="line">当一个报文被分片，除了最后一片外的所有分片都设置 MF 为 1。</span><br><span class="line">最后一个片段具有非零片段偏移字段，将其与未分片数据包区分开，未分片的偏移字段为 0。</span><br></pre></td></tr></table></figure></p><p><code>分片偏移 （Fragment Offset）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个 13 位字段指明了每个分片相对于原始报文开头的偏移量，以 8 字节作单位。</span><br></pre></td></tr></table></figure></p><p><code>存活时间（Time To Live，TTL）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个 8 位字段避免报文在互联网中永远存在（例如陷入路由环路）。</span><br><span class="line">存活时间以秒为单位，但小于一秒的时间均向上取整到一秒。</span><br><span class="line">在现实中，这实际上成了一个跳数计数器：报文经过的每个路由器都将此字段减 1，当此字段等于 0 时，报文不再向下一跳传送并被丢弃，最大值是 255。</span><br><span class="line">常规地，一份 ICMP 报文被发回报文发送端说明其发送的报文已被丢弃。这也是 traceroute 的核心原理。</span><br></pre></td></tr></table></figure></p><p><code>协议 （Protocol）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">占 8bit，这个字段定义了该报文数据区使用的协议。IANA 维护着一份协议列表（最初由 RFC 790 定义），详细参见 IP 协议号列表。</span><br></pre></td></tr></table></figure></p><p><code>首部检验和 （Header Checksum）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个 16 位检验和字段只对首部查错，不包括数据部分。</span><br><span class="line">在每一跳，路由器都要重新计算出的首部检验和并与此字段进行比对，如果不一致，此报文将会被丢弃。</span><br><span class="line">重新计算的必要性是因为每一跳的一些首部字段（如 TTL、Flag、Offset 等）都有可能发生变化，不检查数据部分是为了减少工作量。</span><br><span class="line">数据区的错误留待上层协议处理——用户数据报协议（UDP）和传输控制协议（TCP）都有检验和字段。此处的检验计算方法不使用 CRC。</span><br></pre></td></tr></table></figure></p><p><code>源地址</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个 IPv4 地址由四个字节共 32 位构成，此字段的值是将每个字节转为二进制并拼在一起所得到的 32 位值。</span><br><span class="line">例如，10.9.8.7 是 00001010000010010000100000000111。</span><br><span class="line">但请注意，因为 NAT 的存在，这个地址并不总是报文的真实发送端，因此发往此地址的报文会被送往 NAT 设备，并由它被翻译为真实的地址。</span><br></pre></td></tr></table></figure><p><code>目的地址</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与源地址格式相同，但指出报文的接收端。</span><br></pre></td></tr></table></figure></p><p><code>选项:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">附加的首部字段可能跟在目的地址之后，但这并不被经常使用，从 1 到 40 个字节不等。</span><br><span class="line">请注意首部长度字段必须包括足够的 32 位字来放下所有的选项（包括任何必须的填充以使首部长度能够被 32 位整除）。</span><br><span class="line">当选项列表的结尾不是首部的结尾时，EOL（选项列表结束，0x00）选项被插入列表末尾。下表列出了可能。</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>字段</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td>备份</td><td>1</td><td>当此选项需要被备份到所有分片中时，设为 1。</td></tr><tr><td>类</td><td>2</td><td>常规的选项类别，0 为“控制”，2 为“查错和措施”，1 和 3 保留。</td></tr><tr><td>数字</td><td>5</td><td>指明一个选项。</td></tr><tr><td>长度</td><td>8</td><td>指明整个选项的长度，对于简单的选项此字段可能不存在。</td></tr><tr><td>数据</td><td>可变</td><td>选项相关数据，对于简单的选项此字段可能不存在。</td></tr></tbody></table><blockquote><p>注：如果首部长度大于 5，那么选项字段必然存在并必须被考虑。<br>注：备份、类和数字经常被一并称呼为“类型”。</p></blockquote><ul><li>数据 数据字段不是首部的一部分，因此并不被包含在首部检验和中。数据的格式在协议首部字段中被指明，并可以是任意的传输层协议。 一些常见协议的协议字段值被列在下面</li></ul><table><thead><tr><th>协议字段值</th><th>协议名</th><th>缩写</th></tr></thead><tbody><tr><td>1</td><td>互联网控制消息协议</td><td>ICMP</td></tr><tr><td>2</td><td>互联网组管理协议</td><td>IGMP</td></tr><tr><td>6</td><td>传输控制协议</td><td>TCP</td></tr><tr><td>17</td><td>用户数据报协议</td><td>UDP</td></tr><tr><td>41</td><td>IPv6 封装</td><td>ENCAP</td></tr><tr><td>89</td><td>开放式最短路径优先</td><td>OSPF</td></tr><tr><td>132</td><td>流控制传输协议</td><td>SCTP</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IP 层最重要的目的是让两个主机之间通信，无论他们相隔多远。<br>IP 协议理论上允许的最大 IP 数据报为 <code>65535</code> 字节（16 位来表示包总长）。<br>但是因为协议栈网络层下面的数据链路层一般允许的帧长远远小于这个值，例如以太网的 MTU 通常在 <code>1500</code> 字节左右。<br>所以较大的 IP 数据包会被<code>分片传</code>递给数据链路层发送，分片的 IP 数据报可能会以不同的路径传输到接收主机，接收主机通过一系列的<code>重组</code>，将其还原为一个完整的 IP 数据报，再提交给上层协议处理。<br>IP 分片会带来一定的问题，分片和重组会消耗发送方、接收方一定的 CPU 等资源，如果存在大量的分片报文的话，可能会造成较为严重的资源消耗；分片丢包导致的重传问题；分片攻击；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IP-报文协议&quot;&gt;&lt;a href=&quot;#IP-报文协议&quot; class=&quot;headerlink&quot; title=&quot;IP 报文协议&quot;&gt;&lt;/a&gt;IP 报文协议&lt;/h1&gt;&lt;p&gt;首部协议格式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="4.网络层" scheme="http://blog.huido.site/categories/net-protocol/4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>tcp可靠性机制</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/3.%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/tcp/3.可靠性机制/</id>
    <published>2019-10-22T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcp-可靠性机制"><a href="#tcp-可靠性机制" class="headerlink" title="tcp 可靠性机制"></a>tcp 可靠性机制</h1><p>可靠性指的是网络层能通信的前提下，保证数据包正确且按序到达对端。 比如发送端发送了“12345678”，那么接收端一定能收到“12345678”，不会乱序“12456783”，也不会少或多数据。</p><h2 id="实现-TCP-的可靠传输有以下机制："><a href="#实现-TCP-的可靠传输有以下机制：" class="headerlink" title="实现 TCP 的可靠传输有以下机制："></a>实现 TCP 的可靠传输有以下机制：</h2><p>1.<code>校验和机制</code>（检测和重传受到损伤的报文段）</p><p>2.<code>确认应答机制</code>（保存失序到达的报文段直至缺失的报文到期，以及检测和丢弃重复的报文段）</p><p>3.<code>超时重传机制</code>（重传丢失的报文段）</p><h2 id="1-校验和"><a href="#1-校验和" class="headerlink" title="1.校验和"></a>1.校验和</h2><p>每个 tcp 段都包含了一个检验和字段，用来检查报文段是否收到损伤。如果某个报文段因检验和无效而被检查出受到损伤，就由终点 TCP 将其丢弃，并被认为是丢失了。TCP 规定每个报文段都必须使用 <code>16 位的检验和</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 校验和的计算</span><br><span class="line">func Checksum(buf []byte, initial uint16) uint16 &#123;</span><br><span class="line">v := uint32(initial)</span><br><span class="line"></span><br><span class="line">l := len(buf)</span><br><span class="line">if l&amp;1 != 0 &#123;</span><br><span class="line">l--</span><br><span class="line">v += uint32(buf[l]) &lt;&lt; 8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; l; i += 2 &#123;</span><br><span class="line">v += (uint32(buf[i]) &lt;&lt; 8) + uint32(buf[i+1])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return ChecksumCombine(uint16(v), uint16(v&gt;&gt;16))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-确认机制"><a href="#2-确认机制" class="headerlink" title="2.确认机制"></a>2.确认机制</h2><p>控制报文段不携带数据，但需要消耗一个序号，它也需要被确认，而 ACK 报文段永远不需要确认，ACK 报文段不消耗序号，也不需要被确认。在以前，TCP 只使用一种类型的确认，叫积累确认，目前 TCP 实现还实现了选择确认。</p><ul><li>累积确认（ACK）</li></ul><p>接收方通告它期望接收的下一个字节的序号，并忽略所有失序到达并被保存的报文段。有时这被称为肯定累积确认。在 TCP 首部的 32 位 ACK 字段用于积累确认，而它的值仅在 ACK 标志为 1 时才有效。举个例子来说，这里先不考虑 tcp 的序列号，如果发送方发了数据包 p1，p2，p3，p4；接受方成功收到 p1，p2，p4。那么接收方需要发回一个确认包，序号为 3(3 表示期望下一个收到的包的序号)，那么发送方就知道 p1 到 p2 都发送接收成功，必要时重发 p3。一个确认包确认了累积到某一序号的所有包，而不是对每个序号都发确认包。实际的 tcp 确认的都是序列号，而不是包的序号，但原理是一样的。</p><p>累积确认是快速重传的基础，这个后面讲拥塞控制的时候会详细说明。</p><p>累积确认是快速重传的基础，这个后面讲拥塞控制的时候会详细说明。</p><ul><li>选择确认（SACK）</li></ul><p>选择确认 SACK 要报告失序的数据块以及重复的报文段块，是为了更准确的告诉发送方需要重传哪些数据块。SACK 并没有取代 ACK，而是向发送方报告了更多的信息。SACK 是作为 TCP 首部末尾的选项来实现的。<br>首先是否要启动 sack，应该在握手的时候告诉对方自己是否开启了 sack，这个是通过 kind=4 是选择性确认（Selective Acknowledgment，SACK）选项来实现的。<br>实际传送 sack 信息的是 kind=5 的选项，其格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">         +--------+--------+</span><br><span class="line">         | Kind=5 | Length | </span><br><span class="line">+--------+--------+--------+---------+ </span><br><span class="line">|          Start of 1st Block        | </span><br><span class="line">+--------+--------+--------+---------+ </span><br><span class="line">|           End of 1st Block         | </span><br><span class="line">+--------+--------+--------+---------+ </span><br><span class="line">|                                    | </span><br><span class="line">/            . . . . . .             / </span><br><span class="line">|                                    | </span><br><span class="line">+--------+--------+--------+---------+ </span><br><span class="line">|          Start of nth Block        | </span><br><span class="line">+--------+--------+--------+---------+ </span><br><span class="line">|           End of nth Block         | </span><br><span class="line">+--------+--------+--------+---------+</span><br></pre></td></tr></table></figure></p><p>sack 的每个块是由两个参数构成的<code>{ Start, End }</code> Start 不连续块的第一个数据的序列号。End 不连续块的最后一个数据的序列号之后的序列号。 该选项参数告诉对方已经接收到并缓存的不连续的数据块，<code>注意都是已经接收的</code>，发送方可根据此信息检查究竟是哪个块丢失，从而发送相应的数据块。 比如下图：<br><img src="07D550B59368499399ABFDD70C3735A0" alt="image"><br>如图所示，tcp 接收方在接收到不连续的 tcp 段，可以看出，序号 1～1000，1501～3000，3501～4500 接收到了，但却少了序号 1001～1500，3001～3500 。 前面说了，sack <code>报告的是已接收的不连续的块</code>，在这个例子中，sack 块的内容为<code>{Start:1501, End:3001},{Start:3501, End:4501}</code>， 注意：这里的 End 不是接收到数据段最后的序列号，而是最后的序列号加 1。</p><h3 id="产生确认的情况-确认机制"><a href="#产生确认的情况-确认机制" class="headerlink" title="产生确认的情况 确认机制"></a>产生确认的情况 确认机制</h3><ol><li>当接收方收到了按序到达（序号是所期望的）的报文段，那么接收方就累积发送确认报文段。</li><li>当具有所期望的序号的报文段到达，而前一个按序到达的报文段还没有被确认，那么接收方就要立即发送 ACK 报文段。</li><li>当序号比期望的序号还大的失序报文段到达时，接收方立即发送 ACK 报文段，并宣布下一个期望的报文段序号。这将导致对丢失报文段的快重传。</li><li>当一个丢失的报文段到达时，接收方要发送 ACK 报文段，并宣布下一个所期望的序号。</li><li>如果到达一个重复的报文段，接收方丢弃该报文段，但是应当立即发送确认，指出下一个期望的报文段。</li><li>收到 fin 报文的时候，立即回复确认。</li></ol><h2 id="3-重传机制"><a href="#3-重传机制" class="headerlink" title="3.重传机制"></a>3.重传机制</h2><p>关于重传的基本概念<br>RTO 即超时重传时间<br>RTT 数据包往返时间<br>平均偏差是指单项测定值与平均值的偏差（取绝对值）之和，除以测定次数。<br><img src="DEE81BB910FD42709B8CF09BEBF8055C" alt="image"><br>可靠性的核心就是报文段的重传。在一个报文段发送时，它会被保存到一个队列中，直至被确认为止。当重传计时器超时，或者发送方收到该队列中第一个报文段的三个重复的 ACK 时，该报文段被重传。</p><p>超时重传的概念很简单，就是一定时间内未收到确认，进行再次发送，但是如何计算重传的时间确实 tcp 最复杂的问题之一，毕竟要适应各种网络情况。TCP 一个连接期间只有一个 RTO 计时器，目前大部分实现都是采用<code>Jacobaon/Karels 算法</code>，详细可以看<code>RFC6298</code>，其计算公式如下，</p><p>rto 的计算公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一次rtt计算： </span><br><span class="line">SRTT = R</span><br><span class="line">RTTVAR = R/2</span><br><span class="line">RTO = SRTT + max (G, K*RTTVAR)</span><br><span class="line">K = 4</span><br><span class="line"></span><br><span class="line">之后：</span><br><span class="line">RTTVAR = (1 - beta) * RTTVAR + beta * |SRTT - R&apos;|</span><br><span class="line">SRTT = (1 - alpha) * SRTT + alpha * R&apos;</span><br><span class="line">RTO = SRTT + max (G, K*RTTVAR)</span><br><span class="line">K = 4</span><br></pre></td></tr></table></figure></p><p>SRTT(smoothed round-trip time)平滑 RTT 时间<br>RTTVAR(round-trip time variation)RTT 变量，其实就是 rtt 平均偏差<br>G 表示系统时钟的粒度，一般很小，us 级别。 beta = 1/4, alpha = 1/8</p><p>发送方 TCP 的计时器时间到，TCP 发送队列中最前面的报文段（即序列号最小的报文段），并重启计时器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tcp-可靠性机制&quot;&gt;&lt;a href=&quot;#tcp-可靠性机制&quot; class=&quot;headerlink&quot; title=&quot;tcp 可靠性机制&quot;&gt;&lt;/a&gt;tcp 可靠性机制&lt;/h1&gt;&lt;p&gt;可靠性指的是网络层能通信的前提下，保证数据包正确且按序到达对端。 比如发送端发送了“
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>tcp流量控制</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/2.%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/tcp/2.流量控制/</id>
    <published>2019-10-22T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcp-流量控制"><a href="#tcp-流量控制" class="headerlink" title="tcp 流量控制"></a>tcp 流量控制</h1><p>tcp是由丢包重传的机制的</p><p>那么如果服务端因为负载导致不能接受发送端的数据从而丢弃数据</p><p>发送端接受到ack确认为丢包后导致重传</p><p>然后服务端导致负载更加严重，从而一个劲的重发数据，对网络造成更大的伤害。于是就提出了拥塞控制，当拥塞发生的时候，要做自我牺牲，降低发送速率。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tcp-流量控制&quot;&gt;&lt;a href=&quot;#tcp-流量控制&quot; class=&quot;headerlink&quot; title=&quot;tcp 流量控制&quot;&gt;&lt;/a&gt;tcp 流量控制&lt;/h1&gt;&lt;p&gt;tcp是由丢包重传的机制的&lt;/p&gt;
&lt;p&gt;那么如果服务端因为负载导致不能接受发送端的数据从而
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>tcp头部</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/1.%E5%A4%B4%E9%83%A8/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/tcp/1.头部/</id>
    <published>2019-10-22T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="传输层-tcp-协议-实现"><a href="#传输层-tcp-协议-实现" class="headerlink" title="传输层 tcp 协议 实现"></a>传输层 tcp 协议 实现</h1><p><img src="43E0E23D5D324B8CA750C4F99EF4E3A7" alt="image"></p><h2 id="首部协议格式"><a href="#首部协议格式" class="headerlink" title="首部协议格式"></a>首部协议格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |           |G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><h3 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h3><p>各占 2 个字节，分别 tcp 连接的源端口和目的端口。关于端口的概念之前已经介绍过了。</p><h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>占 4 字节，序号范围是[0，2^32 - 1]，共 2^32（即 4294967296）个序号。序号增加到 2^32-1 后，下一个序号就又回到 0。TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号（ISN）必须在连接建立时设置。<code>首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号</code>。例如，一报文段的序号是 301，而接待的数据共有 100 字节。这就表明：本报文段的数据的第一个字节的序号是 301，最后一个字节的序号是 400。显然，下一个报文段（如果还有的话）的数据序号应当从 401 开始，即下一个报文段的序号字段值应为 401。</p><h3 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h3><p>占 4 字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B 正确收到了 A 发送过来的一个报文段，其序号字段值是 501，而数据长度是 200 字节（序号 501~700），这表明 B 正确收到了 A 发送的到序号 700 为止的数据。因此，B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701。注意，现在确认号不是 501，也不是 700，而是 701。<br>总之：若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。TCP 除了第一个 SYN 报文之外，所有 TCP 报文都需要携带 ACK 状态位。</p><h3 id="数据偏移"><a href="#数据偏移" class="headerlink" title="数据偏移"></a>数据偏移</h3><p>占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。<code>这个字段实际上是指出 TCP 报文段的首部长度</code>。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是 4 个字节，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节。</p><h3 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h3><p>占 6 位，保留为今后使用，但目前应置为 0。</p><h3 id="控制报文标志"><a href="#控制报文标志" class="headerlink" title="控制报文标志"></a>控制报文标志</h3><h4 id="紧急URG（URGent）"><a href="#紧急URG（URGent）" class="headerlink" title="紧急URG（URGent）"></a>紧急URG（URGent）</h4><p>当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收 TCP 的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。<br>当 URG 置为 1 时，发送应用进程就告诉发送方的 TCP 有紧急数据要传送。于是发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。</p><h4 id="确认ACK（ACKnowledgment）"><a href="#确认ACK（ACKnowledgment）" class="headerlink" title="确认ACK（ACKnowledgment）"></a>确认ACK（ACKnowledgment）</h4><p>仅当 ACK=1 时确认号字段才有效，当 ACK=0 时确认号无效。TCP 规定，在连接建立后所有的传送的报文段都必须把 ACK 置为 1。</p><h4 id="推送-PSH（PuSH）"><a href="#推送-PSH（PuSH）" class="headerlink" title="推送 PSH（PuSH）"></a>推送 PSH（PuSH）</h4><p>当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH=1 的报文段，就尽快地交付接收应用进程。<br>复位RST（ReSeT）<br>当 RST=1 时，表名 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST 置为 1 用来拒绝一个非法的报文段或拒绝打开一个连接。</p><h4 id="同步SYN（SYNchronization）"><a href="#同步SYN（SYNchronization）" class="headerlink" title="同步SYN（SYNchronization）"></a>同步SYN（SYNchronization）</h4><p>在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN=1 和 ACK=1，因此 SYN 置为 1 就表示这是一个连接请求或连接接受报文。</p><h4 id="终止FIN（FINis，意思是“完”“终”）"><a href="#终止FIN（FINis，意思是“完”“终”）" class="headerlink" title="终止FIN（FINis，意思是“完”“终”）"></a>终止FIN（FINis，意思是“完”“终”）</h4><p>用来释放一个连接。当 FIN=1 时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p><h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>占 2 字节，窗口值是[0，2^16-1]之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据，作为流量控制的依据，后面会详细介绍。<br>总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。</p><h3 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h3><p>占 2 字节，检验和字段检验的范围包括首部和数据这两部分。和 UDP 用户数据报一样，在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。伪首部的格式和 UDP 用户数据报的伪首部一样。但应把伪首部第 4 个字段中的 17 改为 6（TCP 的协议号是 6）；把第 5 字段中的 UDP 中的长度改为 TCP 长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用 IPv6，则相应的伪首部也要改变。</p><h3 id="紧急指针"><a href="#紧急指针" class="headerlink" title="紧急指针"></a>紧急指针</h3><p>占 2 字节，紧急指针仅在 URG=1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据) 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为 0 时也可以发送紧急数据。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>选项长度可变，最长可达 40 字节。当没有使用“选项”时，TCP 的首部长度是 20 字节。TCP 首部总长度由 TCP 头中的“数据偏移”字段决定，前面说了，最长偏移为 60 字节。那么“tcp 选项”的长度最大为 60-20=40 字节。</p><h4 id="选项的一般结构体"><a href="#选项的一般结构体" class="headerlink" title="选项的一般结构体"></a>选项的一般结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  1byte    1byte        nbytes</span><br><span class="line">+--------+--------+------------------+ </span><br><span class="line">| Kind   | Length |       Info       |</span><br><span class="line">+--------+--------+------------------+</span><br></pre></td></tr></table></figure><p>TCP 最初只规定了一种选项，即最大报文段长度 MSS（Maximum Segment Szie）。后来又增加了几个选项如窗口扩大选项、时间戳选项等，下面说明常用的选项。</p><p>kind=0 是选项表结束选项。</p><p>kind=1 是空操作（nop）选项<br>没有特殊含义，一般用于将 TCP 选项的总长度填充为 4 字节的整数倍，为啥需要 4 字节整数倍？因为前面讲了数据偏移字段的单位是 4 个字节。</p><p>kind=2 是最大报文段长度选项<br>TCP 连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP 模块通常将 MSS 设置为（MTU-40）字节（减掉的这 40 字节包括 20 字节的 TCP 头部和 20 字节的 IP 头部）。这样携带 TCP 报文段的 IP 数据报的长度就不会超过 MTU（假设 TCP 头部和 IP 头部都不包含选项字段，并且这也是一般情况），从而避免本机发生 IP 分片。对以太网而言，MSS 值是 1460（1500-40）字节。</p><p>kind=3 是窗口扩大因子选项<br>TCP 连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在 TCP 的头部中，接收通告窗口大小是用 16 位表示的，故最大为 65535 字节，但实际上 TCP 模块允许的接收通告窗口大小远不止这个数（为了提高 TCP 通信的吞吐量）。窗口扩大因子解决了这个问题。假设 TCP 头部中的接收通告窗口大小是 N，窗口扩大因子（移位数）是 M，那么 TCP 报文段的实际接收通告窗口大小是 N 乘 2M，或者说 N 左移 M 位。注意，M 的取值范围是 0～14。</p><p>和 MSS 选项一样，窗口扩大因子选项只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该 TCP 报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。关于窗口扩大因子选项的细节，可参考标准文档 RFC 1323。</p><p>kind=4 是选择性确认（Selective Acknowledgment，SACK）选项<br>TCP 通信时，如果某个 TCP 报文段丢失，则 TCP 模块会重传最后被确认的 TCP 报文段后续的所有报文段，这样原先已经正确传输的 TCP 报文段也可能重复发送，从而降低了 TCP 性能。SACK 技术正是为改善这种情况而产生的，它使 TCP 模块只重新发送丢失的 TCP 报文段，不用发送所有未被确认的 TCP 报文段。选择性确认选项用在连接初始化时，表示是否支持 SACK 技术。</p><p>kind=5 是 SACK 实际工作的选项<br>该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿（edge of block）参数包含一个 4 字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用 8 字节，所以 TCP 头部选项中实际上最多可以包含 4 个这样的不连续数据块（考虑选项类型和长度占用的 2 字节）。</p><p>kind=8 是时间戳选项<br>该选项提供了较为准确的计算通信双方之间的回路时间（Round Trip Time，RTT）的方法，从而为 TCP 流量控制提供重要信息。</p><h2 id="多种状态的标志"><a href="#多种状态的标志" class="headerlink" title="多种状态的标志"></a>多种状态的标志</h2><h3 id="发起连接时的报文状态"><a href="#发起连接时的报文状态" class="headerlink" title="发起连接时的报文状态"></a>发起连接时的报文状态</h3><p>在连接建立时用来同步序号。当 <code>SYN=1</code> 而 <code>ACK=0</code> 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 <code>SYN=1</code> 和 <code>ACK=1</code>，因此 <code>SYN 置为 1</code> 就表示这是一个连接请求或连接接受报文。</p><h3 id="终端连接的报文状态"><a href="#终端连接的报文状态" class="headerlink" title="终端连接的报文状态"></a>终端连接的报文状态</h3><p>用来释放一个连接。当 FIN=1 时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;传输层-tcp-协议-实现&quot;&gt;&lt;a href=&quot;#传输层-tcp-协议-实现&quot; class=&quot;headerlink&quot; title=&quot;传输层 tcp 协议 实现&quot;&gt;&lt;/a&gt;传输层 tcp 协议 实现&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;43E
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>udp协议</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/udp/1.%E5%8D%8F%E8%AE%AE/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/udp/1.协议/</id>
    <published>2019-10-22T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="udp协议"><a href="#udp协议" class="headerlink" title="udp协议"></a>udp协议</h1><h2 id="udp协议-包体"><a href="#udp协议-包体" class="headerlink" title="udp协议 包体"></a>udp协议 包体</h2><p><img src="C5DAEAF2697B45D6927F108780C6324E" alt="image"></p><ol><li>源端口 源端口号</li><li>目的端口 目的端口号</li><li>长度 UDP 数据报的长度，包含首部，最小为 8</li><li>检验和 UDP 数据报的校验和，如果接收到检验和不正确的情况下，直接丢弃该报文。</li></ol><h2 id="计算校验和算法"><a href="#计算校验和算法" class="headerlink" title="计算校验和算法"></a>计算校验和算法</h2><p>UDP 计算校验和的方法和 IP 数据报首部校验和的方法相似。不同的是：IP 数据报校验和只校验 IP 数据报的首部，但 UDP 的校验和是把首部和数据部分一起都检验。</p><p>UDP 的校验和需要计算 UDP 首部加数据荷载部分，但也需要加上 UDP 伪首部。这个伪首部指，源地址、目的地址、UDP 数据长度、协议类型（0x11），协议类型就一个字节，但需要补一个字节的 0x0，构成 12 个字节。伪首部+UDP 首部+数据一起计算校验和。</p><p>UDP 检验和的计算方法是：<br>按每 16 位求和得出一个 32 位的数；<br>如果这个 32 位的数，高 16 位不为 0，则高 16 位加低 16 位再得到一个 32 位的数；<br>重复第 2 步直到高 16 位为 0，将低 16 位取反，得到校验和。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;udp协议&quot;&gt;&lt;a href=&quot;#udp协议&quot; class=&quot;headerlink&quot; title=&quot;udp协议&quot;&gt;&lt;/a&gt;udp协议&lt;/h1&gt;&lt;h2 id=&quot;udp协议-包体&quot;&gt;&lt;a href=&quot;#udp协议-包体&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="udp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/udp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>websocket实现</title>
    <link href="http://blog.huido.site/wiki/net-protocol/2.%E5%BA%94%E7%94%A8%E5%B1%82/websocket/3.websocket%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.huido.site/wiki/net-protocol/2.应用层/websocket/3.websocket实现/</id>
    <published>2019-10-21T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写基本的httpserver"><a href="#编写基本的httpserver" class="headerlink" title="编写基本的httpserver"></a>编写基本的httpserver</h2><h3 id="启动一个基本的httpserver，提供两个接口，一个index返回主页，另一个是就是我们自定义的websocket协议接口"><a href="#启动一个基本的httpserver，提供两个接口，一个index返回主页，另一个是就是我们自定义的websocket协议接口" class="headerlink" title="启动一个基本的httpserver，提供两个接口，一个index返回主页，另一个是就是我们自定义的websocket协议接口"></a>启动一个基本的httpserver，提供两个接口，一个<code>index</code>返回主页，另一个是就是我们自定义的<code>websocket</code>协议接口</h3><h3 id="main-go"><a href="#main-go" class="headerlink" title="@main.go"></a>@main.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/pkg/logging"</span></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/protocol/application/http"</span></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/protocol/application/websocket"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">logging.Setup()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">serv := http.NewHTTP(<span class="string">"tap1"</span>, <span class="string">"192.168.1.0/24"</span>, <span class="string">"192.168.1.1"</span>, <span class="string">"9502"</span>)</span><br><span class="line">serv.HandleFunc(<span class="string">"/ws"</span>, echo)</span><br><span class="line"></span><br><span class="line">serv.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(request *http.Request, response *http.Response)</span></span> &#123;</span><br><span class="line">response.End(<span class="string">"hello"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">"@main: server is start ip:192.168.1.1 port:9502 "</span>)</span><br><span class="line">serv.ListenAndServ()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//websocket处理器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(r *http.Request, w *http.Response)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"got http request ; start to  upgrade websocket protocol...."</span>)</span><br><span class="line"><span class="comment">//协议升级 c *websocket.Conn</span></span><br><span class="line">c, err := websocket.Upgrade(r, w)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//升级协议失败，直接return 交由http处理响应</span></span><br><span class="line">fmt.Println(<span class="string">"Upgrade error:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"><span class="comment">//循环处理数据，接受数据，然后返回</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">message, err := c.ReadData()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">"read:"</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"recv client msg:"</span>, <span class="keyword">string</span>(message))</span><br><span class="line"><span class="comment">// c.SendData(message )</span></span><br><span class="line">c.SendData([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="echo-接口接受http请求并进行升级我们的websocket"><a href="#echo-接口接受http请求并进行升级我们的websocket" class="headerlink" title="echo 接口接受http请求并进行升级我们的websocket"></a>echo 接口接受http请求并进行升级我们的websocket</h3><h3 id="页面如下"><a href="#页面如下" class="headerlink" title="页面如下"></a>页面如下</h3><p><img src="/images/websocket.png" alt="index"></p><h2 id="自定义的webscoket-upgrade进行升级"><a href="#自定义的webscoket-upgrade进行升级" class="headerlink" title="自定义的webscoket upgrade进行升级"></a>自定义的webscoket upgrade进行升级</h2><h3 id="根据之前的协议分析，我知道握手的过程其实就是检查-HTTP-请求头部字段的过程，值得注意的一点就是需要针对客户端发送的-Sec-WebSocket-Key-生成一个正确的-Sec-WebSocket-Accept-只。关于生成的-Sec-WebSocket-Accpet-的实现，可以参考之前的分析。握手过程的具体代码如下："><a href="#根据之前的协议分析，我知道握手的过程其实就是检查-HTTP-请求头部字段的过程，值得注意的一点就是需要针对客户端发送的-Sec-WebSocket-Key-生成一个正确的-Sec-WebSocket-Accept-只。关于生成的-Sec-WebSocket-Accpet-的实现，可以参考之前的分析。握手过程的具体代码如下：" class="headerlink" title="根据之前的协议分析，我知道握手的过程其实就是检查 HTTP 请求头部字段的过程，值得注意的一点就是需要针对客户端发送的 Sec-WebSocket-Key 生成一个正确的 Sec-WebSocket-Accept 只。关于生成的 Sec-WebSocket-Accpet 的实现，可以参考之前的分析。握手过程的具体代码如下："></a>根据之前的协议分析，我知道握手的过程其实就是检查 HTTP 请求头部字段的过程，值得注意的一点就是需要针对客户端发送的 <code>Sec-WebSocket-Key</code> 生成一个正确的 <code>Sec-WebSocket-Accept</code> 只。关于生成的 <code>Sec-WebSocket-Accpet</code> 的实现，可以参考之前的分析。握手过程的具体代码如下：</h3><h3 id="upgrade-go"><a href="#upgrade-go" class="headerlink" title="@upgrade.go"></a>@upgrade.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> websocket</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upgrade</span><span class="params">(w http.ResponseWriter,r *http.Request)</span><span class="params">(c *Conn,err error)</span></span>&#123;</span><br><span class="line">    <span class="comment">//是否是Get方法</span></span><br><span class="line">    <span class="keyword">if</span> r.Method != <span class="string">"GET"</span> &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusMethodNotAllowed),http.StatusMethodNotAllowed)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:method not GET"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查 Sec-WebSocket-Version 版本</span></span><br><span class="line">    <span class="keyword">if</span> values := r.Header[<span class="string">"Sec-Websocket-Version"</span>];<span class="built_in">len</span>(values) == <span class="number">0</span> || values[<span class="number">0</span>] != <span class="string">"13"</span> &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:version != 13"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查Connection 和  Upgrade</span></span><br><span class="line">    <span class="keyword">if</span> !tokenListContainsValue(r.Header,<span class="string">"Connection"</span>,<span class="string">"upgrade"</span>) &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:could not find connection header with token 'upgrade'"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !tokenListContainsValue(r.Header,<span class="string">"Upgrade"</span>,<span class="string">"websocket"</span>) &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:could not find connection header with token 'websocket'"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算Sec-Websocket-Accept的值</span></span><br><span class="line">    challengeKey := r.Header.Get(<span class="string">"Sec-Websocket-Key"</span>)</span><br><span class="line">    <span class="keyword">if</span> challengeKey == <span class="string">""</span> &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:key missing or blank"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        netConn net.Conn</span><br><span class="line">        br *bufio.Reader</span><br><span class="line">    )</span><br><span class="line">    h,ok := w.(http.Hijacker)</span><br><span class="line">    <span class="keyword">if</span>  !ok &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusInternalServerError),http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:response dose not implement http.Hijacker"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> rw *bufio.ReadWriter</span><br><span class="line">    <span class="comment">//接管当前tcp连接，阻止内置http接管连接</span></span><br><span class="line">    netConn,rw,err = h.Hijack()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusInternalServerError),http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    br = rw.Reader</span><br><span class="line">    <span class="keyword">if</span> br.Buffered() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        netConn.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:client send data before hanshake is complete"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造握手成功后返回的 response</span></span><br><span class="line">    p := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">    p = <span class="built_in">append</span>(p, <span class="string">"HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: "</span>...)</span><br><span class="line">    p = <span class="built_in">append</span>(p, computeAcceptKey(challengeKey)...)</span><br><span class="line">    p = <span class="built_in">append</span>(p, <span class="string">"\r\n\r\n"</span>...)</span><br><span class="line">    <span class="comment">//返回repson 但不关闭连接</span></span><br><span class="line">    <span class="keyword">if</span> _,err = netConn.Write(p);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        netConn.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//升级为websocket</span></span><br><span class="line">    log.Println(<span class="string">"Upgrade http to websocket successfully"</span>)</span><br><span class="line">    conn := newConn(netConn)</span><br><span class="line">    <span class="keyword">return</span> conn,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="握手过程的代码比较直观，就不多做解释了。到这里-WebSocket-的实现就基本完成了，可以看到有了之前的各种约定，我们实现-WebSocket-协议也是比较简单的。"><a href="#握手过程的代码比较直观，就不多做解释了。到这里-WebSocket-的实现就基本完成了，可以看到有了之前的各种约定，我们实现-WebSocket-协议也是比较简单的。" class="headerlink" title="握手过程的代码比较直观，就不多做解释了。到这里 WebSocket 的实现就基本完成了，可以看到有了之前的各种约定，我们实现 WebSocket 协议也是比较简单的。"></a>握手过程的代码比较直观，就不多做解释了。到这里 WebSocket 的实现就基本完成了，可以看到有了之前的各种约定，我们实现 WebSocket 协议也是比较简单的。</h3><h2 id="封装的websocket结构体和对应的方法"><a href="#封装的websocket结构体和对应的方法" class="headerlink" title="封装的websocket结构体和对应的方法"></a>封装的websocket结构体和对应的方法</h2><h3 id="conn-go"><a href="#conn-go" class="headerlink" title="@conn.go"></a>@conn.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> websocket</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 是否是最后一个数据帧</span></span><br><span class="line"><span class="comment">    * Fin Rsv1 Rsv2 Rsv3 Opcode</span></span><br><span class="line"><span class="comment">    *  1  0    0    0    0 0 0 0  =&gt; 128</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    finalBit = <span class="number">1</span> &lt;&lt; <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 是否需要掩码处理</span></span><br><span class="line"><span class="comment">    *  Mask payload-len 第一位mask表示是否需要进行掩码处理 后面</span></span><br><span class="line"><span class="comment">    *  7位表示数据包长度 1.0-125 表示长度 2.126 后面需要扩展2 字节 16bit</span></span><br><span class="line"><span class="comment">    *  3.127则扩展8bit</span></span><br><span class="line"><span class="comment">    *  1    0 0 0 0 0 0 0  =&gt; 128</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    maskBit = <span class="number">1</span> &lt;&lt; <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 文本帧类型</span></span><br><span class="line"><span class="comment">    * 0 0 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TextMessage = <span class="number">1</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 关闭数据帧类型</span></span><br><span class="line"><span class="comment">    * 0 0 0 0 1 0 0 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    CloseMessage = <span class="number">8</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//websocket 连接</span></span><br><span class="line"><span class="keyword">type</span> Conn <span class="keyword">struct</span> &#123;</span><br><span class="line">    writeBuf []<span class="keyword">byte</span></span><br><span class="line">    maskKey [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">    conn net.Conn</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newConn</span><span class="params">(conn net.Conn)</span>*<span class="title">Conn</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Conn&#123;conn:conn&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span><span class="title">Close</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c.conn.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span><span class="title">SendData</span><span class="params">(data []<span class="keyword">byte</span>)</span></span>&#123;</span><br><span class="line">    length := <span class="built_in">len</span>(data)</span><br><span class="line">    c.writeBuf = <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">10</span> + length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据开始和结束位置</span></span><br><span class="line">    payloadStart := <span class="number">2</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *数据帧的第一个字节，不支持且只能发送文本类型数据</span></span><br><span class="line"><span class="comment">    *finalBit 1 0 0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">    *                |</span></span><br><span class="line"><span class="comment">    *Text     0 0 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">    * =&gt;      1 0 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    c.writeBuf[<span class="number">0</span>] = <span class="keyword">byte</span>(TextMessage) | finalBit</span><br><span class="line">    fmt.Printf(<span class="string">"1 bit:%b\n"</span>,c.writeBuf[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据帧第二个字节，服务器发送的数据不需要进行掩码处理</span></span><br><span class="line">    <span class="keyword">switch</span>&#123;</span><br><span class="line">    <span class="comment">//大于2字节的长度</span></span><br><span class="line">    <span class="keyword">case</span> length &gt;= <span class="number">1</span> &lt;&lt; <span class="number">16</span> :<span class="comment">//65536</span></span><br><span class="line">        <span class="comment">//c.writeBuf[1] = byte(0x00) | 127 // 127</span></span><br><span class="line">        c.writeBuf[<span class="number">1</span>] = <span class="keyword">byte</span>(<span class="number">127</span>) <span class="comment">// 127</span></span><br><span class="line">        <span class="comment">//大端写入64位</span></span><br><span class="line">        binary.BigEndian.PutUint64(c.writeBuf[payloadStart:],<span class="keyword">uint64</span>(length))</span><br><span class="line">        <span class="comment">//需要8byte来存储数据长度</span></span><br><span class="line">        payloadStart += <span class="number">8</span></span><br><span class="line">    <span class="keyword">case</span> length &gt; <span class="number">125</span>:</span><br><span class="line">        <span class="comment">//c.writeBuf[1] = byte(0x00) | 126</span></span><br><span class="line">        c.writeBuf[<span class="number">1</span>] = <span class="keyword">byte</span>(<span class="number">126</span>)</span><br><span class="line">        binary.BigEndian.PutUint16(c.writeBuf[payloadStart:],<span class="keyword">uint16</span>(length))</span><br><span class="line">        payloadStart += <span class="number">2</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//c.writeBuf[1] = byte(0x00) | byte(length)</span></span><br><span class="line">        c.writeBuf[<span class="number">1</span>] = <span class="keyword">byte</span>(length)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"2 bit:%b\n"</span>,c.writeBuf[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">copy</span>(c.writeBuf[payloadStart:],data[:])</span><br><span class="line">    c.conn.Write(c.writeBuf[:payloadStart+length])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span><span class="title">ReadData</span><span class="params">()</span><span class="params">(data []<span class="keyword">byte</span>,err error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b [<span class="number">8</span>]<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//读取数据帧的前两个字节</span></span><br><span class="line">    <span class="keyword">if</span> _,err := c.conn.Read(b[:<span class="number">2</span>]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始解析第一个字节 是否还有后续数据帧</span></span><br><span class="line">    final := b[<span class="number">0</span>] &amp; finalBit != <span class="number">0</span></span><br><span class="line">    fmt.Printf(<span class="string">"read data 1 bit :%b\n"</span>,b[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">//不支持数据分片</span></span><br><span class="line">    <span class="keyword">if</span> !final &#123;</span><br><span class="line">        log.Println(<span class="string">"Recived fragemented frame,not support"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"not suppeort fragmented message"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据帧类型</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *1 0 0 0  0 0 0 1</span></span><br><span class="line"><span class="comment">    *        &amp;</span></span><br><span class="line"><span class="comment">    *0 0 0 0  1 1 1 1</span></span><br><span class="line"><span class="comment">    *0 0 0 0  0 0 0 1</span></span><br><span class="line"><span class="comment">    * =&gt; 1 这样就可以直接获取到类型了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    frameType := <span class="keyword">int</span>(b[<span class="number">0</span>] &amp; <span class="number">0xf</span>)</span><br><span class="line">    <span class="comment">//如果 关闭类型，则关闭连接</span></span><br><span class="line">    <span class="keyword">if</span> frameType == CloseMessage &#123;</span><br><span class="line">        c.conn.Close()</span><br><span class="line">        log.Println(<span class="string">"Recived closed message,connection will be closed"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"recived closed message"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只实现了文本格式的传输,编码utf-8</span></span><br><span class="line">    <span class="keyword">if</span> frameType != TextMessage &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"only support text message"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查数据帧是否被掩码处理</span></span><br><span class="line">    <span class="comment">//maskBit =&gt; 1 0 0 0 0 0 0 0 任何与他 要么为0 要么为 128</span></span><br><span class="line">    mask := b[<span class="number">1</span>] &amp; maskBit != <span class="number">0</span></span><br><span class="line">    <span class="comment">//数据长度</span></span><br><span class="line">    payloadLen := <span class="keyword">int64</span>(b[<span class="number">1</span>] &amp; <span class="number">0x7F</span>)<span class="comment">//0 1 1 1 1 1 1 1 1 127</span></span><br><span class="line">    dataLen := <span class="keyword">int64</span>(payloadLen)</span><br><span class="line">    <span class="comment">//根据payload length 判断数据的真实长度</span></span><br><span class="line">    <span class="keyword">switch</span> payloadLen &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">126</span>:<span class="comment">//扩展2字节</span></span><br><span class="line">        <span class="keyword">if</span> _,err := c.conn.Read(b[:<span class="number">2</span>]);err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取扩展二字节的真实数据长度</span></span><br><span class="line">        dataLen = <span class="keyword">int64</span>(binary.BigEndian.Uint16(b[:<span class="number">2</span>]))</span><br><span class="line">    <span class="keyword">case</span> <span class="number">127</span> :</span><br><span class="line">        <span class="keyword">if</span> _,err := c.conn.Read(b[:<span class="number">8</span>]);err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">        &#125;</span><br><span class="line">        dataLen = <span class="keyword">int64</span>(binary.BigEndian.Uint64(b[:<span class="number">8</span>]))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">"Read data length :%d,payload length %d"</span>,payloadLen,dataLen)</span><br><span class="line">    <span class="comment">//读取mask key</span></span><br><span class="line">    <span class="keyword">if</span> mask &#123;<span class="comment">//如果需要掩码处理的话 需要取出key</span></span><br><span class="line">        <span class="comment">//maskKey 是 4 字节  32位</span></span><br><span class="line">        <span class="keyword">if</span> _,err := c.conn.Read(c.maskKey[:]);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> ,err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取数据内容</span></span><br><span class="line">    p := <span class="built_in">make</span>([]<span class="keyword">byte</span>,dataLen)</span><br><span class="line">    <span class="keyword">if</span> _,err := c.conn.Read(p);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mask &#123;</span><br><span class="line">        maskBytes(c.maskKey,p)<span class="comment">//进行解码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="http-头部检查"><a href="#http-头部检查" class="headerlink" title="http 头部检查"></a>http 头部检查</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/sha1"</span></span><br><span class="line">    <span class="string">"encoding/base64"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> KeyGUID = []<span class="keyword">byte</span>(<span class="string">"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</span>)</span><br><span class="line"><span class="comment">//握手阶段使用 加密key返回 进行握手</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">computeAcceptKey</span><span class="params">(challengeKey <span class="keyword">string</span>)</span><span class="title">string</span></span>&#123;</span><br><span class="line">    h := sha1.New()</span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(challengeKey))</span><br><span class="line">    h.Write(KeyGUID)</span><br><span class="line">    <span class="keyword">return</span> base64.StdEncoding.EncodeToString(h.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maskBytes</span><span class="params">(key [4]<span class="keyword">byte</span>,b []<span class="keyword">byte</span>)</span></span>&#123;</span><br><span class="line">    pos := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> b &#123;</span><br><span class="line">        b[i] ^= key[pos &amp; <span class="number">3</span>]</span><br><span class="line">        pos ++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查http 头部字段中是否包含指定的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tokenListContainsValue</span><span class="params">(header http.Header, name <span class="keyword">string</span>, value <span class="keyword">string</span>)</span><span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> header[name] &#123;</span><br><span class="line">        <span class="keyword">for</span> _, s := <span class="keyword">range</span> strings.Split(v,<span class="string">","</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> strings.EqualFold(value,strings.TrimSpace(s)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编写基本的httpserver&quot;&gt;&lt;a href=&quot;#编写基本的httpserver&quot; class=&quot;headerlink&quot; title=&quot;编写基本的httpserver&quot;&gt;&lt;/a&gt;编写基本的httpserver&lt;/h2&gt;&lt;h3 id=&quot;启动一个基本的httpse
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="2.应用层" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
      <category term="websocket" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/websocket/"/>
    
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="golang" scheme="http://blog.huido.site/tags/golang/"/>
    
      <category term="websocket" scheme="http://blog.huido.site/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>websocket协议解析</title>
    <link href="http://blog.huido.site/wiki/net-protocol/2.%E5%BA%94%E7%94%A8%E5%B1%82/websocket/1.websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.huido.site/wiki/net-protocol/2.应用层/websocket/1.websocket协议解析/</id>
    <published>2019-10-21T13:28:59.000Z</published>
    <updated>2019-11-04T14:13:34.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="websocket-协议报文"><a href="#websocket-协议报文" class="headerlink" title="websocket 协议报文"></a>websocket 协议报文</h2><p>websocket协议也是基于<code>tcp协议</code>，和http不同的是，tcp接受的数据包为<code>二进制帧</code>，而http为<code>字符串数据包</code>。并且websocket协议在连接阶段会触发一个<code>http请求</code>进行websocket协议校验。校验成功后才会接管tcp通讯流程不会断开该http连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">websocket 数据帧报文</span><br><span class="line"></span><br><span class="line">  0               1               2               3               4</span><br><span class="line">  0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8</span><br><span class="line">  +-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">  |F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">  |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">  |N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">  | |1|2|3|       |K|             |                               |</span><br><span class="line">  +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">  |     Extended payload length continued, if payload len == 127  |</span><br><span class="line">  + - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">  |                               |Masking-key, if MASK set to 1  |</span><br><span class="line">  +-------------------------------+-------------------------------+</span><br><span class="line">  | Masking-key (continued)       |          Payload Data         |</span><br><span class="line">  +-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">  :                     Payload Data continued ...                :</span><br><span class="line">  + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">  |                     Payload Data continued ...                |</span><br><span class="line">  +---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h2 id="WebSocket协议详解"><a href="#WebSocket协议详解" class="headerlink" title="WebSocket协议详解"></a>WebSocket协议详解</h2><p>WebSocket 协议解决了浏览器和服务器之间的全双工通信问题。在 WebSocket 出现之前，浏览器如果需要从服务器及时获得更新，则需要不停的对服务器主动发起请求，也就是 Web 中常用的poll技术。这样的操作非常低效，这是因为每发起一次新的 HTTP 请求，就需要单独开启一个新的 TCP 链接，同时 HTTP 协议本身也是一种开销非常大的协议。为了解决这些问题，所以出现了 WebSocket 协议。WebSocket 使得浏览器和服务器之间能通过一个持久的 TCP 链接就能完成数据的双向通信。关于 WebSocket 的 RFC 提案，可以参看RFC6455。</p><p>WebSocket 和 HTTP 协议一般情况下都工作在浏览器中，但 WebSocket 是一种完全不同于 HTTP 的协议。尽管，浏览器需要通过 HTTP 协议的GET请求，将 HTTP 协议升级为 WebSocket 协议。升级的过程被称为握手(handshake)。当浏览器和服务器成功握手后，则可以开始根据 WebSocket 定义的通信帧格式开始通信了。像其他各种协议一样，WebSocket 协议的通信帧也分为控制数据帧和普通数据帧，前者用于控制 WebSocket 链接状态，后者用于承载数据。下面我们将一一分析 WebSocket 协议的握手过程以及通信帧格式。</p><h2 id="一、websocket握手"><a href="#一、websocket握手" class="headerlink" title="一、websocket握手"></a>一、websocket握手</h2><h3 id="握手的过程也就是将HTTP协议升级为WebSocket协议的过程，握手开始首先由浏览器端发送一个GET请求，该请求的HTTP头部信息如下"><a href="#握手的过程也就是将HTTP协议升级为WebSocket协议的过程，握手开始首先由浏览器端发送一个GET请求，该请求的HTTP头部信息如下" class="headerlink" title="握手的过程也就是将HTTP协议升级为WebSocket协议的过程，握手开始首先由浏览器端发送一个GET请求，该请求的HTTP头部信息如下:"></a>握手的过程也就是将HTTP协议升级为WebSocket协议的过程，握手开始首先由浏览器端发送一个<code>GET</code>请求，该请求的HTTP头部信息如下:</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Origin</span>: http://example.com</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protcol</span>: chat, superchat</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</span><br></pre></td></tr></table></figure><h3 id="当服务器端，成功验证了以上信息后，则会返回一个形如以下的响应："><a href="#当服务器端，成功验证了以上信息后，则会返回一个形如以下的响应：" class="headerlink" title="当服务器端，成功验证了以上信息后，则会返回一个形如以下的响应："></a>当服务器端，成功验证了以上信息后，则会返回一个形如以下的响应：</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span>: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat</span><br></pre></td></tr></table></figure><h3 id="可以看到，浏览器发送端HTTP请求中，增加了一些新端字段，其作用如下所示："><a href="#可以看到，浏览器发送端HTTP请求中，增加了一些新端字段，其作用如下所示：" class="headerlink" title="可以看到，浏览器发送端HTTP请求中，增加了一些新端字段，其作用如下所示："></a>可以看到，浏览器发送端HTTP请求中，增加了一些新端字段，其作用如下所示：</h3><ul><li><code>Upgrade</code>: 规定必需的字段，其值必需为 <code>websocket</code>, 如果不是则握手失败；</li><li><code>Connection</code>: 规定必需的字段，值必需为 <code>Upgrade</code>, 如果不是则握手失败；<br><code>Sec-WebSocket-Key</code>: 必需字段，一个随机的字符串；<br><code>Sec-WebSocket-Protocol</code>: 可选字段，可以用于标识应用层的协议；<br><code>Sec-WebSocket-Version</code>: 必需字段，代表了 WebSocket 协议版本，值必需是 <code>13</code>, 否则握手失败；<h3 id="返回端响应中，如果握手成功会返回状态码101的HTTP响应，同时其他字段说明如下："><a href="#返回端响应中，如果握手成功会返回状态码101的HTTP响应，同时其他字段说明如下：" class="headerlink" title="返回端响应中，如果握手成功会返回状态码101的HTTP响应，同时其他字段说明如下："></a>返回端响应中，如果握手成功会返回状态码<code>101</code>的HTTP响应，同时其他字段说明如下：</h3></li><li><code>Upgrade</code>: 规定必需的字段，其值必需为 <code>websocket</code>, 如果不是则握手失败；</li><li><code>Connection</code>: 规定必需的字段，值必需为 <code>Upgrade</code>, 如果不是则握手失败；</li><li><code>Sec-WebSocket-Accept</code>: 规定必需的字段，该字段的值是通过固定字符串<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>加上请求中<code>Sec-WebSocket-Key</code>字段的值，然后再对其结果通过 <code>SHA1</code> 哈希算法求出的结果。</li><li><code>Sec-WebSocket-Protocol</code>: 对应于请求中的 <code>Sec-WebSocket-Protocol</code> 字段；<h3 id="当浏览器和服务端成功握手后，就可以传递数据了，传送数据是按照WebSocket的数据格式生成的"><a href="#当浏览器和服务端成功握手后，就可以传递数据了，传送数据是按照WebSocket的数据格式生成的" class="headerlink" title="当浏览器和服务端成功握手后，就可以传递数据了，传送数据是按照WebSocket的数据格式生成的"></a>当浏览器和服务端成功握手后，就可以传递数据了，传送数据是按照WebSocket的数据格式生成的</h3><h2 id="二、WebSocket协议数据帧"><a href="#二、WebSocket协议数据帧" class="headerlink" title="二、WebSocket协议数据帧"></a>二、WebSocket协议数据帧</h2><h3 id="数据帧的定义类似与TCP-IP的格式定义，具体看下图："><a href="#数据帧的定义类似与TCP-IP的格式定义，具体看下图：" class="headerlink" title="数据帧的定义类似与TCP/IP的格式定义，具体看下图："></a>数据帧的定义类似与TCP/IP的格式定义，具体看下图：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure></li></ul><h3 id="以上这张图，一行代表32bit（位），也就是4bytes（字节），总体上包含两份，帧头部和数据内容。每个从WebSocket链接中接受到的数据帧，都要按照以上格式进行解析，这样才能知道该数据帧是用于控制的还是用于传送数据的，关于以上数据帧的各个比特位的解释如下："><a href="#以上这张图，一行代表32bit（位），也就是4bytes（字节），总体上包含两份，帧头部和数据内容。每个从WebSocket链接中接受到的数据帧，都要按照以上格式进行解析，这样才能知道该数据帧是用于控制的还是用于传送数据的，关于以上数据帧的各个比特位的解释如下：" class="headerlink" title="以上这张图，一行代表32bit（位），也就是4bytes（字节），总体上包含两份，帧头部和数据内容。每个从WebSocket链接中接受到的数据帧，都要按照以上格式进行解析，这样才能知道该数据帧是用于控制的还是用于传送数据的，关于以上数据帧的各个比特位的解释如下："></a>以上这张图，一行代表32bit（位），也就是4bytes（字节），总体上包含两份，帧头部和数据内容。每个从WebSocket链接中接受到的数据帧，都要按照以上格式进行解析，这样才能知道该数据帧是用于控制的还是用于传送数据的，关于以上数据帧的各个比特位的解释如下：</h3><ul><li><code>FIN</code>:1bit,当该比特位值为%x0时，表示后面还有更多的数据帧，%x1时表示这是最后一个数据帧；</li><li><code>RSV1</code>,<code>RSV2</code>,<code>RSV3</code>:各占1个比特位。一般情况下全为0，当客户端、服务端协商采用WebSocket扩展时，这三个标识位可以非0，且值当含义由扩展进行定义，如果出现非0当值，且没有采用WebSocket扩展，则链接出错</li><li><code>opcode</code>:4 bit,用于表明数据帧当类型，一共可以表示16种帧类型，如下所示：<ul><li>%x0:表示这是一个分片当帧，它属于前面帧当后续帧；</li><li>%x1:表示该数据帧携带的数据类型是文本类型，且编码utf-8</li><li>%x2 : 表示携带的是二进制数据；</li><li>%x3-7 : 保留未使用；</li><li>%x8 : 表示该帧用于关闭 WebSocket 链接；</li><li>%x9 : 表示该帧代表了 ping 操作；</li><li>%xA : 表示该帧代表了 pong 回应；</li><li>%xB-F : 保留未使用；</li></ul></li><li><code>MASK</code>:1 bit,%x0表示数据帧没有经过掩码计算，而%x1则表示数据帧已经经过掩码计算，得到真正当数据需要解码，一般情况下，只有浏览器发送给服务端当数据帧才需要进行掩码计算；</li><li><code>Payload len</code>:7 bit,表示了数据帧携带当数据长度，7 bit 的值根据三种情况，帧的解析有所不同：<ul><li>%x0 - 7D : 也就是从 0 到 125，表示数据长度, 数据总长度也就是 7 bit 代表的长度；</li><li>%x7E : 7 bit 的值是 126 时，则后续的 2 个字节（16 bit)表示的一个 16 位无符号数，这个数用来表示数据的长度；</li><li>%x7F : 7 bit 的值是 127 时，则后续的 8 个字节（64 bit)表示的一个 64 位无符号数，这个数用来表示数据的长度；<ul><li><code>Masking-key</code>: 32 bit, 表示了用于解码的 key，只有当 MASK 比特位的值为 %x1 是，才有该数据；   </li></ul></li></ul></li><li><code>Payload Data</code>: 余下的比特位用于存储具体的数据；<h3 id="通过以上分析可以看出，WebSocket-协议数据帧的最大头部为-2-8-4-14-bytes-也就是-14-个字节。同时我们要实现-WebSocket-协议，最主要的工作就是实现对数据帧的解析。"><a href="#通过以上分析可以看出，WebSocket-协议数据帧的最大头部为-2-8-4-14-bytes-也就是-14-个字节。同时我们要实现-WebSocket-协议，最主要的工作就是实现对数据帧的解析。" class="headerlink" title="通过以上分析可以看出，WebSocket 协议数据帧的最大头部为 2 + 8 + 4 = 14 bytes 也就是 14 个字节。同时我们要实现 WebSocket 协议，最主要的工作就是实现对数据帧的解析。"></a>通过以上分析可以看出，WebSocket 协议数据帧的最大头部为 2 + 8 + 4 = 14 bytes 也就是 14 个字节。同时我们要实现 WebSocket 协议，最主要的工作就是实现对数据帧的解析。</h3></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;websocket-协议报文&quot;&gt;&lt;a href=&quot;#websocket-协议报文&quot; class=&quot;headerlink&quot; title=&quot;websocket 协议报文&quot;&gt;&lt;/a&gt;websocket 协议报文&lt;/h2&gt;&lt;p&gt;websocket协议也是基于&lt;code&gt;t
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="2.应用层" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
      <category term="websocket" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/websocket/"/>
    
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="golang" scheme="http://blog.huido.site/tags/golang/"/>
    
      <category term="websocket" scheme="http://blog.huido.site/tags/websocket/"/>
    
  </entry>
  
</feed>
