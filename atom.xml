<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Brewlin&#39;s Wiki</title>
  
  <subtitle>found everthing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.huido.site/"/>
  <updated>2019-10-23T09:19:00.911Z</updated>
  <id>http://blog.huido.site/</id>
  
  <author>
    <name>brewlin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>3.tcp可靠性机制</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/3.tcp%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/3.tcp可靠性机制/</id>
    <published>2019-10-22T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcp-可靠性机制"><a href="#tcp-可靠性机制" class="headerlink" title="tcp 可靠性机制"></a>tcp 可靠性机制</h1><p>可靠性指的是网络层能通信的前提下，保证数据包正确且按序到达对端。 比如发送端发送了“12345678”，那么接收端一定能收到“12345678”，不会乱序“12456783”，也不会少或多数据。</p><h2 id="实现-TCP-的可靠传输有以下机制："><a href="#实现-TCP-的可靠传输有以下机制：" class="headerlink" title="实现 TCP 的可靠传输有以下机制："></a>实现 TCP 的可靠传输有以下机制：</h2><p>1.<code>校验和机制</code>（检测和重传受到损伤的报文段）</p><p>2.<code>确认应答机制</code>（保存失序到达的报文段直至缺失的报文到期，以及检测和丢弃重复的报文段）</p><p>3.<code>超时重传机制</code>（重传丢失的报文段）</p><h2 id="1-校验和"><a href="#1-校验和" class="headerlink" title="1.校验和"></a>1.校验和</h2><p>每个 tcp 段都包含了一个检验和字段，用来检查报文段是否收到损伤。如果某个报文段因检验和无效而被检查出受到损伤，就由终点 TCP 将其丢弃，并被认为是丢失了。TCP 规定每个报文段都必须使用 <code>16 位的检验和</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 校验和的计算</span><br><span class="line">func Checksum(buf []byte, initial uint16) uint16 &#123;</span><br><span class="line">v := uint32(initial)</span><br><span class="line"></span><br><span class="line">l := len(buf)</span><br><span class="line">if l&amp;1 != 0 &#123;</span><br><span class="line">l--</span><br><span class="line">v += uint32(buf[l]) &lt;&lt; 8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; l; i += 2 &#123;</span><br><span class="line">v += (uint32(buf[i]) &lt;&lt; 8) + uint32(buf[i+1])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return ChecksumCombine(uint16(v), uint16(v&gt;&gt;16))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-确认机制"><a href="#2-确认机制" class="headerlink" title="2.确认机制"></a>2.确认机制</h2><p>控制报文段不携带数据，但需要消耗一个序号，它也需要被确认，而 ACK 报文段永远不需要确认，ACK 报文段不消耗序号，也不需要被确认。在以前，TCP 只使用一种类型的确认，叫积累确认，目前 TCP 实现还实现了选择确认。</p><ul><li>累积确认（ACK）</li></ul><p>接收方通告它期望接收的下一个字节的序号，并忽略所有失序到达并被保存的报文段。有时这被称为肯定累积确认。在 TCP 首部的 32 位 ACK 字段用于积累确认，而它的值仅在 ACK 标志为 1 时才有效。举个例子来说，这里先不考虑 tcp 的序列号，如果发送方发了数据包 p1，p2，p3，p4；接受方成功收到 p1，p2，p4。那么接收方需要发回一个确认包，序号为 3(3 表示期望下一个收到的包的序号)，那么发送方就知道 p1 到 p2 都发送接收成功，必要时重发 p3。一个确认包确认了累积到某一序号的所有包，而不是对每个序号都发确认包。实际的 tcp 确认的都是序列号，而不是包的序号，但原理是一样的。</p><p>累积确认是快速重传的基础，这个后面讲拥塞控制的时候会详细说明。</p><p>累积确认是快速重传的基础，这个后面讲拥塞控制的时候会详细说明。</p><ul><li>选择确认（SACK）</li></ul><p>选择确认 SACK 要报告失序的数据块以及重复的报文段块，是为了更准确的告诉发送方需要重传哪些数据块。SACK 并没有取代 ACK，而是向发送方报告了更多的信息。SACK 是作为 TCP 首部末尾的选项来实现的。<br>首先是否要启动 sack，应该在握手的时候告诉对方自己是否开启了 sack，这个是通过 kind=4 是选择性确认（Selective Acknowledgment，SACK）选项来实现的。<br>实际传送 sack 信息的是 kind=5 的选项，其格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">         +--------+--------+</span><br><span class="line">         | Kind=5 | Length | </span><br><span class="line">+--------+--------+--------+---------+ </span><br><span class="line">|          Start of 1st Block        | </span><br><span class="line">+--------+--------+--------+---------+ </span><br><span class="line">|           End of 1st Block         | </span><br><span class="line">+--------+--------+--------+---------+ </span><br><span class="line">|                                    | </span><br><span class="line">/            . . . . . .             / </span><br><span class="line">|                                    | </span><br><span class="line">+--------+--------+--------+---------+ </span><br><span class="line">|          Start of nth Block        | </span><br><span class="line">+--------+--------+--------+---------+ </span><br><span class="line">|           End of nth Block         | </span><br><span class="line">+--------+--------+--------+---------+</span><br></pre></td></tr></table></figure></p><p>sack 的每个块是由两个参数构成的<code>{ Start, End }</code> Start 不连续块的第一个数据的序列号。End 不连续块的最后一个数据的序列号之后的序列号。 该选项参数告诉对方已经接收到并缓存的不连续的数据块，<code>注意都是已经接收的</code>，发送方可根据此信息检查究竟是哪个块丢失，从而发送相应的数据块。 比如下图：<br><img src="07D550B59368499399ABFDD70C3735A0" alt="image"><br>如图所示，tcp 接收方在接收到不连续的 tcp 段，可以看出，序号 1～1000，1501～3000，3501～4500 接收到了，但却少了序号 1001～1500，3001～3500 。 前面说了，sack <code>报告的是已接收的不连续的块</code>，在这个例子中，sack 块的内容为<code>{Start:1501, End:3001},{Start:3501, End:4501}</code>， 注意：这里的 End 不是接收到数据段最后的序列号，而是最后的序列号加 1。</p><h3 id="产生确认的情况-确认机制"><a href="#产生确认的情况-确认机制" class="headerlink" title="产生确认的情况 确认机制"></a>产生确认的情况 确认机制</h3><ol><li>当接收方收到了按序到达（序号是所期望的）的报文段，那么接收方就累积发送确认报文段。</li><li>当具有所期望的序号的报文段到达，而前一个按序到达的报文段还没有被确认，那么接收方就要立即发送 ACK 报文段。</li><li>当序号比期望的序号还大的失序报文段到达时，接收方立即发送 ACK 报文段，并宣布下一个期望的报文段序号。这将导致对丢失报文段的快重传。</li><li>当一个丢失的报文段到达时，接收方要发送 ACK 报文段，并宣布下一个所期望的序号。</li><li>如果到达一个重复的报文段，接收方丢弃该报文段，但是应当立即发送确认，指出下一个期望的报文段。</li><li>收到 fin 报文的时候，立即回复确认。</li></ol><h2 id="3-重传机制"><a href="#3-重传机制" class="headerlink" title="3.重传机制"></a>3.重传机制</h2><p>关于重传的基本概念<br>RTO 即超时重传时间<br>RTT 数据包往返时间<br>平均偏差是指单项测定值与平均值的偏差（取绝对值）之和，除以测定次数。<br><img src="DEE81BB910FD42709B8CF09BEBF8055C" alt="image"><br>可靠性的核心就是报文段的重传。在一个报文段发送时，它会被保存到一个队列中，直至被确认为止。当重传计时器超时，或者发送方收到该队列中第一个报文段的三个重复的 ACK 时，该报文段被重传。</p><p>超时重传的概念很简单，就是一定时间内未收到确认，进行再次发送，但是如何计算重传的时间确实 tcp 最复杂的问题之一，毕竟要适应各种网络情况。TCP 一个连接期间只有一个 RTO 计时器，目前大部分实现都是采用<code>Jacobaon/Karels 算法</code>，详细可以看<code>RFC6298</code>，其计算公式如下，</p><p>rto 的计算公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一次rtt计算： </span><br><span class="line">SRTT = R</span><br><span class="line">RTTVAR = R/2</span><br><span class="line">RTO = SRTT + max (G, K*RTTVAR)</span><br><span class="line">K = 4</span><br><span class="line"></span><br><span class="line">之后：</span><br><span class="line">RTTVAR = (1 - beta) * RTTVAR + beta * |SRTT - R&apos;|</span><br><span class="line">SRTT = (1 - alpha) * SRTT + alpha * R&apos;</span><br><span class="line">RTO = SRTT + max (G, K*RTTVAR)</span><br><span class="line">K = 4</span><br></pre></td></tr></table></figure></p><p>SRTT(smoothed round-trip time)平滑 RTT 时间<br>RTTVAR(round-trip time variation)RTT 变量，其实就是 rtt 平均偏差<br>G 表示系统时钟的粒度，一般很小，us 级别。 beta = 1/4, alpha = 1/8</p><p>发送方 TCP 的计时器时间到，TCP 发送队列中最前面的报文段（即序列号最小的报文段），并重启计时器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tcp-可靠性机制&quot;&gt;&lt;a href=&quot;#tcp-可靠性机制&quot; class=&quot;headerlink&quot; title=&quot;tcp 可靠性机制&quot;&gt;&lt;/a&gt;tcp 可靠性机制&lt;/h1&gt;&lt;p&gt;可靠性指的是网络层能通信的前提下，保证数据包正确且按序到达对端。 比如发送端发送了“
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>1.tcp头部</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/1.tcp%E5%A4%B4%E9%83%A8/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/1.tcp头部/</id>
    <published>2019-10-22T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传输层-tcp-协议-实现"><a href="#传输层-tcp-协议-实现" class="headerlink" title="传输层 tcp 协议 实现"></a>传输层 tcp 协议 实现</h1><p><img src="43E0E23D5D324B8CA750C4F99EF4E3A7" alt="image"></p><h2 id="首部协议格式"><a href="#首部协议格式" class="headerlink" title="首部协议格式"></a>首部协议格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |           |G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><h3 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h3><p>各占 2 个字节，分别 tcp 连接的源端口和目的端口。关于端口的概念之前已经介绍过了。</p><h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>占 4 字节，序号范围是[0，2^32 - 1]，共 2^32（即 4294967296）个序号。序号增加到 2^32-1 后，下一个序号就又回到 0。TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号（ISN）必须在连接建立时设置。<code>首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号</code>。例如，一报文段的序号是 301，而接待的数据共有 100 字节。这就表明：本报文段的数据的第一个字节的序号是 301，最后一个字节的序号是 400。显然，下一个报文段（如果还有的话）的数据序号应当从 401 开始，即下一个报文段的序号字段值应为 401。</p><h3 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h3><p>占 4 字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B 正确收到了 A 发送过来的一个报文段，其序号字段值是 501，而数据长度是 200 字节（序号 501~700），这表明 B 正确收到了 A 发送的到序号 700 为止的数据。因此，B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701。注意，现在确认号不是 501，也不是 700，而是 701。<br>总之：若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。TCP 除了第一个 SYN 报文之外，所有 TCP 报文都需要携带 ACK 状态位。</p><h3 id="数据偏移"><a href="#数据偏移" class="headerlink" title="数据偏移"></a>数据偏移</h3><p>占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。<code>这个字段实际上是指出 TCP 报文段的首部长度</code>。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是 4 个字节，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节。</p><h3 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h3><p>占 6 位，保留为今后使用，但目前应置为 0。</p><h3 id="控制报文标志"><a href="#控制报文标志" class="headerlink" title="控制报文标志"></a>控制报文标志</h3><h4 id="紧急URG（URGent）"><a href="#紧急URG（URGent）" class="headerlink" title="紧急URG（URGent）"></a>紧急URG（URGent）</h4><p>当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收 TCP 的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。<br>当 URG 置为 1 时，发送应用进程就告诉发送方的 TCP 有紧急数据要传送。于是发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。</p><h4 id="确认ACK（ACKnowledgment）"><a href="#确认ACK（ACKnowledgment）" class="headerlink" title="确认ACK（ACKnowledgment）"></a>确认ACK（ACKnowledgment）</h4><p>仅当 ACK=1 时确认号字段才有效，当 ACK=0 时确认号无效。TCP 规定，在连接建立后所有的传送的报文段都必须把 ACK 置为 1。</p><h4 id="推送-PSH（PuSH）"><a href="#推送-PSH（PuSH）" class="headerlink" title="推送 PSH（PuSH）"></a>推送 PSH（PuSH）</h4><p>当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH=1 的报文段，就尽快地交付接收应用进程。<br>复位RST（ReSeT）<br>当 RST=1 时，表名 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST 置为 1 用来拒绝一个非法的报文段或拒绝打开一个连接。</p><h4 id="同步SYN（SYNchronization）"><a href="#同步SYN（SYNchronization）" class="headerlink" title="同步SYN（SYNchronization）"></a>同步SYN（SYNchronization）</h4><p>在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN=1 和 ACK=1，因此 SYN 置为 1 就表示这是一个连接请求或连接接受报文。</p><h4 id="终止FIN（FINis，意思是“完”“终”）"><a href="#终止FIN（FINis，意思是“完”“终”）" class="headerlink" title="终止FIN（FINis，意思是“完”“终”）"></a>终止FIN（FINis，意思是“完”“终”）</h4><p>用来释放一个连接。当 FIN=1 时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p><h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>占 2 字节，窗口值是[0，2^16-1]之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据，作为流量控制的依据，后面会详细介绍。<br>总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。</p><h3 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h3><p>占 2 字节，检验和字段检验的范围包括首部和数据这两部分。和 UDP 用户数据报一样，在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。伪首部的格式和 UDP 用户数据报的伪首部一样。但应把伪首部第 4 个字段中的 17 改为 6（TCP 的协议号是 6）；把第 5 字段中的 UDP 中的长度改为 TCP 长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用 IPv6，则相应的伪首部也要改变。</p><h3 id="紧急指针"><a href="#紧急指针" class="headerlink" title="紧急指针"></a>紧急指针</h3><p>占 2 字节，紧急指针仅在 URG=1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据) 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为 0 时也可以发送紧急数据。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>选项长度可变，最长可达 40 字节。当没有使用“选项”时，TCP 的首部长度是 20 字节。TCP 首部总长度由 TCP 头中的“数据偏移”字段决定，前面说了，最长偏移为 60 字节。那么“tcp 选项”的长度最大为 60-20=40 字节。</p><h4 id="选项的一般结构体"><a href="#选项的一般结构体" class="headerlink" title="选项的一般结构体"></a>选项的一般结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  1byte    1byte        nbytes</span><br><span class="line">+--------+--------+------------------+ </span><br><span class="line">| Kind   | Length |       Info       |</span><br><span class="line">+--------+--------+------------------+</span><br></pre></td></tr></table></figure><p>TCP 最初只规定了一种选项，即最大报文段长度 MSS（Maximum Segment Szie）。后来又增加了几个选项如窗口扩大选项、时间戳选项等，下面说明常用的选项。</p><p>kind=0 是选项表结束选项。</p><p>kind=1 是空操作（nop）选项<br>没有特殊含义，一般用于将 TCP 选项的总长度填充为 4 字节的整数倍，为啥需要 4 字节整数倍？因为前面讲了数据偏移字段的单位是 4 个字节。</p><p>kind=2 是最大报文段长度选项<br>TCP 连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP 模块通常将 MSS 设置为（MTU-40）字节（减掉的这 40 字节包括 20 字节的 TCP 头部和 20 字节的 IP 头部）。这样携带 TCP 报文段的 IP 数据报的长度就不会超过 MTU（假设 TCP 头部和 IP 头部都不包含选项字段，并且这也是一般情况），从而避免本机发生 IP 分片。对以太网而言，MSS 值是 1460（1500-40）字节。</p><p>kind=3 是窗口扩大因子选项<br>TCP 连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在 TCP 的头部中，接收通告窗口大小是用 16 位表示的，故最大为 65535 字节，但实际上 TCP 模块允许的接收通告窗口大小远不止这个数（为了提高 TCP 通信的吞吐量）。窗口扩大因子解决了这个问题。假设 TCP 头部中的接收通告窗口大小是 N，窗口扩大因子（移位数）是 M，那么 TCP 报文段的实际接收通告窗口大小是 N 乘 2M，或者说 N 左移 M 位。注意，M 的取值范围是 0～14。</p><p>和 MSS 选项一样，窗口扩大因子选项只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该 TCP 报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。关于窗口扩大因子选项的细节，可参考标准文档 RFC 1323。</p><p>kind=4 是选择性确认（Selective Acknowledgment，SACK）选项<br>TCP 通信时，如果某个 TCP 报文段丢失，则 TCP 模块会重传最后被确认的 TCP 报文段后续的所有报文段，这样原先已经正确传输的 TCP 报文段也可能重复发送，从而降低了 TCP 性能。SACK 技术正是为改善这种情况而产生的，它使 TCP 模块只重新发送丢失的 TCP 报文段，不用发送所有未被确认的 TCP 报文段。选择性确认选项用在连接初始化时，表示是否支持 SACK 技术。</p><p>kind=5 是 SACK 实际工作的选项<br>该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿（edge of block）参数包含一个 4 字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用 8 字节，所以 TCP 头部选项中实际上最多可以包含 4 个这样的不连续数据块（考虑选项类型和长度占用的 2 字节）。</p><p>kind=8 是时间戳选项<br>该选项提供了较为准确的计算通信双方之间的回路时间（Round Trip Time，RTT）的方法，从而为 TCP 流量控制提供重要信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;传输层-tcp-协议-实现&quot;&gt;&lt;a href=&quot;#传输层-tcp-协议-实现&quot; class=&quot;headerlink&quot; title=&quot;传输层 tcp 协议 实现&quot;&gt;&lt;/a&gt;传输层 tcp 协议 实现&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;43E0E23D5D324B8C
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>4.udp协议</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/4.udp%E5%8D%8F%E8%AE%AE/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/4.udp协议/</id>
    <published>2019-10-22T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="udp协议"><a href="#udp协议" class="headerlink" title="udp协议"></a>udp协议</h1><h2 id="udp协议-包体"><a href="#udp协议-包体" class="headerlink" title="udp协议 包体"></a>udp协议 包体</h2><p><img src="C5DAEAF2697B45D6927F108780C6324E" alt="image"></p><ol><li>源端口 源端口号</li><li>目的端口 目的端口号</li><li>长度 UDP 数据报的长度，包含首部，最小为 8</li><li>检验和 UDP 数据报的校验和，如果接收到检验和不正确的情况下，直接丢弃该报文。</li></ol><h2 id="计算校验和算法"><a href="#计算校验和算法" class="headerlink" title="计算校验和算法"></a>计算校验和算法</h2><p>UDP 计算校验和的方法和 IP 数据报首部校验和的方法相似。不同的是：IP 数据报校验和只校验 IP 数据报的首部，但 UDP 的校验和是把首部和数据部分一起都检验。</p><p>UDP 的校验和需要计算 UDP 首部加数据荷载部分，但也需要加上 UDP 伪首部。这个伪首部指，源地址、目的地址、UDP 数据长度、协议类型（0x11），协议类型就一个字节，但需要补一个字节的 0x0，构成 12 个字节。伪首部+UDP 首部+数据一起计算校验和。</p><p>UDP 检验和的计算方法是：<br>按每 16 位求和得出一个 32 位的数；<br>如果这个 32 位的数，高 16 位不为 0，则高 16 位加低 16 位再得到一个 32 位的数；<br>重复第 2 步直到高 16 位为 0，将低 16 位取反，得到校验和。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;udp协议&quot;&gt;&lt;a href=&quot;#udp协议&quot; class=&quot;headerlink&quot; title=&quot;udp协议&quot;&gt;&lt;/a&gt;udp协议&lt;/h1&gt;&lt;h2 id=&quot;udp协议-包体&quot;&gt;&lt;a href=&quot;#udp协议-包体&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>2.tcp流量控制</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/2.tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/2.tcp流量控制/</id>
    <published>2019-10-22T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcp-流量控制"><a href="#tcp-流量控制" class="headerlink" title="tcp 流量控制"></a>tcp 流量控制</h1><p>tcp是由丢包重传的机制的</p><p>那么如果服务端因为负载导致不能接受发送端的数据从而丢弃数据</p><p>发送端接受到ack确认为丢包后导致重传</p><p>然后服务端导致负载更加严重，从而一个劲的重发数据，对网络造成更大的伤害。于是就提出了拥塞控制，当拥塞发生的时候，要做自我牺牲，降低发送速率。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tcp-流量控制&quot;&gt;&lt;a href=&quot;#tcp-流量控制&quot; class=&quot;headerlink&quot; title=&quot;tcp 流量控制&quot;&gt;&lt;/a&gt;tcp 流量控制&lt;/h1&gt;&lt;p&gt;tcp是由丢包重传的机制的&lt;/p&gt;
&lt;p&gt;那么如果服务端因为负载导致不能接受发送端的数据从而
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>websocket实现</title>
    <link href="http://blog.huido.site/wiki/net-protocol/2.%E5%BA%94%E7%94%A8%E5%B1%82/5.websocket%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.huido.site/wiki/net-protocol/2.应用层/5.websocket实现/</id>
    <published>2019-10-21T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写基本的httpserver"><a href="#编写基本的httpserver" class="headerlink" title="编写基本的httpserver"></a>编写基本的httpserver</h2><h3 id="启动一个基本的httpserver，提供两个接口，一个index返回主页，另一个是就是我们自定义的websocket协议接口"><a href="#启动一个基本的httpserver，提供两个接口，一个index返回主页，另一个是就是我们自定义的websocket协议接口" class="headerlink" title="启动一个基本的httpserver，提供两个接口，一个index返回主页，另一个是就是我们自定义的websocket协议接口"></a>启动一个基本的httpserver，提供两个接口，一个<code>index</code>返回主页，另一个是就是我们自定义的<code>websocket</code>协议接口</h3><h3 id="main-go"><a href="#main-go" class="headerlink" title="@main.go"></a>@main.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/pkg/logging"</span></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/protocol/application/http"</span></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/protocol/application/websocket"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">logging.Setup()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">serv := http.NewHTTP(<span class="string">"tap1"</span>, <span class="string">"192.168.1.0/24"</span>, <span class="string">"192.168.1.1"</span>, <span class="string">"9502"</span>)</span><br><span class="line">serv.HandleFunc(<span class="string">"/ws"</span>, echo)</span><br><span class="line"></span><br><span class="line">serv.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(request *http.Request, response *http.Response)</span></span> &#123;</span><br><span class="line">response.End(<span class="string">"hello"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">"@main: server is start ip:192.168.1.1 port:9502 "</span>)</span><br><span class="line">serv.ListenAndServ()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//websocket处理器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(r *http.Request, w *http.Response)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"got http request ; start to  upgrade websocket protocol...."</span>)</span><br><span class="line"><span class="comment">//协议升级 c *websocket.Conn</span></span><br><span class="line">c, err := websocket.Upgrade(r, w)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//升级协议失败，直接return 交由http处理响应</span></span><br><span class="line">fmt.Println(<span class="string">"Upgrade error:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"><span class="comment">//循环处理数据，接受数据，然后返回</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">message, err := c.ReadData()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">"read:"</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"recv client msg:"</span>, <span class="keyword">string</span>(message))</span><br><span class="line"><span class="comment">// c.SendData(message )</span></span><br><span class="line">c.SendData([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="echo-接口接受http请求并进行升级我们的websocket"><a href="#echo-接口接受http请求并进行升级我们的websocket" class="headerlink" title="echo 接口接受http请求并进行升级我们的websocket"></a>echo 接口接受http请求并进行升级我们的websocket</h3><h3 id="页面如下"><a href="#页面如下" class="headerlink" title="页面如下"></a>页面如下</h3><p><img src="/images/websocket.png" alt="index"></p><h2 id="自定义的webscoket-upgrade进行升级"><a href="#自定义的webscoket-upgrade进行升级" class="headerlink" title="自定义的webscoket upgrade进行升级"></a>自定义的webscoket upgrade进行升级</h2><h3 id="根据之前的协议分析，我知道握手的过程其实就是检查-HTTP-请求头部字段的过程，值得注意的一点就是需要针对客户端发送的-Sec-WebSocket-Key-生成一个正确的-Sec-WebSocket-Accept-只。关于生成的-Sec-WebSocket-Accpet-的实现，可以参考之前的分析。握手过程的具体代码如下："><a href="#根据之前的协议分析，我知道握手的过程其实就是检查-HTTP-请求头部字段的过程，值得注意的一点就是需要针对客户端发送的-Sec-WebSocket-Key-生成一个正确的-Sec-WebSocket-Accept-只。关于生成的-Sec-WebSocket-Accpet-的实现，可以参考之前的分析。握手过程的具体代码如下：" class="headerlink" title="根据之前的协议分析，我知道握手的过程其实就是检查 HTTP 请求头部字段的过程，值得注意的一点就是需要针对客户端发送的 Sec-WebSocket-Key 生成一个正确的 Sec-WebSocket-Accept 只。关于生成的 Sec-WebSocket-Accpet 的实现，可以参考之前的分析。握手过程的具体代码如下："></a>根据之前的协议分析，我知道握手的过程其实就是检查 HTTP 请求头部字段的过程，值得注意的一点就是需要针对客户端发送的 <code>Sec-WebSocket-Key</code> 生成一个正确的 <code>Sec-WebSocket-Accept</code> 只。关于生成的 <code>Sec-WebSocket-Accpet</code> 的实现，可以参考之前的分析。握手过程的具体代码如下：</h3><h3 id="upgrade-go"><a href="#upgrade-go" class="headerlink" title="@upgrade.go"></a>@upgrade.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> websocket</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upgrade</span><span class="params">(w http.ResponseWriter,r *http.Request)</span><span class="params">(c *Conn,err error)</span></span>&#123;</span><br><span class="line">    <span class="comment">//是否是Get方法</span></span><br><span class="line">    <span class="keyword">if</span> r.Method != <span class="string">"GET"</span> &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusMethodNotAllowed),http.StatusMethodNotAllowed)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:method not GET"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查 Sec-WebSocket-Version 版本</span></span><br><span class="line">    <span class="keyword">if</span> values := r.Header[<span class="string">"Sec-Websocket-Version"</span>];<span class="built_in">len</span>(values) == <span class="number">0</span> || values[<span class="number">0</span>] != <span class="string">"13"</span> &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:version != 13"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查Connection 和  Upgrade</span></span><br><span class="line">    <span class="keyword">if</span> !tokenListContainsValue(r.Header,<span class="string">"Connection"</span>,<span class="string">"upgrade"</span>) &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:could not find connection header with token 'upgrade'"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !tokenListContainsValue(r.Header,<span class="string">"Upgrade"</span>,<span class="string">"websocket"</span>) &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:could not find connection header with token 'websocket'"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算Sec-Websocket-Accept的值</span></span><br><span class="line">    challengeKey := r.Header.Get(<span class="string">"Sec-Websocket-Key"</span>)</span><br><span class="line">    <span class="keyword">if</span> challengeKey == <span class="string">""</span> &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:key missing or blank"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        netConn net.Conn</span><br><span class="line">        br *bufio.Reader</span><br><span class="line">    )</span><br><span class="line">    h,ok := w.(http.Hijacker)</span><br><span class="line">    <span class="keyword">if</span>  !ok &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusInternalServerError),http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:response dose not implement http.Hijacker"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> rw *bufio.ReadWriter</span><br><span class="line">    <span class="comment">//接管当前tcp连接，阻止内置http接管连接</span></span><br><span class="line">    netConn,rw,err = h.Hijack()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusInternalServerError),http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    br = rw.Reader</span><br><span class="line">    <span class="keyword">if</span> br.Buffered() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        netConn.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:client send data before hanshake is complete"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造握手成功后返回的 response</span></span><br><span class="line">    p := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">    p = <span class="built_in">append</span>(p, <span class="string">"HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: "</span>...)</span><br><span class="line">    p = <span class="built_in">append</span>(p, computeAcceptKey(challengeKey)...)</span><br><span class="line">    p = <span class="built_in">append</span>(p, <span class="string">"\r\n\r\n"</span>...)</span><br><span class="line">    <span class="comment">//返回repson 但不关闭连接</span></span><br><span class="line">    <span class="keyword">if</span> _,err = netConn.Write(p);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        netConn.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//升级为websocket</span></span><br><span class="line">    log.Println(<span class="string">"Upgrade http to websocket successfully"</span>)</span><br><span class="line">    conn := newConn(netConn)</span><br><span class="line">    <span class="keyword">return</span> conn,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="握手过程的代码比较直观，就不多做解释了。到这里-WebSocket-的实现就基本完成了，可以看到有了之前的各种约定，我们实现-WebSocket-协议也是比较简单的。"><a href="#握手过程的代码比较直观，就不多做解释了。到这里-WebSocket-的实现就基本完成了，可以看到有了之前的各种约定，我们实现-WebSocket-协议也是比较简单的。" class="headerlink" title="握手过程的代码比较直观，就不多做解释了。到这里 WebSocket 的实现就基本完成了，可以看到有了之前的各种约定，我们实现 WebSocket 协议也是比较简单的。"></a>握手过程的代码比较直观，就不多做解释了。到这里 WebSocket 的实现就基本完成了，可以看到有了之前的各种约定，我们实现 WebSocket 协议也是比较简单的。</h3><h2 id="封装的websocket结构体和对应的方法"><a href="#封装的websocket结构体和对应的方法" class="headerlink" title="封装的websocket结构体和对应的方法"></a>封装的websocket结构体和对应的方法</h2><h3 id="conn-go"><a href="#conn-go" class="headerlink" title="@conn.go"></a>@conn.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> websocket</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 是否是最后一个数据帧</span></span><br><span class="line"><span class="comment">    * Fin Rsv1 Rsv2 Rsv3 Opcode</span></span><br><span class="line"><span class="comment">    *  1  0    0    0    0 0 0 0  =&gt; 128</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    finalBit = <span class="number">1</span> &lt;&lt; <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 是否需要掩码处理</span></span><br><span class="line"><span class="comment">    *  Mask payload-len 第一位mask表示是否需要进行掩码处理 后面</span></span><br><span class="line"><span class="comment">    *  7位表示数据包长度 1.0-125 表示长度 2.126 后面需要扩展2 字节 16bit</span></span><br><span class="line"><span class="comment">    *  3.127则扩展8bit</span></span><br><span class="line"><span class="comment">    *  1    0 0 0 0 0 0 0  =&gt; 128</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    maskBit = <span class="number">1</span> &lt;&lt; <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 文本帧类型</span></span><br><span class="line"><span class="comment">    * 0 0 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TextMessage = <span class="number">1</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 关闭数据帧类型</span></span><br><span class="line"><span class="comment">    * 0 0 0 0 1 0 0 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    CloseMessage = <span class="number">8</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//websocket 连接</span></span><br><span class="line"><span class="keyword">type</span> Conn <span class="keyword">struct</span> &#123;</span><br><span class="line">    writeBuf []<span class="keyword">byte</span></span><br><span class="line">    maskKey [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">    conn net.Conn</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newConn</span><span class="params">(conn net.Conn)</span>*<span class="title">Conn</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Conn&#123;conn:conn&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span><span class="title">Close</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c.conn.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span><span class="title">SendData</span><span class="params">(data []<span class="keyword">byte</span>)</span></span>&#123;</span><br><span class="line">    length := <span class="built_in">len</span>(data)</span><br><span class="line">    c.writeBuf = <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">10</span> + length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据开始和结束位置</span></span><br><span class="line">    payloadStart := <span class="number">2</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *数据帧的第一个字节，不支持且只能发送文本类型数据</span></span><br><span class="line"><span class="comment">    *finalBit 1 0 0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">    *                |</span></span><br><span class="line"><span class="comment">    *Text     0 0 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">    * =&gt;      1 0 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    c.writeBuf[<span class="number">0</span>] = <span class="keyword">byte</span>(TextMessage) | finalBit</span><br><span class="line">    fmt.Printf(<span class="string">"1 bit:%b\n"</span>,c.writeBuf[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据帧第二个字节，服务器发送的数据不需要进行掩码处理</span></span><br><span class="line">    <span class="keyword">switch</span>&#123;</span><br><span class="line">    <span class="comment">//大于2字节的长度</span></span><br><span class="line">    <span class="keyword">case</span> length &gt;= <span class="number">1</span> &lt;&lt; <span class="number">16</span> :<span class="comment">//65536</span></span><br><span class="line">        <span class="comment">//c.writeBuf[1] = byte(0x00) | 127 // 127</span></span><br><span class="line">        c.writeBuf[<span class="number">1</span>] = <span class="keyword">byte</span>(<span class="number">127</span>) <span class="comment">// 127</span></span><br><span class="line">        <span class="comment">//大端写入64位</span></span><br><span class="line">        binary.BigEndian.PutUint64(c.writeBuf[payloadStart:],<span class="keyword">uint64</span>(length))</span><br><span class="line">        <span class="comment">//需要8byte来存储数据长度</span></span><br><span class="line">        payloadStart += <span class="number">8</span></span><br><span class="line">    <span class="keyword">case</span> length &gt; <span class="number">125</span>:</span><br><span class="line">        <span class="comment">//c.writeBuf[1] = byte(0x00) | 126</span></span><br><span class="line">        c.writeBuf[<span class="number">1</span>] = <span class="keyword">byte</span>(<span class="number">126</span>)</span><br><span class="line">        binary.BigEndian.PutUint16(c.writeBuf[payloadStart:],<span class="keyword">uint16</span>(length))</span><br><span class="line">        payloadStart += <span class="number">2</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//c.writeBuf[1] = byte(0x00) | byte(length)</span></span><br><span class="line">        c.writeBuf[<span class="number">1</span>] = <span class="keyword">byte</span>(length)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"2 bit:%b\n"</span>,c.writeBuf[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">copy</span>(c.writeBuf[payloadStart:],data[:])</span><br><span class="line">    c.conn.Write(c.writeBuf[:payloadStart+length])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span><span class="title">ReadData</span><span class="params">()</span><span class="params">(data []<span class="keyword">byte</span>,err error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b [<span class="number">8</span>]<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//读取数据帧的前两个字节</span></span><br><span class="line">    <span class="keyword">if</span> _,err := c.conn.Read(b[:<span class="number">2</span>]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始解析第一个字节 是否还有后续数据帧</span></span><br><span class="line">    final := b[<span class="number">0</span>] &amp; finalBit != <span class="number">0</span></span><br><span class="line">    fmt.Printf(<span class="string">"read data 1 bit :%b\n"</span>,b[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">//不支持数据分片</span></span><br><span class="line">    <span class="keyword">if</span> !final &#123;</span><br><span class="line">        log.Println(<span class="string">"Recived fragemented frame,not support"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"not suppeort fragmented message"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据帧类型</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *1 0 0 0  0 0 0 1</span></span><br><span class="line"><span class="comment">    *        &amp;</span></span><br><span class="line"><span class="comment">    *0 0 0 0  1 1 1 1</span></span><br><span class="line"><span class="comment">    *0 0 0 0  0 0 0 1</span></span><br><span class="line"><span class="comment">    * =&gt; 1 这样就可以直接获取到类型了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    frameType := <span class="keyword">int</span>(b[<span class="number">0</span>] &amp; <span class="number">0xf</span>)</span><br><span class="line">    <span class="comment">//如果 关闭类型，则关闭连接</span></span><br><span class="line">    <span class="keyword">if</span> frameType == CloseMessage &#123;</span><br><span class="line">        c.conn.Close()</span><br><span class="line">        log.Println(<span class="string">"Recived closed message,connection will be closed"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"recived closed message"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只实现了文本格式的传输,编码utf-8</span></span><br><span class="line">    <span class="keyword">if</span> frameType != TextMessage &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"only support text message"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查数据帧是否被掩码处理</span></span><br><span class="line">    <span class="comment">//maskBit =&gt; 1 0 0 0 0 0 0 0 任何与他 要么为0 要么为 128</span></span><br><span class="line">    mask := b[<span class="number">1</span>] &amp; maskBit != <span class="number">0</span></span><br><span class="line">    <span class="comment">//数据长度</span></span><br><span class="line">    payloadLen := <span class="keyword">int64</span>(b[<span class="number">1</span>] &amp; <span class="number">0x7F</span>)<span class="comment">//0 1 1 1 1 1 1 1 1 127</span></span><br><span class="line">    dataLen := <span class="keyword">int64</span>(payloadLen)</span><br><span class="line">    <span class="comment">//根据payload length 判断数据的真实长度</span></span><br><span class="line">    <span class="keyword">switch</span> payloadLen &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">126</span>:<span class="comment">//扩展2字节</span></span><br><span class="line">        <span class="keyword">if</span> _,err := c.conn.Read(b[:<span class="number">2</span>]);err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取扩展二字节的真实数据长度</span></span><br><span class="line">        dataLen = <span class="keyword">int64</span>(binary.BigEndian.Uint16(b[:<span class="number">2</span>]))</span><br><span class="line">    <span class="keyword">case</span> <span class="number">127</span> :</span><br><span class="line">        <span class="keyword">if</span> _,err := c.conn.Read(b[:<span class="number">8</span>]);err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">        &#125;</span><br><span class="line">        dataLen = <span class="keyword">int64</span>(binary.BigEndian.Uint64(b[:<span class="number">8</span>]))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">"Read data length :%d,payload length %d"</span>,payloadLen,dataLen)</span><br><span class="line">    <span class="comment">//读取mask key</span></span><br><span class="line">    <span class="keyword">if</span> mask &#123;<span class="comment">//如果需要掩码处理的话 需要取出key</span></span><br><span class="line">        <span class="comment">//maskKey 是 4 字节  32位</span></span><br><span class="line">        <span class="keyword">if</span> _,err := c.conn.Read(c.maskKey[:]);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> ,err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取数据内容</span></span><br><span class="line">    p := <span class="built_in">make</span>([]<span class="keyword">byte</span>,dataLen)</span><br><span class="line">    <span class="keyword">if</span> _,err := c.conn.Read(p);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mask &#123;</span><br><span class="line">        maskBytes(c.maskKey,p)<span class="comment">//进行解码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="http-头部检查"><a href="#http-头部检查" class="headerlink" title="http 头部检查"></a>http 头部检查</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/sha1"</span></span><br><span class="line">    <span class="string">"encoding/base64"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> KeyGUID = []<span class="keyword">byte</span>(<span class="string">"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</span>)</span><br><span class="line"><span class="comment">//握手阶段使用 加密key返回 进行握手</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">computeAcceptKey</span><span class="params">(challengeKey <span class="keyword">string</span>)</span><span class="title">string</span></span>&#123;</span><br><span class="line">    h := sha1.New()</span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(challengeKey))</span><br><span class="line">    h.Write(KeyGUID)</span><br><span class="line">    <span class="keyword">return</span> base64.StdEncoding.EncodeToString(h.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maskBytes</span><span class="params">(key [4]<span class="keyword">byte</span>,b []<span class="keyword">byte</span>)</span></span>&#123;</span><br><span class="line">    pos := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> b &#123;</span><br><span class="line">        b[i] ^= key[pos &amp; <span class="number">3</span>]</span><br><span class="line">        pos ++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查http 头部字段中是否包含指定的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tokenListContainsValue</span><span class="params">(header http.Header, name <span class="keyword">string</span>, value <span class="keyword">string</span>)</span><span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> header[name] &#123;</span><br><span class="line">        <span class="keyword">for</span> _, s := <span class="keyword">range</span> strings.Split(v,<span class="string">","</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> strings.EqualFold(value,strings.TrimSpace(s)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编写基本的httpserver&quot;&gt;&lt;a href=&quot;#编写基本的httpserver&quot; class=&quot;headerlink&quot; title=&quot;编写基本的httpserver&quot;&gt;&lt;/a&gt;编写基本的httpserver&lt;/h2&gt;&lt;h3 id=&quot;启动一个基本的httpse
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="2.应用层" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="golang" scheme="http://blog.huido.site/tags/golang/"/>
    
      <category term="websocket" scheme="http://blog.huido.site/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>websocket算法</title>
    <link href="http://blog.huido.site/wiki/net-protocol/2.%E5%BA%94%E7%94%A8%E5%B1%82/4.websocket%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.huido.site/wiki/net-protocol/2.应用层/4.websocket算法/</id>
    <published>2019-10-21T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="websocket协议中的一些算法"><a href="#websocket协议中的一些算法" class="headerlink" title="websocket协议中的一些算法"></a>websocket协议中的一些算法</h2><p>在分析 WebSocket 协议握手过程和数据帧格式过程中，我们讲到了一些算法，下面我们讲解下具体实现。</p><h2 id="Sec-WebSocket-Accept的计算方法"><a href="#Sec-WebSocket-Accept的计算方法" class="headerlink" title="Sec-WebSocket-Accept的计算方法"></a>Sec-WebSocket-Accept的计算方法</h2><h3 id="从上面的分析中，我们知道字段的值是通过固定字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11加上请求中Sec-WebSocket-Key字段的值，然后再对其结果通过-SHA1-哈希算法求出的结果。可以通过以下-golang-代码实现："><a href="#从上面的分析中，我们知道字段的值是通过固定字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11加上请求中Sec-WebSocket-Key字段的值，然后再对其结果通过-SHA1-哈希算法求出的结果。可以通过以下-golang-代码实现：" class="headerlink" title="从上面的分析中，我们知道字段的值是通过固定字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11加上请求中Sec-WebSocket-Key字段的值，然后再对其结果通过 SHA1 哈希算法求出的结果。可以通过以下 golang 代码实现："></a>从上面的分析中，我们知道字段的值是通过固定字符串<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B1</code>1加上请求中<code>Sec-WebSocket-Key字</code>段的值，然后再对其结果通过 SHA1 哈希算法求出的结果。可以通过以下 golang 代码实现：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keyGUID = []<span class="keyword">byte</span>(<span class="string">"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">computeAcceptKey</span><span class="params">(challengeKey <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    h := sha1.New()</span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(challengeKey))</span><br><span class="line">    h.Write(keyGUID)</span><br><span class="line">    <span class="keyword">return</span> base64.StdEncoding.EncodeToString(h.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="掩码处理"><a href="#掩码处理" class="headerlink" title="掩码处理"></a>掩码处理</h2><h3 id="浏览器发送给服务器的数据帧是经过掩码处理的，那怎么样对数据进行解码呢？以下是来自RFC6455文档的解释"><a href="#浏览器发送给服务器的数据帧是经过掩码处理的，那怎么样对数据进行解码呢？以下是来自RFC6455文档的解释" class="headerlink" title="浏览器发送给服务器的数据帧是经过掩码处理的，那怎么样对数据进行解码呢？以下是来自RFC6455文档的解释"></a>浏览器发送给服务器的数据帧是经过掩码处理的，那怎么样对数据进行解码呢？以下是来自<code>RFC6455</code>文档的解释</h3><h3 id="具体的流程是：将传输的数据按字节-byte-处理，同时将-Masking-key-代表的值也按字节处理。假如-data-byte-i-代表的是数据的第-i-个字节，那么-j-i-MOD-4，然后从Maksing-key中-一共有-4-个字节）取出第-j-个字节-mask-key-byte-j，然后将-data-byte-i-和-mask-key-byte-j-代表的字节进行异或操作，取得结果就是最终的结果。该操作可以用如下-golang-代码实现："><a href="#具体的流程是：将传输的数据按字节-byte-处理，同时将-Masking-key-代表的值也按字节处理。假如-data-byte-i-代表的是数据的第-i-个字节，那么-j-i-MOD-4，然后从Maksing-key中-一共有-4-个字节）取出第-j-个字节-mask-key-byte-j，然后将-data-byte-i-和-mask-key-byte-j-代表的字节进行异或操作，取得结果就是最终的结果。该操作可以用如下-golang-代码实现：" class="headerlink" title="具体的流程是：将传输的数据按字节 byte 处理，同时将 Masking-key 代表的值也按字节处理。假如 data-byte-i 代表的是数据的第 i 个字节，那么 j = i MOD 4，然后从Maksing-key中(一共有 4 个字节）取出第 j 个字节 mask-key-byte-j，然后将 data-byte-i 和 mask-key-byte-j 代表的字节进行异或操作，取得结果就是最终的结果。该操作可以用如下 golang 代码实现："></a>具体的流程是：将传输的数据按字节 byte 处理，同时将 <code>Masking-key</code> 代表的值也按字节处理。假如 <code>data-byte-i</code> 代表的是数据的第 <code>i</code> 个字节，那么 <code>j = i MOD 4</code>，然后从<code>Maksing-key</code>中(一共有 4 个字节）取出第 j 个字节 <code>mask-key-byte-j</code>，然后将 d<code>ata-byte-i</code> 和 <code>mask-key-byte-j</code> 代表的字节进行异或操作，取得结果就是最终的结果。该操作可以用如下 golang 代码实现：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maskBytes</span><span class="params">(key [4]<span class="keyword">byte</span>,pos <span class="keyword">int</span>,b[]<span class="keyword">byte</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> b&#123;</span><br><span class="line">        b[i] ^= key[pos &amp; <span class="number">3</span>]</span><br><span class="line">        pos++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos &amp; <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意以上的操作，pos-amp-3这里代表的操作是pos-4-因为-a-2-n-等价于-a-amp-2-n-1-在这里使用按位与操作更加高效"><a href="#注意以上的操作，pos-amp-3这里代表的操作是pos-4-因为-a-2-n-等价于-a-amp-2-n-1-在这里使用按位与操作更加高效" class="headerlink" title="注意以上的操作，pos &amp; 3这里代表的操作是pos%4,因为 a % (2 ^ n) 等价于 a &amp; (2^n -1),在这里使用按位与操作更加高效"></a>注意以上的操作，<code>pos &amp; 3</code>这里代表的操作是pos%4,因为 a % (2 ^ n) 等价于 a &amp; (2^n -1),在这里使用按位与操作更加高效</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;websocket协议中的一些算法&quot;&gt;&lt;a href=&quot;#websocket协议中的一些算法&quot; class=&quot;headerlink&quot; title=&quot;websocket协议中的一些算法&quot;&gt;&lt;/a&gt;websocket协议中的一些算法&lt;/h2&gt;&lt;p&gt;在分析 WebSoc
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="2.应用层" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="golang" scheme="http://blog.huido.site/tags/golang/"/>
    
      <category term="websocket" scheme="http://blog.huido.site/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>websocket协议解析</title>
    <link href="http://blog.huido.site/wiki/net-protocol/2.%E5%BA%94%E7%94%A8%E5%B1%82/3.websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.huido.site/wiki/net-protocol/2.应用层/3.websocket协议解析/</id>
    <published>2019-10-21T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="websocket-协议报文"><a href="#websocket-协议报文" class="headerlink" title="websocket 协议报文"></a>websocket 协议报文</h2><p>websocket协议也是基于<code>tcp协议</code>，和http不同的是，tcp接受的数据包为<code>二进制帧</code>，而http为<code>字符串数据包</code>。并且websocket协议在连接阶段会触发一个<code>http请求</code>进行websocket协议校验。校验成功后才会接管tcp通讯流程不会断开该http连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">websocket 数据帧报文</span><br><span class="line"></span><br><span class="line">  0               1               2               3               4</span><br><span class="line">  0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8</span><br><span class="line">  +-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">  |F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">  |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">  |N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">  | |1|2|3|       |K|             |                               |</span><br><span class="line">  +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">  |     Extended payload length continued, if payload len == 127  |</span><br><span class="line">  + - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">  |                               |Masking-key, if MASK set to 1  |</span><br><span class="line">  +-------------------------------+-------------------------------+</span><br><span class="line">  | Masking-key (continued)       |          Payload Data         |</span><br><span class="line">  +-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">  :                     Payload Data continued ...                :</span><br><span class="line">  + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">  |                     Payload Data continued ...                |</span><br><span class="line">  +---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h2 id="WebSocket协议详解"><a href="#WebSocket协议详解" class="headerlink" title="WebSocket协议详解"></a>WebSocket协议详解</h2><p>WebSocket 协议解决了浏览器和服务器之间的全双工通信问题。在 WebSocket 出现之前，浏览器如果需要从服务器及时获得更新，则需要不停的对服务器主动发起请求，也就是 Web 中常用的poll技术。这样的操作非常低效，这是因为每发起一次新的 HTTP 请求，就需要单独开启一个新的 TCP 链接，同时 HTTP 协议本身也是一种开销非常大的协议。为了解决这些问题，所以出现了 WebSocket 协议。WebSocket 使得浏览器和服务器之间能通过一个持久的 TCP 链接就能完成数据的双向通信。关于 WebSocket 的 RFC 提案，可以参看RFC6455。</p><p>WebSocket 和 HTTP 协议一般情况下都工作在浏览器中，但 WebSocket 是一种完全不同于 HTTP 的协议。尽管，浏览器需要通过 HTTP 协议的GET请求，将 HTTP 协议升级为 WebSocket 协议。升级的过程被称为握手(handshake)。当浏览器和服务器成功握手后，则可以开始根据 WebSocket 定义的通信帧格式开始通信了。像其他各种协议一样，WebSocket 协议的通信帧也分为控制数据帧和普通数据帧，前者用于控制 WebSocket 链接状态，后者用于承载数据。下面我们将一一分析 WebSocket 协议的握手过程以及通信帧格式。</p><h2 id="一、websocket握手"><a href="#一、websocket握手" class="headerlink" title="一、websocket握手"></a>一、websocket握手</h2><h3 id="握手的过程也就是将HTTP协议升级为WebSocket协议的过程，握手开始首先由浏览器端发送一个GET请求，该请求的HTTP头部信息如下"><a href="#握手的过程也就是将HTTP协议升级为WebSocket协议的过程，握手开始首先由浏览器端发送一个GET请求，该请求的HTTP头部信息如下" class="headerlink" title="握手的过程也就是将HTTP协议升级为WebSocket协议的过程，握手开始首先由浏览器端发送一个GET请求，该请求的HTTP头部信息如下:"></a>握手的过程也就是将HTTP协议升级为WebSocket协议的过程，握手开始首先由浏览器端发送一个<code>GET</code>请求，该请求的HTTP头部信息如下:</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Origin</span>: http://example.com</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protcol</span>: chat, superchat</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</span><br></pre></td></tr></table></figure><h3 id="当服务器端，成功验证了以上信息后，则会返回一个形如以下的响应："><a href="#当服务器端，成功验证了以上信息后，则会返回一个形如以下的响应：" class="headerlink" title="当服务器端，成功验证了以上信息后，则会返回一个形如以下的响应："></a>当服务器端，成功验证了以上信息后，则会返回一个形如以下的响应：</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span>: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat</span><br></pre></td></tr></table></figure><h3 id="可以看到，浏览器发送端HTTP请求中，增加了一些新端字段，其作用如下所示："><a href="#可以看到，浏览器发送端HTTP请求中，增加了一些新端字段，其作用如下所示：" class="headerlink" title="可以看到，浏览器发送端HTTP请求中，增加了一些新端字段，其作用如下所示："></a>可以看到，浏览器发送端HTTP请求中，增加了一些新端字段，其作用如下所示：</h3><ul><li><code>Upgrade</code>: 规定必需的字段，其值必需为 <code>websocket</code>, 如果不是则握手失败；</li><li><code>Connection</code>: 规定必需的字段，值必需为 <code>Upgrade</code>, 如果不是则握手失败；<br><code>Sec-WebSocket-Key</code>: 必需字段，一个随机的字符串；<br><code>Sec-WebSocket-Protocol</code>: 可选字段，可以用于标识应用层的协议；<br><code>Sec-WebSocket-Version</code>: 必需字段，代表了 WebSocket 协议版本，值必需是 <code>13</code>, 否则握手失败；<h3 id="返回端响应中，如果握手成功会返回状态码101的HTTP响应，同时其他字段说明如下："><a href="#返回端响应中，如果握手成功会返回状态码101的HTTP响应，同时其他字段说明如下：" class="headerlink" title="返回端响应中，如果握手成功会返回状态码101的HTTP响应，同时其他字段说明如下："></a>返回端响应中，如果握手成功会返回状态码<code>101</code>的HTTP响应，同时其他字段说明如下：</h3></li><li><code>Upgrade</code>: 规定必需的字段，其值必需为 <code>websocket</code>, 如果不是则握手失败；</li><li><code>Connection</code>: 规定必需的字段，值必需为 <code>Upgrade</code>, 如果不是则握手失败；</li><li><code>Sec-WebSocket-Accept</code>: 规定必需的字段，该字段的值是通过固定字符串<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>加上请求中<code>Sec-WebSocket-Key</code>字段的值，然后再对其结果通过 <code>SHA1</code> 哈希算法求出的结果。</li><li><code>Sec-WebSocket-Protocol</code>: 对应于请求中的 <code>Sec-WebSocket-Protocol</code> 字段；<h3 id="当浏览器和服务端成功握手后，就可以传递数据了，传送数据是按照WebSocket的数据格式生成的"><a href="#当浏览器和服务端成功握手后，就可以传递数据了，传送数据是按照WebSocket的数据格式生成的" class="headerlink" title="当浏览器和服务端成功握手后，就可以传递数据了，传送数据是按照WebSocket的数据格式生成的"></a>当浏览器和服务端成功握手后，就可以传递数据了，传送数据是按照WebSocket的数据格式生成的</h3><h2 id="二、WebSocket协议数据帧"><a href="#二、WebSocket协议数据帧" class="headerlink" title="二、WebSocket协议数据帧"></a>二、WebSocket协议数据帧</h2><h3 id="数据帧的定义类似与TCP-IP的格式定义，具体看下图："><a href="#数据帧的定义类似与TCP-IP的格式定义，具体看下图：" class="headerlink" title="数据帧的定义类似与TCP/IP的格式定义，具体看下图："></a>数据帧的定义类似与TCP/IP的格式定义，具体看下图：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure></li></ul><h3 id="以上这张图，一行代表32bit（位），也就是4bytes（字节），总体上包含两份，帧头部和数据内容。每个从WebSocket链接中接受到的数据帧，都要按照以上格式进行解析，这样才能知道该数据帧是用于控制的还是用于传送数据的，关于以上数据帧的各个比特位的解释如下："><a href="#以上这张图，一行代表32bit（位），也就是4bytes（字节），总体上包含两份，帧头部和数据内容。每个从WebSocket链接中接受到的数据帧，都要按照以上格式进行解析，这样才能知道该数据帧是用于控制的还是用于传送数据的，关于以上数据帧的各个比特位的解释如下：" class="headerlink" title="以上这张图，一行代表32bit（位），也就是4bytes（字节），总体上包含两份，帧头部和数据内容。每个从WebSocket链接中接受到的数据帧，都要按照以上格式进行解析，这样才能知道该数据帧是用于控制的还是用于传送数据的，关于以上数据帧的各个比特位的解释如下："></a>以上这张图，一行代表32bit（位），也就是4bytes（字节），总体上包含两份，帧头部和数据内容。每个从WebSocket链接中接受到的数据帧，都要按照以上格式进行解析，这样才能知道该数据帧是用于控制的还是用于传送数据的，关于以上数据帧的各个比特位的解释如下：</h3><ul><li><code>FIN</code>:1bit,当该比特位值为%x0时，表示后面还有更多的数据帧，%x1时表示这是最后一个数据帧；</li><li><code>RSV1</code>,<code>RSV2</code>,<code>RSV3</code>:各占1个比特位。一般情况下全为0，当客户端、服务端协商采用WebSocket扩展时，这三个标识位可以非0，且值当含义由扩展进行定义，如果出现非0当值，且没有采用WebSocket扩展，则链接出错</li><li><code>opcode</code>:4 bit,用于表明数据帧当类型，一共可以表示16种帧类型，如下所示：<ul><li>%x0:表示这是一个分片当帧，它属于前面帧当后续帧；</li><li>%x1:表示该数据帧携带的数据类型是文本类型，且编码utf-8</li><li>%x2 : 表示携带的是二进制数据；</li><li>%x3-7 : 保留未使用；</li><li>%x8 : 表示该帧用于关闭 WebSocket 链接；</li><li>%x9 : 表示该帧代表了 ping 操作；</li><li>%xA : 表示该帧代表了 pong 回应；</li><li>%xB-F : 保留未使用；</li></ul></li><li><code>MASK</code>:1 bit,%x0表示数据帧没有经过掩码计算，而%x1则表示数据帧已经经过掩码计算，得到真正当数据需要解码，一般情况下，只有浏览器发送给服务端当数据帧才需要进行掩码计算；</li><li><code>Payload len</code>:7 bit,表示了数据帧携带当数据长度，7 bit 的值根据三种情况，帧的解析有所不同：<ul><li>%x0 - 7D : 也就是从 0 到 125，表示数据长度, 数据总长度也就是 7 bit 代表的长度；</li><li>%x7E : 7 bit 的值是 126 时，则后续的 2 个字节（16 bit)表示的一个 16 位无符号数，这个数用来表示数据的长度；</li><li>%x7F : 7 bit 的值是 127 时，则后续的 8 个字节（64 bit)表示的一个 64 位无符号数，这个数用来表示数据的长度；<ul><li><code>Masking-key</code>: 32 bit, 表示了用于解码的 key，只有当 MASK 比特位的值为 %x1 是，才有该数据；   </li></ul></li></ul></li><li><code>Payload Data</code>: 余下的比特位用于存储具体的数据；<h3 id="通过以上分析可以看出，WebSocket-协议数据帧的最大头部为-2-8-4-14-bytes-也就是-14-个字节。同时我们要实现-WebSocket-协议，最主要的工作就是实现对数据帧的解析。"><a href="#通过以上分析可以看出，WebSocket-协议数据帧的最大头部为-2-8-4-14-bytes-也就是-14-个字节。同时我们要实现-WebSocket-协议，最主要的工作就是实现对数据帧的解析。" class="headerlink" title="通过以上分析可以看出，WebSocket 协议数据帧的最大头部为 2 + 8 + 4 = 14 bytes 也就是 14 个字节。同时我们要实现 WebSocket 协议，最主要的工作就是实现对数据帧的解析。"></a>通过以上分析可以看出，WebSocket 协议数据帧的最大头部为 2 + 8 + 4 = 14 bytes 也就是 14 个字节。同时我们要实现 WebSocket 协议，最主要的工作就是实现对数据帧的解析。</h3></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;websocket-协议报文&quot;&gt;&lt;a href=&quot;#websocket-协议报文&quot; class=&quot;headerlink&quot; title=&quot;websocket 协议报文&quot;&gt;&lt;/a&gt;websocket 协议报文&lt;/h2&gt;&lt;p&gt;websocket协议也是基于&lt;code&gt;t
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="2.应用层" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="golang" scheme="http://blog.huido.site/tags/golang/"/>
    
      <category term="websocket" scheme="http://blog.huido.site/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>http协议解析</title>
    <link href="http://blog.huido.site/wiki/net-protocol/4.%E7%BD%91%E7%BB%9C%E5%B1%82/2.http%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.huido.site/wiki/net-protocol/4.网络层/2.http协议解析/</id>
    <published>2019-10-18T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http-报文协议"><a href="#http-报文协议" class="headerlink" title="http 报文协议"></a>http 报文协议</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;http-报文协议&quot;&gt;&lt;a href=&quot;#http-报文协议&quot; class=&quot;headerlink&quot; title=&quot;http 报文协议&quot;&gt;&lt;/a&gt;http 报文协议&lt;/h2&gt;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="4.网络层" scheme="http://blog.huido.site/categories/net-protocol/4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
      <category term="Go" scheme="http://blog.huido.site/tags/Go/"/>
    
      <category term="Protocol" scheme="http://blog.huido.site/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>http协议解析</title>
    <link href="http://blog.huido.site/wiki/net-protocol/2.%E5%BA%94%E7%94%A8%E5%B1%82/2.http%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.huido.site/wiki/net-protocol/2.应用层/2.http协议解析/</id>
    <published>2019-10-18T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http协议报文"><a href="#http协议报文" class="headerlink" title="http协议报文"></a>http协议报文</h2><p>这是一个典型的http请求的报文样例，可以看出是一个websocket升级前的http请求。该字符报文完全基于<code>tcp协议</code>，协议报文内容为<code>tcp数据包</code>，也就是<code>tcp</code>进行<code>recv</code>调用获取的数据内容。如下报文表示已经接受完http报文数据。</p><p>解析http报文的源码为<code>application/http/request.go</code>中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http 协议报文</span><br><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protcol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure></p><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="@请求方法"></a>@请求方法</h3><p>解析tcp数据包第一行数据，遇到<code></code>空格就拆分，则获取到请求方法</p><h3 id="uri"><a href="#uri" class="headerlink" title="@uri"></a>@uri</h3><p>解析tcp数据包第一行数据，遇到<code></code>空格就拆分，则获取到uri路径</p><h3 id="header头部"><a href="#header头部" class="headerlink" title="@header头部"></a>@header头部</h3><p>接下来都是一些头部信息的keyvalue，每次读取一行，然后根据:分隔符进行拆分，获取header头部请求键值对</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;http协议报文&quot;&gt;&lt;a href=&quot;#http协议报文&quot; class=&quot;headerlink&quot; title=&quot;http协议报文&quot;&gt;&lt;/a&gt;http协议报文&lt;/h2&gt;&lt;p&gt;这是一个典型的http请求的报文样例，可以看出是一个websocket升级前的http请求。
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="2.应用层" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="golang" scheme="http://blog.huido.site/tags/golang/"/>
    
      <category term="http" scheme="http://blog.huido.site/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>http协议解析</title>
    <link href="http://blog.huido.site/wiki/net-protocol/6.%E7%89%A9%E7%90%86%E5%B1%82/2.http%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.huido.site/wiki/net-protocol/6.物理层/2.http协议解析/</id>
    <published>2019-10-18T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http-报文协议"><a href="#http-报文协议" class="headerlink" title="http 报文协议"></a>http 报文协议</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;http-报文协议&quot;&gt;&lt;a href=&quot;#http-报文协议&quot; class=&quot;headerlink&quot; title=&quot;http 报文协议&quot;&gt;&lt;/a&gt;http 报文协议&lt;/h2&gt;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="6.物理层" scheme="http://blog.huido.site/categories/net-protocol/6-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    
    
      <category term="Go" scheme="http://blog.huido.site/tags/Go/"/>
    
      <category term="Protocol" scheme="http://blog.huido.site/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>http协议解析</title>
    <link href="http://blog.huido.site/wiki/net-protocol/5.%E9%93%BE%E8%B7%AF%E5%B1%82/2.http%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.huido.site/wiki/net-protocol/5.链路层/2.http协议解析/</id>
    <published>2019-10-18T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http-报文协议"><a href="#http-报文协议" class="headerlink" title="http 报文协议"></a>http 报文协议</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;http-报文协议&quot;&gt;&lt;a href=&quot;#http-报文协议&quot; class=&quot;headerlink&quot; title=&quot;http 报文协议&quot;&gt;&lt;/a&gt;http 报文协议&lt;/h2&gt;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="5.链路层" scheme="http://blog.huido.site/categories/net-protocol/5-%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
    
      <category term="Go" scheme="http://blog.huido.site/tags/Go/"/>
    
      <category term="Protocol" scheme="http://blog.huido.site/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>应用层前世今生</title>
    <link href="http://blog.huido.site/wiki/net-protocol/6.%E7%89%A9%E7%90%86%E5%B1%82/1.%E5%BA%94%E7%94%A8%E5%B1%82%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://blog.huido.site/wiki/net-protocol/6.物理层/1.应用层前世今生/</id>
    <published>2019-10-17T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用层的作用"><a href="#应用层的作用" class="headerlink" title="应用层的作用"></a>应用层的作用</h2><p>对传输层协议对再次封装，例如对tcp进行封装对http、websocket协议等，以及http3协议基于udp协议的封装等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;应用层的作用&quot;&gt;&lt;a href=&quot;#应用层的作用&quot; class=&quot;headerlink&quot; title=&quot;应用层的作用&quot;&gt;&lt;/a&gt;应用层的作用&lt;/h2&gt;&lt;p&gt;对传输层协议对再次封装，例如对tcp进行封装对http、websocket协议等，以及http3协议基于ud
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="6.物理层" scheme="http://blog.huido.site/categories/net-protocol/6-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    
    
      <category term="Go" scheme="http://blog.huido.site/tags/Go/"/>
    
      <category term="Protocol" scheme="http://blog.huido.site/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>应用层前世今生</title>
    <link href="http://blog.huido.site/wiki/net-protocol/2.%E5%BA%94%E7%94%A8%E5%B1%82/1.%E5%BA%94%E7%94%A8%E5%B1%82%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://blog.huido.site/wiki/net-protocol/2.应用层/1.应用层前世今生/</id>
    <published>2019-10-17T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用层的作用"><a href="#应用层的作用" class="headerlink" title="应用层的作用"></a>应用层的作用</h2><p>对传输层协议对再次封装，例如对tcp进行封装对http、websocket协议等，以及http3协议基于udp协议的封装等</p><h2 id="http协议报文"><a href="#http协议报文" class="headerlink" title="http协议报文"></a>http协议报文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http 协议报文</span><br><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protcol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure><h2 id="websocket-协议报文"><a href="#websocket-协议报文" class="headerlink" title="websocket 协议报文"></a>websocket 协议报文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">websocket 数据帧报文</span><br><span class="line"></span><br><span class="line">  0               1               2               3               4</span><br><span class="line">  0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8</span><br><span class="line">  +-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">  |F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">  |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">  |N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">  | |1|2|3|       |K|             |                               |</span><br><span class="line">  +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">  |     Extended payload length continued, if payload len == 127  |</span><br><span class="line">  + - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">  |                               |Masking-key, if MASK set to 1  |</span><br><span class="line">  +-------------------------------+-------------------------------+</span><br><span class="line">  | Masking-key (continued)       |          Payload Data         |</span><br><span class="line">  +-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">  :                     Payload Data continued ...                :</span><br><span class="line">  + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">  |                     Payload Data continued ...                |</span><br><span class="line">  +---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;应用层的作用&quot;&gt;&lt;a href=&quot;#应用层的作用&quot; class=&quot;headerlink&quot; title=&quot;应用层的作用&quot;&gt;&lt;/a&gt;应用层的作用&lt;/h2&gt;&lt;p&gt;对传输层协议对再次封装，例如对tcp进行封装对http、websocket协议等，以及http3协议基于ud
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="2.应用层" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
  </entry>
  
  <entry>
    <title>应用层前世今生</title>
    <link href="http://blog.huido.site/wiki/net-protocol/5.%E9%93%BE%E8%B7%AF%E5%B1%82/1.%E5%BA%94%E7%94%A8%E5%B1%82%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://blog.huido.site/wiki/net-protocol/5.链路层/1.应用层前世今生/</id>
    <published>2019-10-17T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用层的作用"><a href="#应用层的作用" class="headerlink" title="应用层的作用"></a>应用层的作用</h2><p>对传输层协议对再次封装，例如对tcp进行封装对http、websocket协议等，以及http3协议基于udp协议的封装等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;应用层的作用&quot;&gt;&lt;a href=&quot;#应用层的作用&quot; class=&quot;headerlink&quot; title=&quot;应用层的作用&quot;&gt;&lt;/a&gt;应用层的作用&lt;/h2&gt;&lt;p&gt;对传输层协议对再次封装，例如对tcp进行封装对http、websocket协议等，以及http3协议基于ud
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="5.链路层" scheme="http://blog.huido.site/categories/net-protocol/5-%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
    
      <category term="Go" scheme="http://blog.huido.site/tags/Go/"/>
    
      <category term="Protocol" scheme="http://blog.huido.site/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>快速开始</title>
    <link href="http://blog.huido.site/wiki/net-protocol/1.%E5%89%8D%E8%A8%80/1.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/"/>
    <id>http://blog.huido.site/wiki/net-protocol/1.前言/1.快速开始/</id>
    <published>2019-10-16T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="demo案例"><a href="#demo案例" class="headerlink" title="demo案例"></a>demo案例</h2><p><code>cmd</code>:该目录下为各协议的实现demo，提供api调用实现以及测试</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;demo案例&quot;&gt;&lt;a href=&quot;#demo案例&quot; class=&quot;headerlink&quot; title=&quot;demo案例&quot;&gt;&lt;/a&gt;demo案例&lt;/h2&gt;&lt;p&gt;&lt;code&gt;cmd&lt;/code&gt;:该目录下为各协议的实现demo，提供api调用实现以及测试&lt;/p&gt;

      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="1.前言" scheme="http://blog.huido.site/categories/net-protocol/1-%E5%89%8D%E8%A8%80/"/>
    
    
      <category term="Go" scheme="http://blog.huido.site/tags/Go/"/>
    
      <category term="Protocol" scheme="http://blog.huido.site/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>分布式推送中间件</title>
    <link href="http://blog.huido.site/wiki/im-cloud/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8E%A8%E9%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://blog.huido.site/wiki/im-cloud/分布式推送中间件/</id>
    <published>2017-10-24T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="im-cloud"><a href="#im-cloud" class="headerlink" title="im-cloud"></a>im-cloud</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;im-cloud&quot;&gt;&lt;a href=&quot;#im-cloud&quot; class=&quot;headerlink&quot; title=&quot;im-cloud&quot;&gt;&lt;/a&gt;im-cloud&lt;/h1&gt;
      
    
    </summary>
    
      <category term="im-cloud" scheme="http://blog.huido.site/categories/im-cloud/"/>
    
    
      <category term="PHP" scheme="http://blog.huido.site/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://blog.huido.site/tags/Swoole/"/>
    
      <category term="RabbitMQ" scheme="http://blog.huido.site/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>微服务应用</title>
    <link href="http://blog.huido.site/wiki/swoft-im/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.huido.site/wiki/swoft-im/微服务应用/</id>
    <published>2017-10-24T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="swoft-im" scheme="http://blog.huido.site/categories/swoft-im/"/>
    
    
      <category term="PHP" scheme="http://blog.huido.site/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://blog.huido.site/tags/Swoole/"/>
    
      <category term="IM" scheme="http://blog.huido.site/tags/IM/"/>
    
  </entry>
  
  <entry>
    <title>index</title>
    <link href="http://blog.huido.site/wiki/net-protocol/index/"/>
    <id>http://blog.huido.site/wiki/net-protocol/index/</id>
    <published>2017-10-24T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="net-protocol"><a href="#net-protocol" class="headerlink" title="net-protocol"></a>net-protocol</h1><p>基于go 实现链路层、网络层、传输层、应用层 网络协议栈 ，使用虚拟网卡实现</p><h2 id="docs"><a href="#docs" class="headerlink" title="@docs"></a>@docs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相关md文档在cmd目录下，以及相关协议的demo测试</span><br></pre></td></tr></table></figure><p><code>./cmd/*.md</code></p><h2 id="application-应用层"><a href="#application-应用层" class="headerlink" title="@application 应用层"></a>@application 应用层</h2><ul><li style="list-style: none"><input type="checkbox" checked></input> http <a href="./cmd/http.md">docs</a></li><li style="list-style: none"><input type="checkbox" checked></input> websocket <a href="./cmd/websocket.md">docs</a></li></ul><h2 id="transport-传输层"><a href="#transport-传输层" class="headerlink" title="@transport 传输层"></a>@transport 传输层</h2><ul><li style="list-style: none"><input type="checkbox" checked></input> tcp <a href="./cmd/tcp.md">docs</a></li><li style="list-style: none"><input type="checkbox" checked></input> udp <a href="./cmd/udp.md">docs</a></li><li style="list-style: none"><input type="checkbox" checked></input> port 端口机制</li></ul><h2 id="network-网络层"><a href="#network-网络层" class="headerlink" title="@network 网络层"></a>@network 网络层</h2><ul><li style="list-style: none"><input type="checkbox" checked></input> icmp</li><li style="list-style: none"><input type="checkbox" checked></input> ipv4</li><li style="list-style: none"><input type="checkbox" checked></input> ipv6</li></ul><h2 id="link-链路层"><a href="#link-链路层" class="headerlink" title="@link 链路层"></a>@link 链路层</h2><ul><li style="list-style: none"><input type="checkbox" checked></input> arp <a href="./cmd/arp.md">docs</a></li><li style="list-style: none"><input type="checkbox" checked></input> ethernet</li></ul><h2 id="物理层"><a href="#物理层" class="headerlink" title="@物理层"></a>@物理层</h2><ul><li style="list-style: none"><input type="checkbox" checked></input> tun tap 虚拟网卡的实现</li></ul><h2 id="协议相关api"><a href="#协议相关api" class="headerlink" title="协议相关api"></a>协议相关api</h2><h3 id="1-应用层相关协议"><a href="#1-应用层相关协议" class="headerlink" title="1.应用层相关协议"></a>1.应用层相关协议</h3><p>应用层暂时只实现了<code>http</code>、<code>websocket</code>等文本协议。都基于tcp、对tcp等进行二次封装</p><p><a href="./http-api.md">http api</a> :<code>http-api.md</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http 协议报文</span><br><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protcol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure></p><p><a href="./websocket-api.md">websocket api</a> : <code>websocket-api.md</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">websocket 数据帧报文</span><br><span class="line"></span><br><span class="line">  0               1               2               3               4</span><br><span class="line">  0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8</span><br><span class="line">  +-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">  |F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">  |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">  |N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">  | |1|2|3|       |K|             |                               |</span><br><span class="line">  +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">  |     Extended payload length continued, if payload len == 127  |</span><br><span class="line">  + - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">  |                               |Masking-key, if MASK set to 1  |</span><br><span class="line">  +-------------------------------+-------------------------------+</span><br><span class="line">  | Masking-key (continued)       |          Payload Data         |</span><br><span class="line">  +-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">  :                     Payload Data continued ...                :</span><br><span class="line">  + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">  |                     Payload Data continued ...                |</span><br><span class="line">  +---------------------------------------------------------------+</span><br></pre></td></tr></table></figure></p><h3 id="2-传输层相关协议"><a href="#2-传输层相关协议" class="headerlink" title="2.传输层相关协议"></a>2.传输层相关协议</h3><p>传输层实现了<code>upd</code>、<code>tcp</code>、灯协议，并实现了主要接口</p><p><a href="./tcp-api.md">tcp api</a>:<code>tcp-api.md</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">     tcp 首部协议报文</span><br><span class="line">0               1               2               3               4</span><br><span class="line">0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |           |G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p><a href="./udp-api.md">udp-api</a>:<code>./udp-api.md</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udp 协议报文</span><br></pre></td></tr></table></figure></p><p>端口机制</p><h3 id="3-网络层相关协议"><a href="#3-网络层相关协议" class="headerlink" title="3.网络层相关协议"></a>3.网络层相关协议</h3><p><a href="./ipv-api.md">ip</a>:<code>ipv4-api.md</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">              ip头部协议报文</span><br><span class="line">0               1               2               3               4</span><br><span class="line">0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Version|  LHL  | Type of Service |        Total Length         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Identification(fragment Id)    |Flags|  Fragment Offset      |</span><br><span class="line">|           16 bits               |R|D|M|       13 bits         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| Time-To-Live  |   Protocol      |      Header Checksum        |</span><br><span class="line">| ttl(8 bits)   |    8 bits       |          16 bits            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|               Source IP Address (32 bits)                     |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|              Destination Ip Address (32 bits)                 |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options (*** bits)          |  Padding     |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;net-protocol&quot;&gt;&lt;a href=&quot;#net-protocol&quot; class=&quot;headerlink&quot; title=&quot;net-protocol&quot;&gt;&lt;/a&gt;net-protocol&lt;/h1&gt;&lt;p&gt;基于go 实现链路层、网络层、传输层、应用层 网络协议栈 ，
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
    
      <category term="Go" scheme="http://blog.huido.site/tags/Go/"/>
    
      <category term="Protocol" scheme="http://blog.huido.site/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>GO标准库和算法应用</title>
    <link href="http://blog.huido.site/wiki/go-stl/GO%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.huido.site/wiki/go-stl/GO标准库和算法应用/</id>
    <published>2017-10-24T13:28:59.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go-stl"><a href="#go-stl" class="headerlink" title="go-stl"></a>go-stl</h1><p>todo..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;go-stl&quot;&gt;&lt;a href=&quot;#go-stl&quot; class=&quot;headerlink&quot; title=&quot;go-stl&quot;&gt;&lt;/a&gt;go-stl&lt;/h1&gt;&lt;p&gt;todo..&lt;/p&gt;

      
    
    </summary>
    
      <category term="go-stl" scheme="http://blog.huido.site/categories/go-stl/"/>
    
    
      <category term="Go" scheme="http://blog.huido.site/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Welcome Brewlin&#39;s Wiki Site</title>
    <link href="http://blog.huido.site/wiki/index/"/>
    <id>http://blog.huido.site/wiki/index/</id>
    <published>2017-01-21T17:55:57.000Z</published>
    <updated>2019-10-23T09:19:00.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="net-protocol"><a href="#net-protocol" class="headerlink" title="@net-protocol"></a>@net-protocol</h2><p>基于go模拟内核协议栈 实现链路层、网络层、传输层、应用层 网络协议栈 ，使用虚拟网卡实现</p><h2 id="go-stl"><a href="#go-stl" class="headerlink" title="@go-stl"></a>@go-stl</h2><p>Golang Standard Template Library</p><h2 id="im-cloud"><a href="#im-cloud" class="headerlink" title="@im-cloud"></a>@im-cloud</h2><p>原生swoole4 全协程化分布式中间件、多节点扩容、多节点服务</p><h2 id="swoft-im"><a href="#swoft-im" class="headerlink" title="@swoft-im"></a>@swoft-im</h2><p>基于swoft-cloud的微服务架构，最小化拆分粒度，PHP7、多进程、协程、异步任务、mysql连接池、redi连接池、rpc连接池、服务治理、服务注册与发现、Aop切面、全注解 <a href="http://chat.huido.site">http://chat.huido.site</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;net-protocol&quot;&gt;&lt;a href=&quot;#net-protocol&quot; class=&quot;headerlink&quot; title=&quot;@net-protocol&quot;&gt;&lt;/a&gt;@net-protocol&lt;/h2&gt;&lt;p&gt;基于go模拟内核协议栈 实现链路层、网络层、传输层、应用
      
    
    </summary>
    
    
  </entry>
  
</feed>
