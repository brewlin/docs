<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Brewlin&#39;s Wiki</title>
  
  <subtitle>found everthing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.huido.site/"/>
  <updated>2019-10-26T15:40:12.962Z</updated>
  <id>http://blog.huido.site/</id>
  
  <author>
    <name>brewlin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>arp协议</title>
    <link href="http://blog.huido.site/wiki/net-protocol/4.%E7%BD%91%E7%BB%9C%E5%B1%82/arp%E5%8D%8F%E8%AE%AE/"/>
    <id>http://blog.huido.site/wiki/net-protocol/4.网络层/arp协议/</id>
    <published>2019-10-24T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><p>基于arp协议，获取对应的物理mac地址</p><p><img src="/images/arp.png" alt="image"><br>上层tcp/ip协议报文只包含<code>目标服务器的ip地址</code>，而下层链路层以太网协议需要知道目标服务器的<code>mac地址</code>，则arp的协议是指当前主机发送ARP查询（广播）查询该mac地址，如果目标地址不是在同一个局域网，则该mac地址则是局域网外的路由器mac地址，该所有帧都将发往该路由器地址</p><blockquote><p>总之以太网协议中得到的上层数据中只有IP地址，需要使用arp协议去获得mac地址，arp协议会在链路层进行广播，只有目标地址会回应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARP Paclket Format </span><br><span class="line">arp协议数据包格式</span><br><span class="line">6字节(以太网目的地址)  +  6字节（以太网源地址）   + 2 字节（帧类型）  + 28字节（arp请求回应包）</span><br></pre></td></tr></table></figure></p></blockquote><p>28字节包格式</p><ul><li>2字节硬件类型：1 =&gt; 以太网地址</li><li>2字节协议类型：0x800 表示ipv4协议</li><li>1字节地址长度：单位长度，一般为6  表示以太网地址的长度6字节</li><li>1字节协议地址长度：一般为4，ipv4地址长度</li><li>2字节操作码：1 =&gt; arp请求   2 =&gt; arp应答  3 =&gt; rarp请求  4 =&gt; rarp应答</li><li>6字节原mac地址：源mac地址</li><li>4字节源协议地址：源ip地址 如192.168.0.1</li><li>6字节目标mac地址：mac地址</li></ul><blockquote><p>不用担心每次请求都会触发arp查询广播，机器是有arp高速缓存的 <code>arp -a</code></p></blockquote><h3 id="type"><a href="#type" class="headerlink" title="@type"></a>@type</h3><p>type:0x8060 表示arp协议</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ARP-协议&quot;&gt;&lt;a href=&quot;#ARP-协议&quot; class=&quot;headerlink&quot; title=&quot;ARP 协议&quot;&gt;&lt;/a&gt;ARP 协议&lt;/h2&gt;&lt;p&gt;基于arp协议，获取对应的物理mac地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/arp.png&quot;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="4.网络层" scheme="http://blog.huido.site/categories/net-protocol/4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>ip协议</title>
    <link href="http://blog.huido.site/wiki/net-protocol/4.%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%8D%8F%E8%AE%AE_ip/"/>
    <id>http://blog.huido.site/wiki/net-protocol/4.网络层/协议_ip/</id>
    <published>2019-10-24T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP-报文协议"><a href="#IP-报文协议" class="headerlink" title="IP 报文协议"></a>IP 报文协议</h1><p>首部协议格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0               1               2               3               4</span><br><span class="line">0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Version|  LHL  | Type of Service |        Total Length         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Identification(fragment Id)    |Flags|  Fragment Offset      |</span><br><span class="line">|           16 bits               |R|D|M|       13 bits         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| Time-To-Live  |   Protocol      |      Header Checksum        |</span><br><span class="line">| ttl(8 bits)   |    8 bits       |          16 bits            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|               Source IP Address (32 bits)                     |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|              Destination Ip Address (32 bits)                 |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options (*** bits)          |  Padding     |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    transport data...                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p><code>版本（Version）:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">版本字段占 4bit，通信双方使用的版本必须一致。对于 IPv4，字段的值是 4。</span><br></pre></td></tr></table></figure><p><code>首部长度（Internet Header Length， IHL）:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">占 4bit，首部长度说明首部有多少 32 位字（4字节）。</span><br><span class="line">由于 IPv4首部可能包含数目不定的选项，这个字段也用来确定数据的偏移量。</span><br><span class="line">这个字段的最小值是 5（二进制 0101），相当于 5*4=20 字节（RFC 791），最大十进制值是 15。</span><br></pre></td></tr></table></figure><p><code>区分服务（Differentiated Services，DS):</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">占 8bit，最初被定义为服务类型字段，实际上并未使用，但 1998 年被 IETF 重定义为区分服务 RFC 2474。</span><br><span class="line">只有在使用区分服务时，这个字段才起作用，在一般的情况 下都不使用这个字段。例如需要实时数据流的技术会应用这个字段，一个例子是 VoIP。</span><br></pre></td></tr></table></figure><p><code>显式拥塞通告（ Explicit Congestion Notification，ECN）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 RFC 3168 中定义，允许在不丢弃报文的同时通知对方网络拥塞的发生。</span><br><span class="line">ECN 是一种可选的功能，仅当两端都支持并希望使用，且底层网络支持时才被使用。</span><br></pre></td></tr></table></figure></p><p><code>全长（Total Length）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个 16 位字段定义了报文总长，包含首部和数据，单位为字节。</span><br><span class="line">这个字段的最小值是 20（20 字节首部+0 字节数据），最大值是 216-1=65,535。</span><br><span class="line">IP 规定所有主机都必须支持最小 576 字节的报文，这是假定上层数据长度 512 字节，加上最长 IP 首部 60 字节，加上 4 字节富裕量，</span><br><span class="line">得出 576 字节，但大多数现代主机支持更大的报文。</span><br><span class="line">当下层的数据链路协议的最大传输单元（MTU）字段的值小于 IP 报文长度时间，报文就必须被分片，详细见下个标题。</span><br></pre></td></tr></table></figure></p><p><code>标识符（Identification):</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">占 16 位，这个字段主要被用来唯一地标识一个报文的所有分片，因为分片不一定按序到达，所以在重组时需要知道分片所属的报文。</span><br><span class="line">每产生一个数据报，计数器加 1，并赋值给此字段。一些实验性的工作建议将此字段用于其它目的，例如增加报文跟踪信息以协助探测伪造的源地址。</span><br></pre></td></tr></table></figure></p><p><code>标志 （Flags）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这个 3 位字段用于控制和识别分片，它们是：</span><br><span class="line">位 0：保留，必须为 0； </span><br><span class="line">位 1：禁止分片（Don’t Fragment，DF），当 DF=0 时才允许分片； </span><br><span class="line">位 2：更多分片（More Fragment，MF），MF=1 代表后面还有分片，MF=0 代表已经是最后一个分片。 </span><br><span class="line">如果 DF 标志被设置为 1，但路由要求必须分片报文，此报文会被丢弃。这个标志可被用于发往没有能力组装分片的主机。</span><br><span class="line">当一个报文被分片，除了最后一片外的所有分片都设置 MF 为 1。</span><br><span class="line">最后一个片段具有非零片段偏移字段，将其与未分片数据包区分开，未分片的偏移字段为 0。</span><br></pre></td></tr></table></figure></p><p><code>分片偏移 （Fragment Offset）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个 13 位字段指明了每个分片相对于原始报文开头的偏移量，以 8 字节作单位。</span><br></pre></td></tr></table></figure></p><p><code>存活时间（Time To Live，TTL）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个 8 位字段避免报文在互联网中永远存在（例如陷入路由环路）。</span><br><span class="line">存活时间以秒为单位，但小于一秒的时间均向上取整到一秒。</span><br><span class="line">在现实中，这实际上成了一个跳数计数器：报文经过的每个路由器都将此字段减 1，当此字段等于 0 时，报文不再向下一跳传送并被丢弃，最大值是 255。</span><br><span class="line">常规地，一份 ICMP 报文被发回报文发送端说明其发送的报文已被丢弃。这也是 traceroute 的核心原理。</span><br></pre></td></tr></table></figure></p><p><code>协议 （Protocol）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">占 8bit，这个字段定义了该报文数据区使用的协议。IANA 维护着一份协议列表（最初由 RFC 790 定义），详细参见 IP 协议号列表。</span><br></pre></td></tr></table></figure></p><p><code>首部检验和 （Header Checksum）:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个 16 位检验和字段只对首部查错，不包括数据部分。</span><br><span class="line">在每一跳，路由器都要重新计算出的首部检验和并与此字段进行比对，如果不一致，此报文将会被丢弃。</span><br><span class="line">重新计算的必要性是因为每一跳的一些首部字段（如 TTL、Flag、Offset 等）都有可能发生变化，不检查数据部分是为了减少工作量。</span><br><span class="line">数据区的错误留待上层协议处理——用户数据报协议（UDP）和传输控制协议（TCP）都有检验和字段。此处的检验计算方法不使用 CRC。</span><br></pre></td></tr></table></figure></p><p><code>源地址</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个 IPv4 地址由四个字节共 32 位构成，此字段的值是将每个字节转为二进制并拼在一起所得到的 32 位值。</span><br><span class="line">例如，10.9.8.7 是 00001010000010010000100000000111。</span><br><span class="line">但请注意，因为 NAT 的存在，这个地址并不总是报文的真实发送端，因此发往此地址的报文会被送往 NAT 设备，并由它被翻译为真实的地址。</span><br></pre></td></tr></table></figure><p><code>目的地址</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与源地址格式相同，但指出报文的接收端。</span><br></pre></td></tr></table></figure></p><p><code>选项:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">附加的首部字段可能跟在目的地址之后，但这并不被经常使用，从 1 到 40 个字节不等。</span><br><span class="line">请注意首部长度字段必须包括足够的 32 位字来放下所有的选项（包括任何必须的填充以使首部长度能够被 32 位整除）。</span><br><span class="line">当选项列表的结尾不是首部的结尾时，EOL（选项列表结束，0x00）选项被插入列表末尾。下表列出了可能。</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>字段</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td>备份</td><td>1</td><td>当此选项需要被备份到所有分片中时，设为 1。</td></tr><tr><td>类</td><td>2</td><td>常规的选项类别，0 为“控制”，2 为“查错和措施”，1 和 3 保留。</td></tr><tr><td>数字</td><td>5</td><td>指明一个选项。</td></tr><tr><td>长度</td><td>8</td><td>指明整个选项的长度，对于简单的选项此字段可能不存在。</td></tr><tr><td>数据</td><td>可变</td><td>选项相关数据，对于简单的选项此字段可能不存在。</td></tr></tbody></table><blockquote><p>注：如果首部长度大于 5，那么选项字段必然存在并必须被考虑。<br>注：备份、类和数字经常被一并称呼为“类型”。</p></blockquote><ul><li>数据 数据字段不是首部的一部分，因此并不被包含在首部检验和中。数据的格式在协议首部字段中被指明，并可以是任意的传输层协议。 一些常见协议的协议字段值被列在下面</li></ul><table><thead><tr><th>协议字段值</th><th>协议名</th><th>缩写</th></tr></thead><tbody><tr><td>1</td><td>互联网控制消息协议</td><td>ICMP</td></tr><tr><td>2</td><td>互联网组管理协议</td><td>IGMP</td></tr><tr><td>6</td><td>传输控制协议</td><td>TCP</td></tr><tr><td>17</td><td>用户数据报协议</td><td>UDP</td></tr><tr><td>41</td><td>IPv6 封装</td><td>ENCAP</td></tr><tr><td>89</td><td>开放式最短路径优先</td><td>OSPF</td></tr><tr><td>132</td><td>流控制传输协议</td><td>SCTP</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IP 层最重要的目的是让两个主机之间通信，无论他们相隔多远。<br>IP 协议理论上允许的最大 IP 数据报为 <code>65535</code> 字节（16 位来表示包总长）。<br>但是因为协议栈网络层下面的数据链路层一般允许的帧长远远小于这个值，例如以太网的 MTU 通常在 <code>1500</code> 字节左右。<br>所以较大的 IP 数据包会被<code>分片传</code>递给数据链路层发送，分片的 IP 数据报可能会以不同的路径传输到接收主机，接收主机通过一系列的<code>重组</code>，将其还原为一个完整的 IP 数据报，再提交给上层协议处理。<br>IP 分片会带来一定的问题，分片和重组会消耗发送方、接收方一定的 CPU 等资源，如果存在大量的分片报文的话，可能会造成较为严重的资源消耗；分片丢包导致的重传问题；分片攻击；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IP-报文协议&quot;&gt;&lt;a href=&quot;#IP-报文协议&quot; class=&quot;headerlink&quot; title=&quot;IP 报文协议&quot;&gt;&lt;/a&gt;IP 报文协议&lt;/h1&gt;&lt;p&gt;首部协议格式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="4.网络层" scheme="http://blog.huido.site/categories/net-protocol/4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>端口机制</title>
    <link href="http://blog.huido.site/wiki/net-protocol/4.%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%8D%8F%E8%AE%AE_%E7%AB%AF%E5%8F%A3/"/>
    <id>http://blog.huido.site/wiki/net-protocol/4.网络层/协议_端口/</id>
    <published>2019-10-24T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><h2 id="端口在tcp协议中的体现"><a href="#端口在tcp协议中的体现" class="headerlink" title="端口在tcp协议中的体现"></a>端口在tcp协议中的体现</h2><p>端口一般在tcp首部前四个字节中，前2字节表示源端口 后两字节表示目标端口<br><img src="5F5BC33465194D9E82C737A5030A7808" alt="image"></p><p>1.周知端口（Well Known Ports）<br>周知端口是众所周知的端口号，范围从 0 到 1023，其中 80 端口分配给 WWW 服务，21 端口分配给 FTP 服务等。我们在 IE 的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下 WWW 服务的端口是”80”。网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在 地址栏上指定端口号，方法是在地址后面加上冒号”:”，再加上端口号。比如使用”8080”作为 WWW 服务的端口，则需要在地址栏里输入”网址:8080”。但是有些系统协议使用固定的端口号，它是不能被改变的，比如 139 端口专门用于 NetBIOS 与 TCP/IP 之间的通信，不能手动改变。</p><p>2.注册端口（Registered Ports）<br>端口 1024 到 49151，分配给用户进程或应用程序。这些进程主要是用户选择安装的一些应用程序，而不是已经分配好了公认端口的常用程序。这些端口在没有被服务器资源占用的时候，可以用用户端动态选用为源端口。</p><p>3.动态端口（Dynamic Ports）<br>动态端口的范围是从 49152 到 65535。之所以称为动态端口，是因为它 一般不固定分配某种服务，而是动态分配。比如本地想和远端建立 TCP 连接，如果没有指定本地源端口，系统就会给你自动分配一个未占用的源端口，这个端口值就是动态的，当你断开再次建立连接的时候，很有可能你的源端口和上次得到的端口不一样。</p><p>一些常见的端口号及其用途如下：</p><ul><li>TCP21 端口：FTP 文件传输服务</li><li>TCP22 端口：SSH 安全外壳协议</li><li>TCP23 端口：TELNET 终端仿真服务</li><li>TCP25 端口：SMTP 简单邮件传输服务</li><li>UDP53 端口：DNS 域名解析服务</li><li>UDP67 端口：DHCP 的服务端端口 UDP68 端口：DHCP 的客户端端口 TCP80 端口：HTTP 超文本传输服务</li><li>TCP110 端 口：POP3“邮局协议版本 3”使用的端口</li><li>TCP443 端口：HTTPS 加密的超文本传输服务</li></ul><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>端口是<code>网络层协议地址+传输层协议号+端口号</code>来区分的，比如：</p><p><code>ipv4的tcp 80</code>端口和<code>ipv4的udp 8</code>0端口不会冲突。</p><p>如果你主机有两个 ip 地址 ip1 和 ip2，那么你同时监听<code>ip1:80</code>和<code>ip2:80</code>不会冲突。</p><p><code>ipv4的tcp 80</code>端口和ipv6的<code>tcp 80</code>端口不会冲突。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;端口&quot;&gt;&lt;a href=&quot;#端口&quot; class=&quot;headerlink&quot; title=&quot;端口&quot;&gt;&lt;/a&gt;端口&lt;/h1&gt;&lt;h2 id=&quot;端口在tcp协议中的体现&quot;&gt;&lt;a href=&quot;#端口在tcp协议中的体现&quot; class=&quot;headerlink&quot; title=&quot;端
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="4.网络层" scheme="http://blog.huido.site/categories/net-protocol/4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>icmp协议</title>
    <link href="http://blog.huido.site/wiki/net-protocol/4.%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%8D%8F%E8%AE%AE_icmp/"/>
    <id>http://blog.huido.site/wiki/net-protocol/4.网络层/协议_icmp/</id>
    <published>2019-10-24T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h1><p>ICMP 的全称是 Internet Control Message Protocol 。与 IP 协议一样同属 TCP/IP 模型中的网络层，并且 ICMP 数据包是包裹在 IP 数据包中的。他的作用是报告一些网络传输过程中的错误与做一些同步工作。ICMP 数据包有许多类型。每一个数据包只有前 4 个字节是相同域的，剩余的字段有不同的数据包类型的不同而不同。ICMP 数据包的格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">https://tools.ietf.org/html/rfc792</span><br><span class="line"></span><br><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |     Code      |          Checksum             |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">|                   不同的Type和Code有不同的内容                    |         </span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>从技术角度来说，ICMP 就是一个“错误侦测与回报机制”， 其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性﹐其功能主要有：</p><ul><li>侦测远端主机是否存在。</li><li>建立及维护路由信息。</li><li>重导数据传送路径（ICMP 重定向）。</li><li>数据流量控制。<br>ICMP 在沟通之中，主要是透过不同的类别(Type)与代码(Code) 让机器来识别不同的连线状况。</li></ul><h2 id="完整类型列表"><a href="#完整类型列表" class="headerlink" title="完整类型列表"></a>完整类型列表</h2><table><thead><tr><th>TYPE</th><th>CODE</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>Echo Reply——回显应答（Ping 应答）</td></tr><tr><td>3</td><td>0</td><td>Network Unreachable——网络不可达</td></tr><tr><td>3</td><td>1</td><td>Host Unreachable——主机不可达</td></tr><tr><td>3</td><td>2</td><td>Protocol Unreachable——协议不可达</td></tr><tr><td>3</td><td>3</td><td>Port Unreachable——端口不可达</td></tr><tr><td>3</td><td>4</td><td>Fragmentation needed but no frag. bit set——需要进行分片但设置不分片标志</td></tr><tr><td>3</td><td>5</td><td>Source routing failed——源站选路失败</td></tr><tr><td>3</td><td>6</td><td>Destination network unknown——目的网络未知</td></tr><tr><td>3</td><td>7</td><td>Destination host unknown——目的主机未知</td></tr><tr><td>3</td><td>8</td><td>Source host isolated (obsolete)——源主机被隔离（作废不用）</td></tr><tr><td>3</td><td>9</td><td>Destination network administratively prohibited——目的网络被强制禁止</td></tr><tr><td>3</td><td>10</td><td>Destination host administratively prohibited——目的主机被强制禁止</td></tr><tr><td>3</td><td>11</td><td>Network unreachable for TOS——由于服务类型 TOS，网络不可达</td></tr><tr><td>3</td><td>12</td><td>Host unreachable for TOS——由于服务类型 TOS，主机不可达</td></tr><tr><td>3</td><td>13</td><td>Communication administratively prohibited by filtering——由于过滤，通信被强制禁止</td></tr><tr><td>3</td><td>14</td><td>Host precedence violation——主机越权</td></tr><tr><td>3</td><td>15</td><td>Precedence cutoff in effect——优先中止生效</td></tr><tr><td>4</td><td>0</td><td>Source quench——源端被关闭（基本流控制）</td></tr><tr><td>5</td><td>0</td><td>Redirect for network——对网络重定向</td></tr><tr><td>5</td><td>1</td><td>Redirect for host——对主机重定向</td></tr><tr><td>5</td><td>2</td><td>Redirect for TOS and network——对服务类型和网络重定向</td></tr><tr><td>5</td><td>3</td><td>Redirect for TOS and host——对服务类型和主机重定向</td></tr><tr><td>8</td><td>0</td><td>Echo request——回显请求（Ping 请求）</td></tr><tr><td>9</td><td>0</td><td>Router advertisement——路由器通告</td></tr><tr><td>10</td><td>0</td><td>Route solicitation——路由器请求</td></tr><tr><td>11</td><td>0</td><td>TTL equals 0 during transit——传输期间生存时间为 0</td></tr><tr><td>11</td><td>1</td><td>TTL equals 0 during reassembly——在数据报组装期间生存时间为 0</td></tr><tr><td>12</td><td>0</td><td>IP header bad (catchall error)——坏的 IP 首部（包括各种差错）</td></tr><tr><td>12</td><td>1</td><td>Required options missing——缺少必需的选项</td></tr><tr><td>13</td><td>0</td><td>Timestamp request (obsolete)——时间戳请求（作废不用）</td></tr><tr><td>14</td><td></td><td>Timestamp reply (obsolete)——时间戳应答（作废不用）</td></tr><tr><td>15</td><td>0</td><td>Information request (obsolete)——信息请求（作废不用）</td></tr><tr><td>16</td><td>0</td><td>Information reply (obsolete)——信息应答（作废不用）</td></tr><tr><td>17</td><td>0</td><td>Address mask request——地址掩码请求</td></tr><tr><td>18</td><td>0</td><td>Address mask</td></tr></tbody></table><p>ICMP 是个非常有用的协议，尤其是当我们要对网路连接状况进行判断的时候。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ICMP-协议&quot;&gt;&lt;a href=&quot;#ICMP-协议&quot; class=&quot;headerlink&quot; title=&quot;ICMP 协议&quot;&gt;&lt;/a&gt;ICMP 协议&lt;/h1&gt;&lt;p&gt;ICMP 的全称是 Internet Control Message Protocol 。与 IP 
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="4.网络层" scheme="http://blog.huido.site/categories/net-protocol/4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>tcp头部</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/1.%E5%A4%B4%E9%83%A8/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/tcp/1.头部/</id>
    <published>2019-10-22T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传输层-tcp-协议-实现"><a href="#传输层-tcp-协议-实现" class="headerlink" title="传输层 tcp 协议 实现"></a>传输层 tcp 协议 实现</h1><p><img src="43E0E23D5D324B8CA750C4F99EF4E3A7" alt="image"></p><h2 id="首部协议格式"><a href="#首部协议格式" class="headerlink" title="首部协议格式"></a>首部协议格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |           |G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><h3 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h3><p>各占 2 个字节，分别 tcp 连接的源端口和目的端口。关于端口的概念之前已经介绍过了。</p><h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>占 4 字节，序号范围是[0，2^32 - 1]，共 2^32（即 4294967296）个序号。序号增加到 2^32-1 后，下一个序号就又回到 0。TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号（ISN）必须在连接建立时设置。<code>首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号</code>。例如，一报文段的序号是 301，而接待的数据共有 100 字节。这就表明：本报文段的数据的第一个字节的序号是 301，最后一个字节的序号是 400。显然，下一个报文段（如果还有的话）的数据序号应当从 401 开始，即下一个报文段的序号字段值应为 401。</p><h3 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h3><p>占 4 字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B 正确收到了 A 发送过来的一个报文段，其序号字段值是 501，而数据长度是 200 字节（序号 501~700），这表明 B 正确收到了 A 发送的到序号 700 为止的数据。因此，B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701。注意，现在确认号不是 501，也不是 700，而是 701。<br>总之：若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。TCP 除了第一个 SYN 报文之外，所有 TCP 报文都需要携带 ACK 状态位。</p><h3 id="数据偏移"><a href="#数据偏移" class="headerlink" title="数据偏移"></a>数据偏移</h3><p>占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。<code>这个字段实际上是指出 TCP 报文段的首部长度</code>。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是 4 个字节，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节。</p><h3 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h3><p>占 6 位，保留为今后使用，但目前应置为 0。</p><h3 id="控制报文标志"><a href="#控制报文标志" class="headerlink" title="控制报文标志"></a>控制报文标志</h3><h4 id="紧急URG（URGent）"><a href="#紧急URG（URGent）" class="headerlink" title="紧急URG（URGent）"></a>紧急URG（URGent）</h4><p>当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收 TCP 的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。<br>当 URG 置为 1 时，发送应用进程就告诉发送方的 TCP 有紧急数据要传送。于是发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。</p><h4 id="确认ACK（ACKnowledgment）"><a href="#确认ACK（ACKnowledgment）" class="headerlink" title="确认ACK（ACKnowledgment）"></a>确认ACK（ACKnowledgment）</h4><p>仅当 ACK=1 时确认号字段才有效，当 ACK=0 时确认号无效。TCP 规定，在连接建立后所有的传送的报文段都必须把 ACK 置为 1。</p><h4 id="推送-PSH（PuSH）"><a href="#推送-PSH（PuSH）" class="headerlink" title="推送 PSH（PuSH）"></a>推送 PSH（PuSH）</h4><p>当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH=1 的报文段，就尽快地交付接收应用进程。<br>复位RST（ReSeT）<br>当 RST=1 时，表名 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST 置为 1 用来拒绝一个非法的报文段或拒绝打开一个连接。</p><h4 id="同步SYN（SYNchronization）"><a href="#同步SYN（SYNchronization）" class="headerlink" title="同步SYN（SYNchronization）"></a>同步SYN（SYNchronization）</h4><p>在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN=1 和 ACK=1，因此 SYN 置为 1 就表示这是一个连接请求或连接接受报文。</p><h4 id="终止FIN（FINis，意思是“完”“终”）"><a href="#终止FIN（FINis，意思是“完”“终”）" class="headerlink" title="终止FIN（FINis，意思是“完”“终”）"></a>终止FIN（FINis，意思是“完”“终”）</h4><p>用来释放一个连接。当 FIN=1 时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p><h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>占 2 字节，窗口值是[0，2^16-1]之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据，作为流量控制的依据，后面会详细介绍。<br>总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。</p><h3 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h3><p>占 2 字节，检验和字段检验的范围包括首部和数据这两部分。和 UDP 用户数据报一样，在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。伪首部的格式和 UDP 用户数据报的伪首部一样。但应把伪首部第 4 个字段中的 17 改为 6（TCP 的协议号是 6）；把第 5 字段中的 UDP 中的长度改为 TCP 长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用 IPv6，则相应的伪首部也要改变。</p><h3 id="紧急指针"><a href="#紧急指针" class="headerlink" title="紧急指针"></a>紧急指针</h3><p>占 2 字节，紧急指针仅在 URG=1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据) 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为 0 时也可以发送紧急数据。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>选项长度可变，最长可达 40 字节。当没有使用“选项”时，TCP 的首部长度是 20 字节。TCP 首部总长度由 TCP 头中的“数据偏移”字段决定，前面说了，最长偏移为 60 字节。那么“tcp 选项”的长度最大为 60-20=40 字节。</p><h4 id="选项的一般结构体"><a href="#选项的一般结构体" class="headerlink" title="选项的一般结构体"></a>选项的一般结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  1byte    1byte        nbytes</span><br><span class="line">+--------+--------+------------------+ </span><br><span class="line">| Kind   | Length |       Info       |</span><br><span class="line">+--------+--------+------------------+</span><br></pre></td></tr></table></figure><p>TCP 最初只规定了一种选项，即最大报文段长度 MSS（Maximum Segment Szie）。后来又增加了几个选项如窗口扩大选项、时间戳选项等，下面说明常用的选项。</p><p>kind=0 是选项表结束选项。</p><p>kind=1 是空操作（nop）选项<br>没有特殊含义，一般用于将 TCP 选项的总长度填充为 4 字节的整数倍，为啥需要 4 字节整数倍？因为前面讲了数据偏移字段的单位是 4 个字节。</p><p>kind=2 是最大报文段长度选项<br>TCP 连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP 模块通常将 MSS 设置为（MTU-40）字节（减掉的这 40 字节包括 20 字节的 TCP 头部和 20 字节的 IP 头部）。这样携带 TCP 报文段的 IP 数据报的长度就不会超过 MTU（假设 TCP 头部和 IP 头部都不包含选项字段，并且这也是一般情况），从而避免本机发生 IP 分片。对以太网而言，MSS 值是 1460（1500-40）字节。</p><p>kind=3 是窗口扩大因子选项<br>TCP 连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在 TCP 的头部中，接收通告窗口大小是用 16 位表示的，故最大为 65535 字节，但实际上 TCP 模块允许的接收通告窗口大小远不止这个数（为了提高 TCP 通信的吞吐量）。窗口扩大因子解决了这个问题。假设 TCP 头部中的接收通告窗口大小是 N，窗口扩大因子（移位数）是 M，那么 TCP 报文段的实际接收通告窗口大小是 N 乘 2M，或者说 N 左移 M 位。注意，M 的取值范围是 0～14。</p><p>和 MSS 选项一样，窗口扩大因子选项只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该 TCP 报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。关于窗口扩大因子选项的细节，可参考标准文档 RFC 1323。</p><p>kind=4 是选择性确认（Selective Acknowledgment，SACK）选项<br>TCP 通信时，如果某个 TCP 报文段丢失，则 TCP 模块会重传最后被确认的 TCP 报文段后续的所有报文段，这样原先已经正确传输的 TCP 报文段也可能重复发送，从而降低了 TCP 性能。SACK 技术正是为改善这种情况而产生的，它使 TCP 模块只重新发送丢失的 TCP 报文段，不用发送所有未被确认的 TCP 报文段。选择性确认选项用在连接初始化时，表示是否支持 SACK 技术。</p><p>kind=5 是 SACK 实际工作的选项<br>该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿（edge of block）参数包含一个 4 字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用 8 字节，所以 TCP 头部选项中实际上最多可以包含 4 个这样的不连续数据块（考虑选项类型和长度占用的 2 字节）。</p><p>kind=8 是时间戳选项<br>该选项提供了较为准确的计算通信双方之间的回路时间（Round Trip Time，RTT）的方法，从而为 TCP 流量控制提供重要信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;传输层-tcp-协议-实现&quot;&gt;&lt;a href=&quot;#传输层-tcp-协议-实现&quot; class=&quot;headerlink&quot; title=&quot;传输层 tcp 协议 实现&quot;&gt;&lt;/a&gt;传输层 tcp 协议 实现&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;43E0E23D5D324B8C
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>udp协议</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/udp/1.%E5%8D%8F%E8%AE%AE/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/udp/1.协议/</id>
    <published>2019-10-22T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="udp协议"><a href="#udp协议" class="headerlink" title="udp协议"></a>udp协议</h1><h2 id="udp协议-包体"><a href="#udp协议-包体" class="headerlink" title="udp协议 包体"></a>udp协议 包体</h2><p><img src="C5DAEAF2697B45D6927F108780C6324E" alt="image"></p><ol><li>源端口 源端口号</li><li>目的端口 目的端口号</li><li>长度 UDP 数据报的长度，包含首部，最小为 8</li><li>检验和 UDP 数据报的校验和，如果接收到检验和不正确的情况下，直接丢弃该报文。</li></ol><h2 id="计算校验和算法"><a href="#计算校验和算法" class="headerlink" title="计算校验和算法"></a>计算校验和算法</h2><p>UDP 计算校验和的方法和 IP 数据报首部校验和的方法相似。不同的是：IP 数据报校验和只校验 IP 数据报的首部，但 UDP 的校验和是把首部和数据部分一起都检验。</p><p>UDP 的校验和需要计算 UDP 首部加数据荷载部分，但也需要加上 UDP 伪首部。这个伪首部指，源地址、目的地址、UDP 数据长度、协议类型（0x11），协议类型就一个字节，但需要补一个字节的 0x0，构成 12 个字节。伪首部+UDP 首部+数据一起计算校验和。</p><p>UDP 检验和的计算方法是：<br>按每 16 位求和得出一个 32 位的数；<br>如果这个 32 位的数，高 16 位不为 0，则高 16 位加低 16 位再得到一个 32 位的数；<br>重复第 2 步直到高 16 位为 0，将低 16 位取反，得到校验和。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;udp协议&quot;&gt;&lt;a href=&quot;#udp协议&quot; class=&quot;headerlink&quot; title=&quot;udp协议&quot;&gt;&lt;/a&gt;udp协议&lt;/h1&gt;&lt;h2 id=&quot;udp协议-包体&quot;&gt;&lt;a href=&quot;#udp协议-包体&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="udp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/udp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="udp" scheme="http://blog.huido.site/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>tcp可靠性机制</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/3.%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/tcp/3.可靠性机制/</id>
    <published>2019-10-22T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcp-可靠性机制"><a href="#tcp-可靠性机制" class="headerlink" title="tcp 可靠性机制"></a>tcp 可靠性机制</h1><p>可靠性指的是网络层能通信的前提下，保证数据包正确且按序到达对端。 比如发送端发送了“12345678”，那么接收端一定能收到“12345678”，不会乱序“12456783”，也不会少或多数据。</p><h2 id="实现-TCP-的可靠传输有以下机制："><a href="#实现-TCP-的可靠传输有以下机制：" class="headerlink" title="实现 TCP 的可靠传输有以下机制："></a>实现 TCP 的可靠传输有以下机制：</h2><p>1.<code>校验和机制</code>（检测和重传受到损伤的报文段）</p><p>2.<code>确认应答机制</code>（保存失序到达的报文段直至缺失的报文到期，以及检测和丢弃重复的报文段）</p><p>3.<code>超时重传机制</code>（重传丢失的报文段）</p><h2 id="1-校验和"><a href="#1-校验和" class="headerlink" title="1.校验和"></a>1.校验和</h2><p>每个 tcp 段都包含了一个检验和字段，用来检查报文段是否收到损伤。如果某个报文段因检验和无效而被检查出受到损伤，就由终点 TCP 将其丢弃，并被认为是丢失了。TCP 规定每个报文段都必须使用 <code>16 位的检验和</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 校验和的计算</span><br><span class="line">func Checksum(buf []byte, initial uint16) uint16 &#123;</span><br><span class="line">v := uint32(initial)</span><br><span class="line"></span><br><span class="line">l := len(buf)</span><br><span class="line">if l&amp;1 != 0 &#123;</span><br><span class="line">l--</span><br><span class="line">v += uint32(buf[l]) &lt;&lt; 8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; l; i += 2 &#123;</span><br><span class="line">v += (uint32(buf[i]) &lt;&lt; 8) + uint32(buf[i+1])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return ChecksumCombine(uint16(v), uint16(v&gt;&gt;16))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-确认机制"><a href="#2-确认机制" class="headerlink" title="2.确认机制"></a>2.确认机制</h2><p>控制报文段不携带数据，但需要消耗一个序号，它也需要被确认，而 ACK 报文段永远不需要确认，ACK 报文段不消耗序号，也不需要被确认。在以前，TCP 只使用一种类型的确认，叫积累确认，目前 TCP 实现还实现了选择确认。</p><ul><li>累积确认（ACK）</li></ul><p>接收方通告它期望接收的下一个字节的序号，并忽略所有失序到达并被保存的报文段。有时这被称为肯定累积确认。在 TCP 首部的 32 位 ACK 字段用于积累确认，而它的值仅在 ACK 标志为 1 时才有效。举个例子来说，这里先不考虑 tcp 的序列号，如果发送方发了数据包 p1，p2，p3，p4；接受方成功收到 p1，p2，p4。那么接收方需要发回一个确认包，序号为 3(3 表示期望下一个收到的包的序号)，那么发送方就知道 p1 到 p2 都发送接收成功，必要时重发 p3。一个确认包确认了累积到某一序号的所有包，而不是对每个序号都发确认包。实际的 tcp 确认的都是序列号，而不是包的序号，但原理是一样的。</p><p>累积确认是快速重传的基础，这个后面讲拥塞控制的时候会详细说明。</p><p>累积确认是快速重传的基础，这个后面讲拥塞控制的时候会详细说明。</p><ul><li>选择确认（SACK）</li></ul><p>选择确认 SACK 要报告失序的数据块以及重复的报文段块，是为了更准确的告诉发送方需要重传哪些数据块。SACK 并没有取代 ACK，而是向发送方报告了更多的信息。SACK 是作为 TCP 首部末尾的选项来实现的。<br>首先是否要启动 sack，应该在握手的时候告诉对方自己是否开启了 sack，这个是通过 kind=4 是选择性确认（Selective Acknowledgment，SACK）选项来实现的。<br>实际传送 sack 信息的是 kind=5 的选项，其格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">         +--------+--------+</span><br><span class="line">         | Kind=5 | Length | </span><br><span class="line">+--------+--------+--------+---------+ </span><br><span class="line">|          Start of 1st Block        | </span><br><span class="line">+--------+--------+--------+---------+ </span><br><span class="line">|           End of 1st Block         | </span><br><span class="line">+--------+--------+--------+---------+ </span><br><span class="line">|                                    | </span><br><span class="line">/            . . . . . .             / </span><br><span class="line">|                                    | </span><br><span class="line">+--------+--------+--------+---------+ </span><br><span class="line">|          Start of nth Block        | </span><br><span class="line">+--------+--------+--------+---------+ </span><br><span class="line">|           End of nth Block         | </span><br><span class="line">+--------+--------+--------+---------+</span><br></pre></td></tr></table></figure></p><p>sack 的每个块是由两个参数构成的<code>{ Start, End }</code> Start 不连续块的第一个数据的序列号。End 不连续块的最后一个数据的序列号之后的序列号。 该选项参数告诉对方已经接收到并缓存的不连续的数据块，<code>注意都是已经接收的</code>，发送方可根据此信息检查究竟是哪个块丢失，从而发送相应的数据块。 比如下图：<br><img src="07D550B59368499399ABFDD70C3735A0" alt="image"><br>如图所示，tcp 接收方在接收到不连续的 tcp 段，可以看出，序号 1～1000，1501～3000，3501～4500 接收到了，但却少了序号 1001～1500，3001～3500 。 前面说了，sack <code>报告的是已接收的不连续的块</code>，在这个例子中，sack 块的内容为<code>{Start:1501, End:3001},{Start:3501, End:4501}</code>， 注意：这里的 End 不是接收到数据段最后的序列号，而是最后的序列号加 1。</p><h3 id="产生确认的情况-确认机制"><a href="#产生确认的情况-确认机制" class="headerlink" title="产生确认的情况 确认机制"></a>产生确认的情况 确认机制</h3><ol><li>当接收方收到了按序到达（序号是所期望的）的报文段，那么接收方就累积发送确认报文段。</li><li>当具有所期望的序号的报文段到达，而前一个按序到达的报文段还没有被确认，那么接收方就要立即发送 ACK 报文段。</li><li>当序号比期望的序号还大的失序报文段到达时，接收方立即发送 ACK 报文段，并宣布下一个期望的报文段序号。这将导致对丢失报文段的快重传。</li><li>当一个丢失的报文段到达时，接收方要发送 ACK 报文段，并宣布下一个所期望的序号。</li><li>如果到达一个重复的报文段，接收方丢弃该报文段，但是应当立即发送确认，指出下一个期望的报文段。</li><li>收到 fin 报文的时候，立即回复确认。</li></ol><h2 id="3-重传机制"><a href="#3-重传机制" class="headerlink" title="3.重传机制"></a>3.重传机制</h2><p>关于重传的基本概念<br>RTO 即超时重传时间<br>RTT 数据包往返时间<br>平均偏差是指单项测定值与平均值的偏差（取绝对值）之和，除以测定次数。<br><img src="DEE81BB910FD42709B8CF09BEBF8055C" alt="image"><br>可靠性的核心就是报文段的重传。在一个报文段发送时，它会被保存到一个队列中，直至被确认为止。当重传计时器超时，或者发送方收到该队列中第一个报文段的三个重复的 ACK 时，该报文段被重传。</p><p>超时重传的概念很简单，就是一定时间内未收到确认，进行再次发送，但是如何计算重传的时间确实 tcp 最复杂的问题之一，毕竟要适应各种网络情况。TCP 一个连接期间只有一个 RTO 计时器，目前大部分实现都是采用<code>Jacobaon/Karels 算法</code>，详细可以看<code>RFC6298</code>，其计算公式如下，</p><p>rto 的计算公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一次rtt计算： </span><br><span class="line">SRTT = R</span><br><span class="line">RTTVAR = R/2</span><br><span class="line">RTO = SRTT + max (G, K*RTTVAR)</span><br><span class="line">K = 4</span><br><span class="line"></span><br><span class="line">之后：</span><br><span class="line">RTTVAR = (1 - beta) * RTTVAR + beta * |SRTT - R&apos;|</span><br><span class="line">SRTT = (1 - alpha) * SRTT + alpha * R&apos;</span><br><span class="line">RTO = SRTT + max (G, K*RTTVAR)</span><br><span class="line">K = 4</span><br></pre></td></tr></table></figure></p><p>SRTT(smoothed round-trip time)平滑 RTT 时间<br>RTTVAR(round-trip time variation)RTT 变量，其实就是 rtt 平均偏差<br>G 表示系统时钟的粒度，一般很小，us 级别。 beta = 1/4, alpha = 1/8</p><p>发送方 TCP 的计时器时间到，TCP 发送队列中最前面的报文段（即序列号最小的报文段），并重启计时器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tcp-可靠性机制&quot;&gt;&lt;a href=&quot;#tcp-可靠性机制&quot; class=&quot;headerlink&quot; title=&quot;tcp 可靠性机制&quot;&gt;&lt;/a&gt;tcp 可靠性机制&lt;/h1&gt;&lt;p&gt;可靠性指的是网络层能通信的前提下，保证数据包正确且按序到达对端。 比如发送端发送了“
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>tcp流量控制</title>
    <link href="http://blog.huido.site/wiki/net-protocol/3.%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/2.%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <id>http://blog.huido.site/wiki/net-protocol/3.传输层/tcp/2.流量控制/</id>
    <published>2019-10-22T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcp-流量控制"><a href="#tcp-流量控制" class="headerlink" title="tcp 流量控制"></a>tcp 流量控制</h1><p>tcp是由丢包重传的机制的</p><p>那么如果服务端因为负载导致不能接受发送端的数据从而丢弃数据</p><p>发送端接受到ack确认为丢包后导致重传</p><p>然后服务端导致负载更加严重，从而一个劲的重发数据，对网络造成更大的伤害。于是就提出了拥塞控制，当拥塞发生的时候，要做自我牺牲，降低发送速率。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tcp-流量控制&quot;&gt;&lt;a href=&quot;#tcp-流量控制&quot; class=&quot;headerlink&quot; title=&quot;tcp 流量控制&quot;&gt;&lt;/a&gt;tcp 流量控制&lt;/h1&gt;&lt;p&gt;tcp是由丢包重传的机制的&lt;/p&gt;
&lt;p&gt;那么如果服务端因为负载导致不能接受发送端的数据从而
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="3.传输层" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/categories/net-protocol/3-%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="tcp" scheme="http://blog.huido.site/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>websocket算法</title>
    <link href="http://blog.huido.site/wiki/net-protocol/2.%E5%BA%94%E7%94%A8%E5%B1%82/websocket/2.websocket%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.huido.site/wiki/net-protocol/2.应用层/websocket/2.websocket算法/</id>
    <published>2019-10-21T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="websocket协议中的一些算法"><a href="#websocket协议中的一些算法" class="headerlink" title="websocket协议中的一些算法"></a>websocket协议中的一些算法</h2><p>在分析 WebSocket 协议握手过程和数据帧格式过程中，我们讲到了一些算法，下面我们讲解下具体实现。</p><h2 id="Sec-WebSocket-Accept的计算方法"><a href="#Sec-WebSocket-Accept的计算方法" class="headerlink" title="Sec-WebSocket-Accept的计算方法"></a>Sec-WebSocket-Accept的计算方法</h2><h3 id="从上面的分析中，我们知道字段的值是通过固定字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11加上请求中Sec-WebSocket-Key字段的值，然后再对其结果通过-SHA1-哈希算法求出的结果。可以通过以下-golang-代码实现："><a href="#从上面的分析中，我们知道字段的值是通过固定字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11加上请求中Sec-WebSocket-Key字段的值，然后再对其结果通过-SHA1-哈希算法求出的结果。可以通过以下-golang-代码实现：" class="headerlink" title="从上面的分析中，我们知道字段的值是通过固定字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11加上请求中Sec-WebSocket-Key字段的值，然后再对其结果通过 SHA1 哈希算法求出的结果。可以通过以下 golang 代码实现："></a>从上面的分析中，我们知道字段的值是通过固定字符串<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B1</code>1加上请求中<code>Sec-WebSocket-Key字</code>段的值，然后再对其结果通过 SHA1 哈希算法求出的结果。可以通过以下 golang 代码实现：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keyGUID = []<span class="keyword">byte</span>(<span class="string">"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">computeAcceptKey</span><span class="params">(challengeKey <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    h := sha1.New()</span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(challengeKey))</span><br><span class="line">    h.Write(keyGUID)</span><br><span class="line">    <span class="keyword">return</span> base64.StdEncoding.EncodeToString(h.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="掩码处理"><a href="#掩码处理" class="headerlink" title="掩码处理"></a>掩码处理</h2><h3 id="浏览器发送给服务器的数据帧是经过掩码处理的，那怎么样对数据进行解码呢？以下是来自RFC6455文档的解释"><a href="#浏览器发送给服务器的数据帧是经过掩码处理的，那怎么样对数据进行解码呢？以下是来自RFC6455文档的解释" class="headerlink" title="浏览器发送给服务器的数据帧是经过掩码处理的，那怎么样对数据进行解码呢？以下是来自RFC6455文档的解释"></a>浏览器发送给服务器的数据帧是经过掩码处理的，那怎么样对数据进行解码呢？以下是来自<code>RFC6455</code>文档的解释</h3><h3 id="具体的流程是：将传输的数据按字节-byte-处理，同时将-Masking-key-代表的值也按字节处理。假如-data-byte-i-代表的是数据的第-i-个字节，那么-j-i-MOD-4，然后从Maksing-key中-一共有-4-个字节）取出第-j-个字节-mask-key-byte-j，然后将-data-byte-i-和-mask-key-byte-j-代表的字节进行异或操作，取得结果就是最终的结果。该操作可以用如下-golang-代码实现："><a href="#具体的流程是：将传输的数据按字节-byte-处理，同时将-Masking-key-代表的值也按字节处理。假如-data-byte-i-代表的是数据的第-i-个字节，那么-j-i-MOD-4，然后从Maksing-key中-一共有-4-个字节）取出第-j-个字节-mask-key-byte-j，然后将-data-byte-i-和-mask-key-byte-j-代表的字节进行异或操作，取得结果就是最终的结果。该操作可以用如下-golang-代码实现：" class="headerlink" title="具体的流程是：将传输的数据按字节 byte 处理，同时将 Masking-key 代表的值也按字节处理。假如 data-byte-i 代表的是数据的第 i 个字节，那么 j = i MOD 4，然后从Maksing-key中(一共有 4 个字节）取出第 j 个字节 mask-key-byte-j，然后将 data-byte-i 和 mask-key-byte-j 代表的字节进行异或操作，取得结果就是最终的结果。该操作可以用如下 golang 代码实现："></a>具体的流程是：将传输的数据按字节 byte 处理，同时将 <code>Masking-key</code> 代表的值也按字节处理。假如 <code>data-byte-i</code> 代表的是数据的第 <code>i</code> 个字节，那么 <code>j = i MOD 4</code>，然后从<code>Maksing-key</code>中(一共有 4 个字节）取出第 j 个字节 <code>mask-key-byte-j</code>，然后将 d<code>ata-byte-i</code> 和 <code>mask-key-byte-j</code> 代表的字节进行异或操作，取得结果就是最终的结果。该操作可以用如下 golang 代码实现：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maskBytes</span><span class="params">(key [4]<span class="keyword">byte</span>,pos <span class="keyword">int</span>,b[]<span class="keyword">byte</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> b&#123;</span><br><span class="line">        b[i] ^= key[pos &amp; <span class="number">3</span>]</span><br><span class="line">        pos++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos &amp; <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意以上的操作，pos-amp-3这里代表的操作是pos-4-因为-a-2-n-等价于-a-amp-2-n-1-在这里使用按位与操作更加高效"><a href="#注意以上的操作，pos-amp-3这里代表的操作是pos-4-因为-a-2-n-等价于-a-amp-2-n-1-在这里使用按位与操作更加高效" class="headerlink" title="注意以上的操作，pos &amp; 3这里代表的操作是pos%4,因为 a % (2 ^ n) 等价于 a &amp; (2^n -1),在这里使用按位与操作更加高效"></a>注意以上的操作，<code>pos &amp; 3</code>这里代表的操作是pos%4,因为 a % (2 ^ n) 等价于 a &amp; (2^n -1),在这里使用按位与操作更加高效</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;websocket协议中的一些算法&quot;&gt;&lt;a href=&quot;#websocket协议中的一些算法&quot; class=&quot;headerlink&quot; title=&quot;websocket协议中的一些算法&quot;&gt;&lt;/a&gt;websocket协议中的一些算法&lt;/h2&gt;&lt;p&gt;在分析 WebSoc
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="2.应用层" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
      <category term="websocket" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/websocket/"/>
    
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="golang" scheme="http://blog.huido.site/tags/golang/"/>
    
      <category term="websocket" scheme="http://blog.huido.site/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>websocket实现</title>
    <link href="http://blog.huido.site/wiki/net-protocol/2.%E5%BA%94%E7%94%A8%E5%B1%82/websocket/3.websocket%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.huido.site/wiki/net-protocol/2.应用层/websocket/3.websocket实现/</id>
    <published>2019-10-21T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写基本的httpserver"><a href="#编写基本的httpserver" class="headerlink" title="编写基本的httpserver"></a>编写基本的httpserver</h2><h3 id="启动一个基本的httpserver，提供两个接口，一个index返回主页，另一个是就是我们自定义的websocket协议接口"><a href="#启动一个基本的httpserver，提供两个接口，一个index返回主页，另一个是就是我们自定义的websocket协议接口" class="headerlink" title="启动一个基本的httpserver，提供两个接口，一个index返回主页，另一个是就是我们自定义的websocket协议接口"></a>启动一个基本的httpserver，提供两个接口，一个<code>index</code>返回主页，另一个是就是我们自定义的<code>websocket</code>协议接口</h3><h3 id="main-go"><a href="#main-go" class="headerlink" title="@main.go"></a>@main.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/pkg/logging"</span></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/protocol/application/http"</span></span><br><span class="line"><span class="string">"github.com/brewlin/net-protocol/protocol/application/websocket"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">logging.Setup()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">serv := http.NewHTTP(<span class="string">"tap1"</span>, <span class="string">"192.168.1.0/24"</span>, <span class="string">"192.168.1.1"</span>, <span class="string">"9502"</span>)</span><br><span class="line">serv.HandleFunc(<span class="string">"/ws"</span>, echo)</span><br><span class="line"></span><br><span class="line">serv.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(request *http.Request, response *http.Response)</span></span> &#123;</span><br><span class="line">response.End(<span class="string">"hello"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">"@main: server is start ip:192.168.1.1 port:9502 "</span>)</span><br><span class="line">serv.ListenAndServ()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//websocket处理器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(r *http.Request, w *http.Response)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"got http request ; start to  upgrade websocket protocol...."</span>)</span><br><span class="line"><span class="comment">//协议升级 c *websocket.Conn</span></span><br><span class="line">c, err := websocket.Upgrade(r, w)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//升级协议失败，直接return 交由http处理响应</span></span><br><span class="line">fmt.Println(<span class="string">"Upgrade error:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"><span class="comment">//循环处理数据，接受数据，然后返回</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">message, err := c.ReadData()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">"read:"</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"recv client msg:"</span>, <span class="keyword">string</span>(message))</span><br><span class="line"><span class="comment">// c.SendData(message )</span></span><br><span class="line">c.SendData([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="echo-接口接受http请求并进行升级我们的websocket"><a href="#echo-接口接受http请求并进行升级我们的websocket" class="headerlink" title="echo 接口接受http请求并进行升级我们的websocket"></a>echo 接口接受http请求并进行升级我们的websocket</h3><h3 id="页面如下"><a href="#页面如下" class="headerlink" title="页面如下"></a>页面如下</h3><p><img src="/images/websocket.png" alt="index"></p><h2 id="自定义的webscoket-upgrade进行升级"><a href="#自定义的webscoket-upgrade进行升级" class="headerlink" title="自定义的webscoket upgrade进行升级"></a>自定义的webscoket upgrade进行升级</h2><h3 id="根据之前的协议分析，我知道握手的过程其实就是检查-HTTP-请求头部字段的过程，值得注意的一点就是需要针对客户端发送的-Sec-WebSocket-Key-生成一个正确的-Sec-WebSocket-Accept-只。关于生成的-Sec-WebSocket-Accpet-的实现，可以参考之前的分析。握手过程的具体代码如下："><a href="#根据之前的协议分析，我知道握手的过程其实就是检查-HTTP-请求头部字段的过程，值得注意的一点就是需要针对客户端发送的-Sec-WebSocket-Key-生成一个正确的-Sec-WebSocket-Accept-只。关于生成的-Sec-WebSocket-Accpet-的实现，可以参考之前的分析。握手过程的具体代码如下：" class="headerlink" title="根据之前的协议分析，我知道握手的过程其实就是检查 HTTP 请求头部字段的过程，值得注意的一点就是需要针对客户端发送的 Sec-WebSocket-Key 生成一个正确的 Sec-WebSocket-Accept 只。关于生成的 Sec-WebSocket-Accpet 的实现，可以参考之前的分析。握手过程的具体代码如下："></a>根据之前的协议分析，我知道握手的过程其实就是检查 HTTP 请求头部字段的过程，值得注意的一点就是需要针对客户端发送的 <code>Sec-WebSocket-Key</code> 生成一个正确的 <code>Sec-WebSocket-Accept</code> 只。关于生成的 <code>Sec-WebSocket-Accpet</code> 的实现，可以参考之前的分析。握手过程的具体代码如下：</h3><h3 id="upgrade-go"><a href="#upgrade-go" class="headerlink" title="@upgrade.go"></a>@upgrade.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> websocket</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upgrade</span><span class="params">(w http.ResponseWriter,r *http.Request)</span><span class="params">(c *Conn,err error)</span></span>&#123;</span><br><span class="line">    <span class="comment">//是否是Get方法</span></span><br><span class="line">    <span class="keyword">if</span> r.Method != <span class="string">"GET"</span> &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusMethodNotAllowed),http.StatusMethodNotAllowed)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:method not GET"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查 Sec-WebSocket-Version 版本</span></span><br><span class="line">    <span class="keyword">if</span> values := r.Header[<span class="string">"Sec-Websocket-Version"</span>];<span class="built_in">len</span>(values) == <span class="number">0</span> || values[<span class="number">0</span>] != <span class="string">"13"</span> &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:version != 13"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查Connection 和  Upgrade</span></span><br><span class="line">    <span class="keyword">if</span> !tokenListContainsValue(r.Header,<span class="string">"Connection"</span>,<span class="string">"upgrade"</span>) &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:could not find connection header with token 'upgrade'"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !tokenListContainsValue(r.Header,<span class="string">"Upgrade"</span>,<span class="string">"websocket"</span>) &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:could not find connection header with token 'websocket'"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算Sec-Websocket-Accept的值</span></span><br><span class="line">    challengeKey := r.Header.Get(<span class="string">"Sec-Websocket-Key"</span>)</span><br><span class="line">    <span class="keyword">if</span> challengeKey == <span class="string">""</span> &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusBadRequest),http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:key missing or blank"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        netConn net.Conn</span><br><span class="line">        br *bufio.Reader</span><br><span class="line">    )</span><br><span class="line">    h,ok := w.(http.Hijacker)</span><br><span class="line">    <span class="keyword">if</span>  !ok &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusInternalServerError),http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:response dose not implement http.Hijacker"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> rw *bufio.ReadWriter</span><br><span class="line">    <span class="comment">//接管当前tcp连接，阻止内置http接管连接</span></span><br><span class="line">    netConn,rw,err = h.Hijack()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w,http.StatusText(http.StatusInternalServerError),http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    br = rw.Reader</span><br><span class="line">    <span class="keyword">if</span> br.Buffered() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        netConn.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"websocket:client send data before hanshake is complete"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造握手成功后返回的 response</span></span><br><span class="line">    p := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">    p = <span class="built_in">append</span>(p, <span class="string">"HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: "</span>...)</span><br><span class="line">    p = <span class="built_in">append</span>(p, computeAcceptKey(challengeKey)...)</span><br><span class="line">    p = <span class="built_in">append</span>(p, <span class="string">"\r\n\r\n"</span>...)</span><br><span class="line">    <span class="comment">//返回repson 但不关闭连接</span></span><br><span class="line">    <span class="keyword">if</span> _,err = netConn.Write(p);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        netConn.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//升级为websocket</span></span><br><span class="line">    log.Println(<span class="string">"Upgrade http to websocket successfully"</span>)</span><br><span class="line">    conn := newConn(netConn)</span><br><span class="line">    <span class="keyword">return</span> conn,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="握手过程的代码比较直观，就不多做解释了。到这里-WebSocket-的实现就基本完成了，可以看到有了之前的各种约定，我们实现-WebSocket-协议也是比较简单的。"><a href="#握手过程的代码比较直观，就不多做解释了。到这里-WebSocket-的实现就基本完成了，可以看到有了之前的各种约定，我们实现-WebSocket-协议也是比较简单的。" class="headerlink" title="握手过程的代码比较直观，就不多做解释了。到这里 WebSocket 的实现就基本完成了，可以看到有了之前的各种约定，我们实现 WebSocket 协议也是比较简单的。"></a>握手过程的代码比较直观，就不多做解释了。到这里 WebSocket 的实现就基本完成了，可以看到有了之前的各种约定，我们实现 WebSocket 协议也是比较简单的。</h3><h2 id="封装的websocket结构体和对应的方法"><a href="#封装的websocket结构体和对应的方法" class="headerlink" title="封装的websocket结构体和对应的方法"></a>封装的websocket结构体和对应的方法</h2><h3 id="conn-go"><a href="#conn-go" class="headerlink" title="@conn.go"></a>@conn.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> websocket</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 是否是最后一个数据帧</span></span><br><span class="line"><span class="comment">    * Fin Rsv1 Rsv2 Rsv3 Opcode</span></span><br><span class="line"><span class="comment">    *  1  0    0    0    0 0 0 0  =&gt; 128</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    finalBit = <span class="number">1</span> &lt;&lt; <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 是否需要掩码处理</span></span><br><span class="line"><span class="comment">    *  Mask payload-len 第一位mask表示是否需要进行掩码处理 后面</span></span><br><span class="line"><span class="comment">    *  7位表示数据包长度 1.0-125 表示长度 2.126 后面需要扩展2 字节 16bit</span></span><br><span class="line"><span class="comment">    *  3.127则扩展8bit</span></span><br><span class="line"><span class="comment">    *  1    0 0 0 0 0 0 0  =&gt; 128</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    maskBit = <span class="number">1</span> &lt;&lt; <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 文本帧类型</span></span><br><span class="line"><span class="comment">    * 0 0 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TextMessage = <span class="number">1</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 关闭数据帧类型</span></span><br><span class="line"><span class="comment">    * 0 0 0 0 1 0 0 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    CloseMessage = <span class="number">8</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//websocket 连接</span></span><br><span class="line"><span class="keyword">type</span> Conn <span class="keyword">struct</span> &#123;</span><br><span class="line">    writeBuf []<span class="keyword">byte</span></span><br><span class="line">    maskKey [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">    conn net.Conn</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newConn</span><span class="params">(conn net.Conn)</span>*<span class="title">Conn</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Conn&#123;conn:conn&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span><span class="title">Close</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c.conn.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span><span class="title">SendData</span><span class="params">(data []<span class="keyword">byte</span>)</span></span>&#123;</span><br><span class="line">    length := <span class="built_in">len</span>(data)</span><br><span class="line">    c.writeBuf = <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">10</span> + length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据开始和结束位置</span></span><br><span class="line">    payloadStart := <span class="number">2</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *数据帧的第一个字节，不支持且只能发送文本类型数据</span></span><br><span class="line"><span class="comment">    *finalBit 1 0 0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">    *                |</span></span><br><span class="line"><span class="comment">    *Text     0 0 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">    * =&gt;      1 0 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    c.writeBuf[<span class="number">0</span>] = <span class="keyword">byte</span>(TextMessage) | finalBit</span><br><span class="line">    fmt.Printf(<span class="string">"1 bit:%b\n"</span>,c.writeBuf[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据帧第二个字节，服务器发送的数据不需要进行掩码处理</span></span><br><span class="line">    <span class="keyword">switch</span>&#123;</span><br><span class="line">    <span class="comment">//大于2字节的长度</span></span><br><span class="line">    <span class="keyword">case</span> length &gt;= <span class="number">1</span> &lt;&lt; <span class="number">16</span> :<span class="comment">//65536</span></span><br><span class="line">        <span class="comment">//c.writeBuf[1] = byte(0x00) | 127 // 127</span></span><br><span class="line">        c.writeBuf[<span class="number">1</span>] = <span class="keyword">byte</span>(<span class="number">127</span>) <span class="comment">// 127</span></span><br><span class="line">        <span class="comment">//大端写入64位</span></span><br><span class="line">        binary.BigEndian.PutUint64(c.writeBuf[payloadStart:],<span class="keyword">uint64</span>(length))</span><br><span class="line">        <span class="comment">//需要8byte来存储数据长度</span></span><br><span class="line">        payloadStart += <span class="number">8</span></span><br><span class="line">    <span class="keyword">case</span> length &gt; <span class="number">125</span>:</span><br><span class="line">        <span class="comment">//c.writeBuf[1] = byte(0x00) | 126</span></span><br><span class="line">        c.writeBuf[<span class="number">1</span>] = <span class="keyword">byte</span>(<span class="number">126</span>)</span><br><span class="line">        binary.BigEndian.PutUint16(c.writeBuf[payloadStart:],<span class="keyword">uint16</span>(length))</span><br><span class="line">        payloadStart += <span class="number">2</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//c.writeBuf[1] = byte(0x00) | byte(length)</span></span><br><span class="line">        c.writeBuf[<span class="number">1</span>] = <span class="keyword">byte</span>(length)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"2 bit:%b\n"</span>,c.writeBuf[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">copy</span>(c.writeBuf[payloadStart:],data[:])</span><br><span class="line">    c.conn.Write(c.writeBuf[:payloadStart+length])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span><span class="title">ReadData</span><span class="params">()</span><span class="params">(data []<span class="keyword">byte</span>,err error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b [<span class="number">8</span>]<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//读取数据帧的前两个字节</span></span><br><span class="line">    <span class="keyword">if</span> _,err := c.conn.Read(b[:<span class="number">2</span>]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始解析第一个字节 是否还有后续数据帧</span></span><br><span class="line">    final := b[<span class="number">0</span>] &amp; finalBit != <span class="number">0</span></span><br><span class="line">    fmt.Printf(<span class="string">"read data 1 bit :%b\n"</span>,b[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">//不支持数据分片</span></span><br><span class="line">    <span class="keyword">if</span> !final &#123;</span><br><span class="line">        log.Println(<span class="string">"Recived fragemented frame,not support"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"not suppeort fragmented message"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据帧类型</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *1 0 0 0  0 0 0 1</span></span><br><span class="line"><span class="comment">    *        &amp;</span></span><br><span class="line"><span class="comment">    *0 0 0 0  1 1 1 1</span></span><br><span class="line"><span class="comment">    *0 0 0 0  0 0 0 1</span></span><br><span class="line"><span class="comment">    * =&gt; 1 这样就可以直接获取到类型了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    frameType := <span class="keyword">int</span>(b[<span class="number">0</span>] &amp; <span class="number">0xf</span>)</span><br><span class="line">    <span class="comment">//如果 关闭类型，则关闭连接</span></span><br><span class="line">    <span class="keyword">if</span> frameType == CloseMessage &#123;</span><br><span class="line">        c.conn.Close()</span><br><span class="line">        log.Println(<span class="string">"Recived closed message,connection will be closed"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"recived closed message"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只实现了文本格式的传输,编码utf-8</span></span><br><span class="line">    <span class="keyword">if</span> frameType != TextMessage &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"only support text message"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查数据帧是否被掩码处理</span></span><br><span class="line">    <span class="comment">//maskBit =&gt; 1 0 0 0 0 0 0 0 任何与他 要么为0 要么为 128</span></span><br><span class="line">    mask := b[<span class="number">1</span>] &amp; maskBit != <span class="number">0</span></span><br><span class="line">    <span class="comment">//数据长度</span></span><br><span class="line">    payloadLen := <span class="keyword">int64</span>(b[<span class="number">1</span>] &amp; <span class="number">0x7F</span>)<span class="comment">//0 1 1 1 1 1 1 1 1 127</span></span><br><span class="line">    dataLen := <span class="keyword">int64</span>(payloadLen)</span><br><span class="line">    <span class="comment">//根据payload length 判断数据的真实长度</span></span><br><span class="line">    <span class="keyword">switch</span> payloadLen &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">126</span>:<span class="comment">//扩展2字节</span></span><br><span class="line">        <span class="keyword">if</span> _,err := c.conn.Read(b[:<span class="number">2</span>]);err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取扩展二字节的真实数据长度</span></span><br><span class="line">        dataLen = <span class="keyword">int64</span>(binary.BigEndian.Uint16(b[:<span class="number">2</span>]))</span><br><span class="line">    <span class="keyword">case</span> <span class="number">127</span> :</span><br><span class="line">        <span class="keyword">if</span> _,err := c.conn.Read(b[:<span class="number">8</span>]);err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">        &#125;</span><br><span class="line">        dataLen = <span class="keyword">int64</span>(binary.BigEndian.Uint64(b[:<span class="number">8</span>]))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">"Read data length :%d,payload length %d"</span>,payloadLen,dataLen)</span><br><span class="line">    <span class="comment">//读取mask key</span></span><br><span class="line">    <span class="keyword">if</span> mask &#123;<span class="comment">//如果需要掩码处理的话 需要取出key</span></span><br><span class="line">        <span class="comment">//maskKey 是 4 字节  32位</span></span><br><span class="line">        <span class="keyword">if</span> _,err := c.conn.Read(c.maskKey[:]);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> ,err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取数据内容</span></span><br><span class="line">    p := <span class="built_in">make</span>([]<span class="keyword">byte</span>,dataLen)</span><br><span class="line">    <span class="keyword">if</span> _,err := c.conn.Read(p);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mask &#123;</span><br><span class="line">        maskBytes(c.maskKey,p)<span class="comment">//进行解码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="http-头部检查"><a href="#http-头部检查" class="headerlink" title="http 头部检查"></a>http 头部检查</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/sha1"</span></span><br><span class="line">    <span class="string">"encoding/base64"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> KeyGUID = []<span class="keyword">byte</span>(<span class="string">"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</span>)</span><br><span class="line"><span class="comment">//握手阶段使用 加密key返回 进行握手</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">computeAcceptKey</span><span class="params">(challengeKey <span class="keyword">string</span>)</span><span class="title">string</span></span>&#123;</span><br><span class="line">    h := sha1.New()</span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(challengeKey))</span><br><span class="line">    h.Write(KeyGUID)</span><br><span class="line">    <span class="keyword">return</span> base64.StdEncoding.EncodeToString(h.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maskBytes</span><span class="params">(key [4]<span class="keyword">byte</span>,b []<span class="keyword">byte</span>)</span></span>&#123;</span><br><span class="line">    pos := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> b &#123;</span><br><span class="line">        b[i] ^= key[pos &amp; <span class="number">3</span>]</span><br><span class="line">        pos ++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查http 头部字段中是否包含指定的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tokenListContainsValue</span><span class="params">(header http.Header, name <span class="keyword">string</span>, value <span class="keyword">string</span>)</span><span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> header[name] &#123;</span><br><span class="line">        <span class="keyword">for</span> _, s := <span class="keyword">range</span> strings.Split(v,<span class="string">","</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> strings.EqualFold(value,strings.TrimSpace(s)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编写基本的httpserver&quot;&gt;&lt;a href=&quot;#编写基本的httpserver&quot; class=&quot;headerlink&quot; title=&quot;编写基本的httpserver&quot;&gt;&lt;/a&gt;编写基本的httpserver&lt;/h2&gt;&lt;h3 id=&quot;启动一个基本的httpse
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="2.应用层" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
      <category term="websocket" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/websocket/"/>
    
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="golang" scheme="http://blog.huido.site/tags/golang/"/>
    
      <category term="websocket" scheme="http://blog.huido.site/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>websocket协议解析</title>
    <link href="http://blog.huido.site/wiki/net-protocol/2.%E5%BA%94%E7%94%A8%E5%B1%82/websocket/1.websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.huido.site/wiki/net-protocol/2.应用层/websocket/1.websocket协议解析/</id>
    <published>2019-10-21T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="websocket-协议报文"><a href="#websocket-协议报文" class="headerlink" title="websocket 协议报文"></a>websocket 协议报文</h2><p>websocket协议也是基于<code>tcp协议</code>，和http不同的是，tcp接受的数据包为<code>二进制帧</code>，而http为<code>字符串数据包</code>。并且websocket协议在连接阶段会触发一个<code>http请求</code>进行websocket协议校验。校验成功后才会接管tcp通讯流程不会断开该http连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">websocket 数据帧报文</span><br><span class="line"></span><br><span class="line">  0               1               2               3               4</span><br><span class="line">  0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8</span><br><span class="line">  +-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">  |F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">  |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">  |N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">  | |1|2|3|       |K|             |                               |</span><br><span class="line">  +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">  |     Extended payload length continued, if payload len == 127  |</span><br><span class="line">  + - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">  |                               |Masking-key, if MASK set to 1  |</span><br><span class="line">  +-------------------------------+-------------------------------+</span><br><span class="line">  | Masking-key (continued)       |          Payload Data         |</span><br><span class="line">  +-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">  :                     Payload Data continued ...                :</span><br><span class="line">  + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">  |                     Payload Data continued ...                |</span><br><span class="line">  +---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h2 id="WebSocket协议详解"><a href="#WebSocket协议详解" class="headerlink" title="WebSocket协议详解"></a>WebSocket协议详解</h2><p>WebSocket 协议解决了浏览器和服务器之间的全双工通信问题。在 WebSocket 出现之前，浏览器如果需要从服务器及时获得更新，则需要不停的对服务器主动发起请求，也就是 Web 中常用的poll技术。这样的操作非常低效，这是因为每发起一次新的 HTTP 请求，就需要单独开启一个新的 TCP 链接，同时 HTTP 协议本身也是一种开销非常大的协议。为了解决这些问题，所以出现了 WebSocket 协议。WebSocket 使得浏览器和服务器之间能通过一个持久的 TCP 链接就能完成数据的双向通信。关于 WebSocket 的 RFC 提案，可以参看RFC6455。</p><p>WebSocket 和 HTTP 协议一般情况下都工作在浏览器中，但 WebSocket 是一种完全不同于 HTTP 的协议。尽管，浏览器需要通过 HTTP 协议的GET请求，将 HTTP 协议升级为 WebSocket 协议。升级的过程被称为握手(handshake)。当浏览器和服务器成功握手后，则可以开始根据 WebSocket 定义的通信帧格式开始通信了。像其他各种协议一样，WebSocket 协议的通信帧也分为控制数据帧和普通数据帧，前者用于控制 WebSocket 链接状态，后者用于承载数据。下面我们将一一分析 WebSocket 协议的握手过程以及通信帧格式。</p><h2 id="一、websocket握手"><a href="#一、websocket握手" class="headerlink" title="一、websocket握手"></a>一、websocket握手</h2><h3 id="握手的过程也就是将HTTP协议升级为WebSocket协议的过程，握手开始首先由浏览器端发送一个GET请求，该请求的HTTP头部信息如下"><a href="#握手的过程也就是将HTTP协议升级为WebSocket协议的过程，握手开始首先由浏览器端发送一个GET请求，该请求的HTTP头部信息如下" class="headerlink" title="握手的过程也就是将HTTP协议升级为WebSocket协议的过程，握手开始首先由浏览器端发送一个GET请求，该请求的HTTP头部信息如下:"></a>握手的过程也就是将HTTP协议升级为WebSocket协议的过程，握手开始首先由浏览器端发送一个<code>GET</code>请求，该请求的HTTP头部信息如下:</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Origin</span>: http://example.com</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protcol</span>: chat, superchat</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</span><br></pre></td></tr></table></figure><h3 id="当服务器端，成功验证了以上信息后，则会返回一个形如以下的响应："><a href="#当服务器端，成功验证了以上信息后，则会返回一个形如以下的响应：" class="headerlink" title="当服务器端，成功验证了以上信息后，则会返回一个形如以下的响应："></a>当服务器端，成功验证了以上信息后，则会返回一个形如以下的响应：</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span>: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat</span><br></pre></td></tr></table></figure><h3 id="可以看到，浏览器发送端HTTP请求中，增加了一些新端字段，其作用如下所示："><a href="#可以看到，浏览器发送端HTTP请求中，增加了一些新端字段，其作用如下所示：" class="headerlink" title="可以看到，浏览器发送端HTTP请求中，增加了一些新端字段，其作用如下所示："></a>可以看到，浏览器发送端HTTP请求中，增加了一些新端字段，其作用如下所示：</h3><ul><li><code>Upgrade</code>: 规定必需的字段，其值必需为 <code>websocket</code>, 如果不是则握手失败；</li><li><code>Connection</code>: 规定必需的字段，值必需为 <code>Upgrade</code>, 如果不是则握手失败；<br><code>Sec-WebSocket-Key</code>: 必需字段，一个随机的字符串；<br><code>Sec-WebSocket-Protocol</code>: 可选字段，可以用于标识应用层的协议；<br><code>Sec-WebSocket-Version</code>: 必需字段，代表了 WebSocket 协议版本，值必需是 <code>13</code>, 否则握手失败；<h3 id="返回端响应中，如果握手成功会返回状态码101的HTTP响应，同时其他字段说明如下："><a href="#返回端响应中，如果握手成功会返回状态码101的HTTP响应，同时其他字段说明如下：" class="headerlink" title="返回端响应中，如果握手成功会返回状态码101的HTTP响应，同时其他字段说明如下："></a>返回端响应中，如果握手成功会返回状态码<code>101</code>的HTTP响应，同时其他字段说明如下：</h3></li><li><code>Upgrade</code>: 规定必需的字段，其值必需为 <code>websocket</code>, 如果不是则握手失败；</li><li><code>Connection</code>: 规定必需的字段，值必需为 <code>Upgrade</code>, 如果不是则握手失败；</li><li><code>Sec-WebSocket-Accept</code>: 规定必需的字段，该字段的值是通过固定字符串<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>加上请求中<code>Sec-WebSocket-Key</code>字段的值，然后再对其结果通过 <code>SHA1</code> 哈希算法求出的结果。</li><li><code>Sec-WebSocket-Protocol</code>: 对应于请求中的 <code>Sec-WebSocket-Protocol</code> 字段；<h3 id="当浏览器和服务端成功握手后，就可以传递数据了，传送数据是按照WebSocket的数据格式生成的"><a href="#当浏览器和服务端成功握手后，就可以传递数据了，传送数据是按照WebSocket的数据格式生成的" class="headerlink" title="当浏览器和服务端成功握手后，就可以传递数据了，传送数据是按照WebSocket的数据格式生成的"></a>当浏览器和服务端成功握手后，就可以传递数据了，传送数据是按照WebSocket的数据格式生成的</h3><h2 id="二、WebSocket协议数据帧"><a href="#二、WebSocket协议数据帧" class="headerlink" title="二、WebSocket协议数据帧"></a>二、WebSocket协议数据帧</h2><h3 id="数据帧的定义类似与TCP-IP的格式定义，具体看下图："><a href="#数据帧的定义类似与TCP-IP的格式定义，具体看下图：" class="headerlink" title="数据帧的定义类似与TCP/IP的格式定义，具体看下图："></a>数据帧的定义类似与TCP/IP的格式定义，具体看下图：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure></li></ul><h3 id="以上这张图，一行代表32bit（位），也就是4bytes（字节），总体上包含两份，帧头部和数据内容。每个从WebSocket链接中接受到的数据帧，都要按照以上格式进行解析，这样才能知道该数据帧是用于控制的还是用于传送数据的，关于以上数据帧的各个比特位的解释如下："><a href="#以上这张图，一行代表32bit（位），也就是4bytes（字节），总体上包含两份，帧头部和数据内容。每个从WebSocket链接中接受到的数据帧，都要按照以上格式进行解析，这样才能知道该数据帧是用于控制的还是用于传送数据的，关于以上数据帧的各个比特位的解释如下：" class="headerlink" title="以上这张图，一行代表32bit（位），也就是4bytes（字节），总体上包含两份，帧头部和数据内容。每个从WebSocket链接中接受到的数据帧，都要按照以上格式进行解析，这样才能知道该数据帧是用于控制的还是用于传送数据的，关于以上数据帧的各个比特位的解释如下："></a>以上这张图，一行代表32bit（位），也就是4bytes（字节），总体上包含两份，帧头部和数据内容。每个从WebSocket链接中接受到的数据帧，都要按照以上格式进行解析，这样才能知道该数据帧是用于控制的还是用于传送数据的，关于以上数据帧的各个比特位的解释如下：</h3><ul><li><code>FIN</code>:1bit,当该比特位值为%x0时，表示后面还有更多的数据帧，%x1时表示这是最后一个数据帧；</li><li><code>RSV1</code>,<code>RSV2</code>,<code>RSV3</code>:各占1个比特位。一般情况下全为0，当客户端、服务端协商采用WebSocket扩展时，这三个标识位可以非0，且值当含义由扩展进行定义，如果出现非0当值，且没有采用WebSocket扩展，则链接出错</li><li><code>opcode</code>:4 bit,用于表明数据帧当类型，一共可以表示16种帧类型，如下所示：<ul><li>%x0:表示这是一个分片当帧，它属于前面帧当后续帧；</li><li>%x1:表示该数据帧携带的数据类型是文本类型，且编码utf-8</li><li>%x2 : 表示携带的是二进制数据；</li><li>%x3-7 : 保留未使用；</li><li>%x8 : 表示该帧用于关闭 WebSocket 链接；</li><li>%x9 : 表示该帧代表了 ping 操作；</li><li>%xA : 表示该帧代表了 pong 回应；</li><li>%xB-F : 保留未使用；</li></ul></li><li><code>MASK</code>:1 bit,%x0表示数据帧没有经过掩码计算，而%x1则表示数据帧已经经过掩码计算，得到真正当数据需要解码，一般情况下，只有浏览器发送给服务端当数据帧才需要进行掩码计算；</li><li><code>Payload len</code>:7 bit,表示了数据帧携带当数据长度，7 bit 的值根据三种情况，帧的解析有所不同：<ul><li>%x0 - 7D : 也就是从 0 到 125，表示数据长度, 数据总长度也就是 7 bit 代表的长度；</li><li>%x7E : 7 bit 的值是 126 时，则后续的 2 个字节（16 bit)表示的一个 16 位无符号数，这个数用来表示数据的长度；</li><li>%x7F : 7 bit 的值是 127 时，则后续的 8 个字节（64 bit)表示的一个 64 位无符号数，这个数用来表示数据的长度；<ul><li><code>Masking-key</code>: 32 bit, 表示了用于解码的 key，只有当 MASK 比特位的值为 %x1 是，才有该数据；   </li></ul></li></ul></li><li><code>Payload Data</code>: 余下的比特位用于存储具体的数据；<h3 id="通过以上分析可以看出，WebSocket-协议数据帧的最大头部为-2-8-4-14-bytes-也就是-14-个字节。同时我们要实现-WebSocket-协议，最主要的工作就是实现对数据帧的解析。"><a href="#通过以上分析可以看出，WebSocket-协议数据帧的最大头部为-2-8-4-14-bytes-也就是-14-个字节。同时我们要实现-WebSocket-协议，最主要的工作就是实现对数据帧的解析。" class="headerlink" title="通过以上分析可以看出，WebSocket 协议数据帧的最大头部为 2 + 8 + 4 = 14 bytes 也就是 14 个字节。同时我们要实现 WebSocket 协议，最主要的工作就是实现对数据帧的解析。"></a>通过以上分析可以看出，WebSocket 协议数据帧的最大头部为 2 + 8 + 4 = 14 bytes 也就是 14 个字节。同时我们要实现 WebSocket 协议，最主要的工作就是实现对数据帧的解析。</h3></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;websocket-协议报文&quot;&gt;&lt;a href=&quot;#websocket-协议报文&quot; class=&quot;headerlink&quot; title=&quot;websocket 协议报文&quot;&gt;&lt;/a&gt;websocket 协议报文&lt;/h2&gt;&lt;p&gt;websocket协议也是基于&lt;code&gt;t
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="2.应用层" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
      <category term="websocket" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/websocket/"/>
    
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="golang" scheme="http://blog.huido.site/tags/golang/"/>
    
      <category term="websocket" scheme="http://blog.huido.site/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>http协议解析</title>
    <link href="http://blog.huido.site/wiki/net-protocol/2.%E5%BA%94%E7%94%A8%E5%B1%82/http/1.http%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.huido.site/wiki/net-protocol/2.应用层/http/1.http协议解析/</id>
    <published>2019-10-18T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http协议报文"><a href="#http协议报文" class="headerlink" title="http协议报文"></a>http协议报文</h2><p>这是一个典型的http请求的报文样例，可以看出是一个websocket升级前的http请求。该字符报文完全基于<code>tcp协议</code>，协议报文内容为<code>tcp数据包</code>，也就是<code>tcp</code>进行<code>recv</code>调用获取的数据内容。如下报文表示已经接受完http报文数据。</p><p>解析http报文的源码为<code>application/http/request.go</code>中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http 协议报文</span><br><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protcol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure></p><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="@请求方法"></a>@请求方法</h3><p>解析tcp数据包第一行数据，遇到<code></code>空格就拆分，则获取到请求方法</p><h3 id="uri"><a href="#uri" class="headerlink" title="@uri"></a>@uri</h3><p>解析tcp数据包第一行数据，遇到<code></code>空格就拆分，则获取到uri路径</p><h3 id="header头部"><a href="#header头部" class="headerlink" title="@header头部"></a>@header头部</h3><p>接下来都是一些头部信息的keyvalue，每次读取一行，然后根据:分隔符进行拆分，获取header头部请求键值对</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;http协议报文&quot;&gt;&lt;a href=&quot;#http协议报文&quot; class=&quot;headerlink&quot; title=&quot;http协议报文&quot;&gt;&lt;/a&gt;http协议报文&lt;/h2&gt;&lt;p&gt;这是一个典型的http请求的报文样例，可以看出是一个websocket升级前的http请求。
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="2.应用层" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
      <category term="http" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/http/"/>
    
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
      <category term="golang" scheme="http://blog.huido.site/tags/golang/"/>
    
      <category term="http" scheme="http://blog.huido.site/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>应用层前世今生</title>
    <link href="http://blog.huido.site/wiki/net-protocol/2.%E5%BA%94%E7%94%A8%E5%B1%82/%E5%BA%94%E7%94%A8%E5%B1%82%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://blog.huido.site/wiki/net-protocol/2.应用层/应用层前世今生/</id>
    <published>2019-10-17T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用层的作用"><a href="#应用层的作用" class="headerlink" title="应用层的作用"></a>应用层的作用</h2><p>对传输层协议对再次封装，例如对tcp进行封装对http、websocket协议等，以及http3协议基于udp协议的封装等</p><h2 id="http协议报文"><a href="#http协议报文" class="headerlink" title="http协议报文"></a>http协议报文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http 协议报文</span><br><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protcol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure><h2 id="websocket-协议报文"><a href="#websocket-协议报文" class="headerlink" title="websocket 协议报文"></a>websocket 协议报文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">websocket 数据帧报文</span><br><span class="line"></span><br><span class="line">  0               1               2               3               4</span><br><span class="line">  0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8</span><br><span class="line">  +-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">  |F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">  |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">  |N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">  | |1|2|3|       |K|             |                               |</span><br><span class="line">  +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">  |     Extended payload length continued, if payload len == 127  |</span><br><span class="line">  + - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">  |                               |Masking-key, if MASK set to 1  |</span><br><span class="line">  +-------------------------------+-------------------------------+</span><br><span class="line">  | Masking-key (continued)       |          Payload Data         |</span><br><span class="line">  +-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">  :                     Payload Data continued ...                :</span><br><span class="line">  + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">  |                     Payload Data continued ...                |</span><br><span class="line">  +---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;应用层的作用&quot;&gt;&lt;a href=&quot;#应用层的作用&quot; class=&quot;headerlink&quot; title=&quot;应用层的作用&quot;&gt;&lt;/a&gt;应用层的作用&lt;/h2&gt;&lt;p&gt;对传输层协议对再次封装，例如对tcp进行封装对http、websocket协议等，以及http3协议基于ud
      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="2.应用层" scheme="http://blog.huido.site/categories/net-protocol/2-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="protocol" scheme="http://blog.huido.site/tags/protocol/"/>
    
  </entry>
  
  <entry>
    <title>快速开始</title>
    <link href="http://blog.huido.site/wiki/net-protocol/1.%E5%89%8D%E8%A8%80/1.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/"/>
    <id>http://blog.huido.site/wiki/net-protocol/1.前言/1.快速开始/</id>
    <published>2019-10-16T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="demo案例"><a href="#demo案例" class="headerlink" title="demo案例"></a>demo案例</h2><p><code>cmd</code>:该目录下为各协议的实现demo，提供api调用实现以及测试</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;demo案例&quot;&gt;&lt;a href=&quot;#demo案例&quot; class=&quot;headerlink&quot; title=&quot;demo案例&quot;&gt;&lt;/a&gt;demo案例&lt;/h2&gt;&lt;p&gt;&lt;code&gt;cmd&lt;/code&gt;:该目录下为各协议的实现demo，提供api调用实现以及测试&lt;/p&gt;

      
    
    </summary>
    
      <category term="net-protocol" scheme="http://blog.huido.site/categories/net-protocol/"/>
    
      <category term="1.前言" scheme="http://blog.huido.site/categories/net-protocol/1-%E5%89%8D%E8%A8%80/"/>
    
    
      <category term="Go" scheme="http://blog.huido.site/tags/Go/"/>
    
      <category term="Protocol" scheme="http://blog.huido.site/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>相关资料</title>
    <link href="http://blog.huido.site/wiki/go-stl/raft/%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/"/>
    <id>http://blog.huido.site/wiki/go-stl/raft/相关资料/</id>
    <published>2017-10-26T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="动画演示-raft-协议"><a href="#动画演示-raft-协议" class="headerlink" title="动画演示 raft 协议"></a>动画演示 raft 协议</h2><p><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p><h2 id="raft-比较好的blog"><a href="#raft-比较好的blog" class="headerlink" title="raft 比较好的blog"></a>raft 比较好的blog</h2><p><a href="http://oserror.com/distributed/implement-raft-with-golang-first/">http://oserror.com/distributed/implement-raft-with-golang-first/</a></p><p><a href="http://blog.luoyuanhang.com/2017/02/02/raft-paper-in-zh-CN/">http://blog.luoyuanhang.com/2017/02/02/raft-paper-in-zh-CN/</a></p><h2 id="相关原版英语论文"><a href="#相关原版英语论文" class="headerlink" title="相关原版英语论文"></a>相关原版英语论文</h2><p><a href="http://people.csail.mit.edu/cowling/vr/vr-revisited.pdf">http://people.csail.mit.edu/cowling/vr/vr-revisited.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;h2 id=&quot;动画演示-raft-协议&quot;&gt;&lt;a href=&quot;#动画演示-raft-协议&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="go-stl" scheme="http://blog.huido.site/categories/go-stl/"/>
    
      <category term="raft" scheme="http://blog.huido.site/categories/go-stl/raft/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="algorithm" scheme="http://blog.huido.site/tags/algorithm/"/>
    
      <category term="raft" scheme="http://blog.huido.site/tags/raft/"/>
    
  </entry>
  
  <entry>
    <title>raft分布式一致性原理(二)</title>
    <link href="http://blog.huido.site/wiki/go-stl/raft/raft%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86(%E4%BA%8C)/"/>
    <id>http://blog.huido.site/wiki/go-stl/raft/raft分布式一致性原理(二)/</id>
    <published>2017-10-26T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-选举"><a href="#1-选举" class="headerlink" title="@1 选举"></a>@1 选举</h2><p>此阶段为集群初始化，所有的节点都是<code>FOLLOWER</code>身份</p><ol><li>进行事件循环 </li></ol><h3 id="fllower-身份"><a href="#fllower-身份" class="headerlink" title="@fllower 身份"></a>@fllower 身份</h3><ol><li>接受主节点心跳</li><li>接受投票选举</li><li>如果在超时时间里还没有处触发上面两个<code>事件</code> 则转换为 <code>CANDIDATE</code> 候选身份，作为新的候选人进行选举</li></ol><h3 id="candidate-身份"><a href="#candidate-身份" class="headerlink" title="@candidate 身份"></a>@candidate 身份</h3><ol><li>开始选举，增加当前任期 term</li><li>投票给自己</li><li>广播rpc向所有节点发起选举投票<ul><li>当前任期<code>小于</code>其他节点则转换为fllower节点等待心跳到来或者超时</li><li>当前依然为candidate 且 收到的投票大于 总结点<code>1/2</code> 则准换为 leader节点结束选举</li></ul></li><li>监听广播的投票结果<ul><li><code>收到心跳</code> 说明选举失败退化为follwer节点</li><li><code>选举成功为leader</code> 结束选举<h3 id="leader-身份"><a href="#leader-身份" class="headerlink" title="@leader 身份"></a>@leader 身份</h3></li></ul></li><li>广播所有节点心跳 和日志复制</li><li>睡眠等待下一次心跳发送</li></ol><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><table><thead><tr><th>性质</th><th>描述</th></tr></thead><tbody><tr><td>选举安全原则（Election Safety）</td><td>一个任期（term）内最多允许有一个领导人被选上</td></tr><tr><td>领导人只增加原则（Leader Append-Only）</td><td>领导人永远不会覆盖或者删除自己的日志，它只会增加条目</td></tr><tr><td>日志匹配原则（Log Matching）</td><td>如果两个日志在相同的索引位置上的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间的条目完全相同</td></tr><tr><td>领导人完全原则（Leader Completeness)</td><td>如果一个日志条目在一个给定任期内被提交，那么这个条目一定会出现在所有任期号更大的领导人中</td></tr><tr><td>状态机安全原则（State Machine Safety）</td><td>如果一个服务器已经将给定索引位置的日志条目应用到状态机中，则所有其他服务器不会在该索引位置应用不同的条目</td></tr></tbody></table><h2 id="2日志复制"><a href="#2日志复制" class="headerlink" title="@2日志复制"></a>@2日志复制</h2><p>只有当该日志同步到所有node才可以进行提交<code>commited</code> 到状态机<code>state machine</code></p><h3 id="状态机"><a href="#状态机" class="headerlink" title="@状态机"></a>@状态机</h3><p>其实就是实际进行操作的区域，如果该服务是数据库，那么状态机就是实际执行命令储存的地方</p><p>当收到所有的节点回复可以提交到状态机后，然后leader节点进行提交，提交后在广播到其他节点，通知其他节点可以提交日志到状态机执行命令</p><p>到这里就算是成功提交了一条命令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-选举&quot;&gt;&lt;a href=&quot;#1-选举&quot; class=&quot;headerlink&quot; title=&quot;@1 选举&quot;&gt;&lt;/a&gt;@1 选举&lt;/h2&gt;&lt;p&gt;此阶段为集群初始化，所有的节点都是&lt;code&gt;FOLLOWER&lt;/code&gt;身份&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进行事件循环
      
    
    </summary>
    
      <category term="go-stl" scheme="http://blog.huido.site/categories/go-stl/"/>
    
      <category term="raft" scheme="http://blog.huido.site/categories/go-stl/raft/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="algorithm" scheme="http://blog.huido.site/tags/algorithm/"/>
    
      <category term="raft" scheme="http://blog.huido.site/tags/raft/"/>
    
  </entry>
  
  <entry>
    <title>raft分布式一致性原理(一)</title>
    <link href="http://blog.huido.site/wiki/go-stl/raft/raft%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86(%E4%B8%80)/"/>
    <id>http://blog.huido.site/wiki/go-stl/raft/raft分布式一致性原理(一)/</id>
    <published>2017-10-26T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="raft分布式一致性原理"><a href="#raft分布式一致性原理" class="headerlink" title="raft分布式一致性原理"></a>raft分布式一致性原理</h1><h2 id="无限循环选leader异常"><a href="#无限循环选leader异常" class="headerlink" title="无限循环选leader异常"></a>无限循环选leader异常</h2><p>当启动所有server时，默认都是<code>follower</code> 此时没有leader角色，然后follower会转换成<code>candidate</code> 身份进行选取<code>leader</code></p><h3 id="选取leader失败导致的重复选取"><a href="#选取leader失败导致的重复选取" class="headerlink" title="@选取leader失败导致的重复选取"></a>@选取leader失败导致的重复选取</h3><p>当所有的follower 都转换为candidate身份进行leader选举时，可能导致选取leader失败，那么会更新选举时间，进行下一次重新选举</p><p><code>此时就可能导致无限次选举</code></p><h3 id="随机定时器"><a href="#随机定时器" class="headerlink" title="@随机定时器"></a>@随机定时器</h3><p>其实就是采用 <code>150ms - 300ms</code>之间 随机产生一个定时时间，此时默认同一时刻基本只有一个server会转换为candidate身份，解决了单次无法选举出leader的问题</p><h3 id="选举leader-限制"><a href="#选举leader-限制" class="headerlink" title="@选举leader 限制"></a>@选举leader 限制</h3><p>候选人进行选举leader时发起并行请求投票 RPC 实现了这样的限制： <code>RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求</code>。</p><p>总的来说 就是过滤掉那些日志比较落后的候选人节点</p><p>Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，<code>那么日志比较长的那个就更加新。</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;raft分布式一致性原理&quot;&gt;&lt;a href=&quot;#raft分布式一致性原理&quot; class=&quot;headerlink&quot; title=&quot;raft分布式一致性原理&quot;&gt;&lt;/a&gt;raft分布式一致性原理&lt;/h1&gt;&lt;h2 id=&quot;无限循环选leader异常&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="go-stl" scheme="http://blog.huido.site/categories/go-stl/"/>
    
      <category term="raft" scheme="http://blog.huido.site/categories/go-stl/raft/"/>
    
    
      <category term="go" scheme="http://blog.huido.site/tags/go/"/>
    
      <category term="algorithm" scheme="http://blog.huido.site/tags/algorithm/"/>
    
      <category term="raft" scheme="http://blog.huido.site/tags/raft/"/>
    
  </entry>
  
  <entry>
    <title>并发压测对比</title>
    <link href="http://blog.huido.site/wiki/im-cloud/1.%E5%89%8D%E8%A8%80/2.%E5%B9%B6%E5%8F%91%E5%8E%8B%E6%B5%8B%E5%AF%B9%E6%AF%94/"/>
    <id>http://blog.huido.site/wiki/im-cloud/1.前言/2.并发压测对比/</id>
    <published>2017-10-25T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="im-cloud-lt-gt-goim-分布式中间件并发压测对比"><a href="#im-cloud-lt-gt-goim-分布式中间件并发压测对比" class="headerlink" title="im-cloud &lt;&gt; goim 分布式中间件并发压测对比"></a>im-cloud &lt;&gt; goim 分布式中间件并发压测对比</h1><h1 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h1><blockquote><p>此次测试环境为 window8.1 启动 virtualbox虚拟机部署的ubuntu14</p><ul><li>goim无需担心进程配置，im-cloud测试时候需要根据机器配置做更改<code>worker进程和task进程最好和cpu核心数</code>保持一致，太大会使性能大大降低</li></ul></blockquote><h2 id="测评对象-goim-im-cloud"><a href="#测评对象-goim-im-cloud" class="headerlink" title="测评对象  goim im-cloud"></a>测评对象  <code>goim</code> <code>im-cloud</code></h2><ul><li>goim (bilibili出品，经过B站生产验证 <code>百万级消息秒级推</code>送)</li><li>im-cloud（借鉴goim 使用swoole原生实现  经过自己验证。。。）<h2 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU: 4 核cpu</span><br><span class="line">MEM: 2G 内存 </span><br><span class="line">System: Ubunutu 14.04 (64bit)</span><br></pre></td></tr></table></figure></li></ul><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">单节点启动</span><br><span class="line">im-cloud: </span><br><span class="line">    cloud(2 个worker进程               2个子进程) </span><br><span class="line">    job(  2 个worker进程   2个task进程 1个子进程)  </span><br><span class="line">    logic(2个worker进程  2个task进程   1个子进程)</span><br><span class="line">goim    : </span><br><span class="line">    comet(单进程)</span><br><span class="line">    job(单进程)</span><br><span class="line">    logic(单进程)</span><br></pre></td></tr></table></figure><h2 id="评测结果"><a href="#评测结果" class="headerlink" title="评测结果"></a>评测结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c : concurrent 并发请求</span><br><span class="line">n : number     总请求数</span><br><span class="line">-----------------------------------</span><br><span class="line">c:500   |  n:2000 | n:5000 | n:20000</span><br><span class="line">im-cloud:  6300     6082     3815</span><br><span class="line">goim    :  5377     5540     5894  </span><br><span class="line">-----------------------------------</span><br><span class="line">c:1000   |  n:20000</span><br><span class="line">im-cloud:   5014</span><br><span class="line">goim    :   5950   </span><br><span class="line">-----------------------------------</span><br></pre></td></tr></table></figure><h2 id="Concurrent-500-Number-2000"><a href="#Concurrent-500-Number-2000" class="headerlink" title="@Concurrent:500 @Number:2000"></a>@Concurrent:500 @Number:2000</h2><blockquote><p><code>im-cloud</code> 整体高达6300qps <code>goim</code> 整体高达 5300qps</p></blockquote><h3 id="im-cloud"><a href="#im-cloud" class="headerlink" title="im-cloud"></a>im-cloud</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        swoole-http-server</span><br><span class="line">Server Hostname:        127.0.0.1</span><br><span class="line">Server Port:            9600</span><br><span class="line"></span><br><span class="line">Concurrency Level:      500</span><br><span class="line">Time taken for tests:   0.321 seconds</span><br><span class="line">Complete requests:      2000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      354000 bytes</span><br><span class="line">Total body sent:        374000</span><br><span class="line">HTML transferred:       58000 bytes</span><br><span class="line">Requests per second:    6239.74 [#/sec] (mean)</span><br><span class="line">Time per request:       80.131 [ms] (mean)</span><br><span class="line">Time per request:       0.160 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          1078.55 [Kbytes/sec] received</span><br><span class="line">                        1139.48 kb/s sent</span><br><span class="line">                        2218.03 kb/s total</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:       10   22   5.0     21      35</span><br><span class="line">Processing:     6   33  11.3     30      74</span><br><span class="line">Waiting:        4   25  10.1     24      68</span><br><span class="line">Total:         31   54  11.1     54      98</span><br></pre></td></tr></table></figure><h3 id="goim"><a href="#goim" class="headerlink" title="goim"></a>goim</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Document Path:          /goim/push/mids?mids=123&amp;operation=1000</span><br><span class="line">Document Length:        23 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      500</span><br><span class="line">Time taken for tests:   0.372 seconds</span><br><span class="line">Complete requests:      2000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      292000 bytes</span><br><span class="line">Total body sent:        356000</span><br><span class="line">HTML transferred:       46000 bytes</span><br><span class="line">Requests per second:    5377.91 [#/sec] (mean)</span><br><span class="line">Time per request:       92.973 [ms] (mean)</span><br><span class="line">Time per request:       0.186 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          766.77 [Kbytes/sec] received</span><br><span class="line">                        934.83 kb/s sent</span><br><span class="line">                        1701.60 kb/s total</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0   14  11.8     11      46</span><br><span class="line">Processing:    17   65  27.7     62     149</span><br><span class="line">Waiting:       16   59  24.1     57     136</span><br><span class="line">Total:         31   79  22.0     75     162</span><br></pre></td></tr></table></figure><h2 id="Concurrent-500-Number-5000"><a href="#Concurrent-500-Number-5000" class="headerlink" title="@Concurrent:500 @Number:5000"></a>@Concurrent:500 @Number:5000</h2><blockquote><p>5000的请求下 <code>im-cloud</code>高达6100qps  </p></blockquote><h3 id="im-cloud-1"><a href="#im-cloud-1" class="headerlink" title="im-cloud"></a>im-cloud</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        swoole-http-server</span><br><span class="line">Server Hostname:        127.0.0.1</span><br><span class="line">Server Port:            9600</span><br><span class="line">Document Path:          /im/push/mids?mids=123&amp;operation=9&amp;msg=push_mids</span><br><span class="line">Document Length:        29 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      500</span><br><span class="line">Time taken for tests:   0.822 seconds</span><br><span class="line">Complete requests:      5000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      885000 bytes</span><br><span class="line">Total body sent:        935000</span><br><span class="line">HTML transferred:       145000 bytes</span><br><span class="line">Requests per second:    6082.98 [#/sec] (mean)</span><br><span class="line">Time per request:       82.196 [ms] (mean)</span><br><span class="line">Time per request:       0.164 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          1051.45 [Kbytes/sec] received</span><br><span class="line">                        1110.86 kb/s sent</span><br><span class="line">                        2162.31 kb/s total</span><br></pre></td></tr></table></figure><h3 id="goim-1"><a href="#goim-1" class="headerlink" title="goim"></a>goim</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Document Path:          /goim/push/mids?mids=123&amp;operation=1000</span><br><span class="line">Document Length:        23 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      500</span><br><span class="line">Time taken for tests:   0.907 seconds</span><br><span class="line">Complete requests:      5000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      730000 bytes</span><br><span class="line">Total body sent:        890000</span><br><span class="line">HTML transferred:       115000 bytes</span><br><span class="line">Requests per second:    5514.84 [#/sec] (mean)</span><br><span class="line">Time per request:       90.664 [ms] (mean)</span><br><span class="line">Time per request:       0.181 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          786.30 [Kbytes/sec] received</span><br><span class="line">                        958.63 kb/s sent</span><br><span class="line">                        1744.93 kb/s total</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0   18  13.4     16      54</span><br><span class="line">Processing:    20   64  25.0     63     143</span><br><span class="line">Waiting:       17   55  20.5     54     117</span><br><span class="line">Total:         35   82  21.3     80     161</span><br></pre></td></tr></table></figure><h2 id="Concurrent-500-Number-20000"><a href="#Concurrent-500-Number-20000" class="headerlink" title="@Concurrent:500 @Number:20000"></a>@Concurrent:500 @Number:20000</h2><blockquote><p>请求20000 并发500 </p></blockquote><h3 id="goim-2"><a href="#goim-2" class="headerlink" title="goim"></a>goim</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Document Path:          /goim/push/mids?mids=123&amp;operation=1000</span><br><span class="line">Document Length:        23 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      500</span><br><span class="line">Time taken for tests:   3.393 seconds</span><br><span class="line">Complete requests:      20000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      2920000 bytes</span><br><span class="line">Total body sent:        3560000</span><br><span class="line">HTML transferred:       460000 bytes</span><br><span class="line">Requests per second:    5894.30 [#/sec] (mean)</span><br><span class="line">Time per request:       84.828 [ms] (mean)</span><br><span class="line">Time per request:       0.170 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          840.40 [Kbytes/sec] received</span><br><span class="line">                        1024.60 kb/s sent</span><br><span class="line">                        1864.99 kb/s total</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0   30 129.4     10    1025</span><br><span class="line">Processing:    10   50  19.2     47     128</span><br><span class="line">Waiting:        6   42  16.1     40     125</span><br><span class="line">Total:         16   80 131.8     60    1100</span><br></pre></td></tr></table></figure><h3 id="im-cloud-2"><a href="#im-cloud-2" class="headerlink" title="im-cloud"></a>im-cloud</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        swoole-http-server</span><br><span class="line">Server Hostname:        127.0.0.1</span><br><span class="line">Server Port:            9600</span><br><span class="line">Document Path:          /im/push/mids?mids=123&amp;operation=9&amp;msg=push_mids</span><br><span class="line">Document Length:        29 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      500</span><br><span class="line">Time taken for tests:   5.242 seconds</span><br><span class="line">Complete requests:      20000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      3540000 bytes</span><br><span class="line">Total body sent:        3740000</span><br><span class="line">HTML transferred:       580000 bytes</span><br><span class="line">Requests per second:    3815.33 [#/sec] (mean)</span><br><span class="line">Time per request:       131.050 [ms] (mean)</span><br><span class="line">Time per request:       0.262 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          659.49 [Kbytes/sec] received</span><br><span class="line">                        696.75 kb/s sent</span><br><span class="line">                        1356.23 kb/s total</span><br></pre></td></tr></table></figure><h2 id="Concurrent-1000-Number-20000"><a href="#Concurrent-1000-Number-20000" class="headerlink" title="@Concurrent:1000 @Number:20000"></a>@Concurrent:1000 @Number:20000</h2><blockquote><p>请求20000 并发1000</p></blockquote><h3 id="goim-3"><a href="#goim-3" class="headerlink" title="goim"></a>goim</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Document Path:          /goim/push/mids?mids=123&amp;operation=1000</span><br><span class="line">Document Length:        23 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      1000</span><br><span class="line">Time taken for tests:   3.361 seconds</span><br><span class="line">Complete requests:      20000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      2920000 bytes</span><br><span class="line">Total body sent:        3560000</span><br><span class="line">HTML transferred:       460000 bytes</span><br><span class="line">Requests per second:    5950.20 [#/sec] (mean)</span><br><span class="line">Time per request:       168.061 [ms] (mean)</span><br><span class="line">Time per request:       0.168 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          848.37 [Kbytes/sec] received</span><br><span class="line">                        1034.31 kb/s sent</span><br><span class="line">                        1882.68 kb/s total</span><br></pre></td></tr></table></figure><h3 id="im-cloud-3"><a href="#im-cloud-3" class="headerlink" title="im-cloud"></a>im-cloud</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        swoole-http-server</span><br><span class="line">Server Hostname:        127.0.0.1</span><br><span class="line">Server Port:            9600</span><br><span class="line"></span><br><span class="line">Document Path:          /im/push/mids?mids=123&amp;operation=9&amp;msg=push_mids</span><br><span class="line">Document Length:        29 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      500</span><br><span class="line">Time taken for tests:   3.988 seconds</span><br><span class="line">Complete requests:      20000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      3540000 bytes</span><br><span class="line">Total body sent:        3740000</span><br><span class="line">HTML transferred:       580000 bytes</span><br><span class="line">Requests per second:    5014.66 [#/sec] (mean)</span><br><span class="line">Time per request:       99.708 [ms] (mean)</span><br><span class="line">Time per request:       0.199 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          866.79 [Kbytes/sec] received</span><br><span class="line">                        915.76 kb/s sent</span><br><span class="line">                        1782.56 kb/s total</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;im-cloud-lt-gt-goim-分布式中间件并发压测对比&quot;&gt;&lt;a href=&quot;#im-cloud-lt-gt-goim-分布式中间件并发压测对比&quot; class=&quot;headerlink&quot; title=&quot;im-cloud &amp;lt;&amp;gt; goim 分布式中间
      
    
    </summary>
    
      <category term="im-cloud" scheme="http://blog.huido.site/categories/im-cloud/"/>
    
      <category term="1.前言" scheme="http://blog.huido.site/categories/im-cloud/1-%E5%89%8D%E8%A8%80/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="rabbitmq" scheme="http://blog.huido.site/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>cloud节点实现</title>
    <link href="http://blog.huido.site/wiki/im-cloud/2.%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/3.cloud%E8%8A%82%E7%82%B9/"/>
    <id>http://blog.huido.site/wiki/im-cloud/2.底层实现/3.cloud节点/</id>
    <published>2017-10-25T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="im-cloud分布式中间件分析-cloud节点实现"><a href="#im-cloud分布式中间件分析-cloud节点实现" class="headerlink" title="im-cloud分布式中间件分析-cloud节点实现"></a>im-cloud分布式中间件分析-cloud节点实现</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><blockquote><p>cloud 节点对外提供<code>websocket</code>、<code>tcp</code> client 注册。并维护每个连接对应的客户端信息。作为Grpc server，接受grpc推送数据，并推送到client端</p><ul><li>数据流程图<br><img src="/images/im-cloud/im-cloud-cloud.png" alt=""></li></ul></blockquote><h2 id="2-Grpc-server"><a href="#2-Grpc-server" class="headerlink" title="2.@Grpc server"></a>2.@Grpc server</h2><blockquote><p>grpc server 基于swoole 的<code>http2</code>协议，然后通过config/router.php 配置项注册路由既可以使用如rest模式下的交互流程</p></blockquote><h3 id="grpc-路由注册"><a href="#grpc-路由注册" class="headerlink" title="grpc 路由注册"></a>grpc 路由注册</h3><blockquote><p>配置文件 <code>config/router.php</code><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//Grpc server router</span></span><br><span class="line">HttpRouter::post(<span class="string">'/im.cloud.Cloud/Ping'</span>, <span class="string">'/Grpc/Cloud/ping'</span>);</span><br><span class="line">HttpRouter::post(<span class="string">'/im.cloud.Cloud/Close'</span>, <span class="string">'/Grpc/Cloud/close'</span>);</span><br><span class="line">HttpRouter::post(<span class="string">'/im.cloud.Cloud/PushMsg'</span>, <span class="string">'/Grpc/Cloud/pushMsg'</span>);</span><br><span class="line">HttpRouter::post(<span class="string">'/im.cloud.Cloud/Broadcast'</span>, <span class="string">'/Grpc/Cloud/broadcast'</span>);</span><br><span class="line">HttpRouter::post(<span class="string">'/im.cloud.Cloud/Rooms'</span>, <span class="string">'/Grpc/Cloud/rooms'</span>);</span><br></pre></td></tr></table></figure></p></blockquote><p>和rest 路由一样只需要注册路由到对应的方法即可，当使用grpc-client进行请求时，就能分发到最远的控制器去，</p><h3 id="grpc-参数解析"><a href="#grpc-参数解析" class="headerlink" title="grpc 参数解析"></a>grpc 参数解析</h3><blockquote><p>当接收到请求后，可以根据协程上下文获取当前连接的请求参数，<code>grpc</code>传输的协议是二进制，所以不能通过get，post方法直接获得对应的参数，需要采用grpc提供的方法进行解包<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Grpc</span>\<span class="title">Parser</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Core</span>\<span class="title">Context</span>\<span class="title">Context</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">pushMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $rawbody = Context::get()-&gt;getRequest()-&gt;getRawBody();</span><br><span class="line">    <span class="comment">/** <span class="doctag">@var</span> PushMsgReq $pushMsgReq */</span></span><br><span class="line">    $pushMsgReq = Parser::deserializeMessage(</span><br><span class="line">            [PushMsgReq::class,<span class="keyword">null</span>],</span><br><span class="line">            $rawbody</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>获取请求参数可以通过协程上下文获取<ul><li><code>Context::get()-&gt;getRequest()-&gt;getRawBody();</code></li><li><code>request()-&gt;getRawBody();</code></li></ul></li><li><code>Grpc\Parser</code> 方法使用的是 swoole\grpc-client 组件包提供的方法，使用swoole对原生grpc 进行了封装<h2 id="3-websocket-server"><a href="#3-websocket-server" class="headerlink" title="3.@websocket server"></a>3.@websocket server</h2><blockquote><p>基于websocket 协议注册到cloud节点，cloud 进行认证，通过grpc将注册信息传递到logic统一管理，认证成功后cloud节点将保存改连接的基础信息</p></blockquote><h3 id="握手阶段"><a href="#握手阶段" class="headerlink" title="握手阶段"></a>握手阶段</h3><blockquote><p>命名空间：<code>App/Websocket/HandshakeListener.class</code></p></blockquote></li></ul><p>该事件为swoole 监听事件，所以需要注册监听回调函数,配置文件为<code>config/event.php</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use \Core\Swoole\SwooleEvent;</span><br><span class="line">use \App\Websocket\HandshakeListener;</span><br><span class="line"></span><br><span class="line">return [</span><br><span class="line">    //websocket握手事件</span><br><span class="line">    SwooleEvent::HANDSHAKE        =&gt; new HandshakeListener(),</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>接下来是握手流程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * token check &apos;&#123;&quot;mid&quot;:123, &quot;room_id&quot;:&quot;live://1000&quot;, &quot;platform&quot;:&quot;web&quot;, &quot;accepts&quot;:[1000,1001,1002]&#125;&apos;</span><br><span class="line"> * @param Request $request</span><br><span class="line"> * @param Response $response</span><br><span class="line"> * @return bool</span><br><span class="line"> */</span><br><span class="line">public function onHandshake(Request $request, Response $response): bool</span><br><span class="line">&#123;</span><br><span class="line">    $httpRequest = HttpRequest::new($request);</span><br><span class="line">    //握手失败</span><br><span class="line">    if($httpRequest-&gt;getUriPath() != self::upgradeUrl)&#123;</span><br><span class="line">        $response-&gt;end();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // websocket握手连接算法验证</span><br><span class="line">    $secWebSocketKey = $request-&gt;header[&apos;sec-websocket-key&apos;];</span><br><span class="line">    $patten = &apos;#^[+/0-9A-Za-z]&#123;21&#125;[AQgw]==$#&apos;;</span><br><span class="line">    if (0 === preg_match($patten, $secWebSocketKey) || 16 !== strlen(base64_decode($secWebSocketKey))) &#123;</span><br><span class="line">        $response-&gt;end();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    $key = base64_encode(sha1(</span><br><span class="line">        $request-&gt;header[&apos;sec-websocket-key&apos;] . &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos;,</span><br><span class="line">        true</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    $headers = [</span><br><span class="line">        &apos;Upgrade&apos; =&gt; &apos;websocket&apos;,</span><br><span class="line">        &apos;Connection&apos; =&gt; &apos;Upgrade&apos;,</span><br><span class="line">        &apos;Sec-WebSocket-Accept&apos; =&gt; $key,</span><br><span class="line">        &apos;Sec-WebSocket-Version&apos; =&gt; &apos;13&apos;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    // WebSocket connection to &apos;ws://127.0.0.1:9502/&apos;</span><br><span class="line">    // failed: Error during WebSocket handshake:</span><br><span class="line">    // Response must not include &apos;Sec-WebSocket-Protocol&apos; header if not present in request: websocket</span><br><span class="line">    if (isset($request-&gt;header[&apos;sec-websocket-protocol&apos;])) &#123;</span><br><span class="line">        $headers[&apos;Sec-WebSocket-Protocol&apos;] = $request-&gt;header[&apos;sec-websocket-protocol&apos;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foreach ($headers as $key =&gt; $val) &#123;</span><br><span class="line">        $response-&gt;header($key, $val);</span><br><span class="line">    &#125;</span><br><span class="line">    $response-&gt;status(101);</span><br><span class="line">    $response-&gt;end();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法在握手阶段对于http请求进行校验，如果路径不为 ‘/sub’ 则认证失败关闭连接，成功后校验websocekt协议并升级为websocket，</p><h3 id="主事件处理"><a href="#主事件处理" class="headerlink" title="主事件处理"></a>主事件处理</h3><blockquote><p>同样需要注册websocket的onmessage事件 配置文件:<code>config/envent.php</code></p></blockquote><h4 id="step1-解包"><a href="#step1-解包" class="headerlink" title="@step1 解包"></a>@step1 解包</h4><blockquote><p>使用 <code>App\Packet\Packet::class</code> 进行解包，<br>通讯协议为二进制传输，会有单独一章分析im-cloud通讯协议的设计</p></blockquote><h4 id="step2-处理分发-注册"><a href="#step2-处理分发-注册" class="headerlink" title="@step2 处理分发(注册)"></a>@step2 处理分发(注册)</h4><blockquote><p>根据协议，如果为注册请求，则进行注册流程，心跳则进行心跳流程<br><code>im-cloud暂时不支持双向推送，也就是该连接不支持接受推送消息，推送请走logic节点push</code></p></blockquote><h3 id="step3-注册"><a href="#step3-注册" class="headerlink" title="@step3 注册"></a>@step3 注册</h3><ul><li>1.进行auth参数校验</li><li><p>2.通过grpc 注册到logic节点</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$server = LogicClient::getLogicClient();</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($server))</span><br><span class="line">    <span class="keyword">throw</span>  <span class="keyword">new</span> \<span class="keyword">Exception</span>(<span class="string">"not find any logic node"</span>);</span><br><span class="line">$connectReq = <span class="keyword">new</span> ConnectReq();</span><br><span class="line"><span class="comment">/** <span class="doctag">@var</span> \Im\Logic\LogicClient $rpcClient */</span></span><br><span class="line">$rpcClient  = <span class="keyword">null</span>;</span><br><span class="line">$serverId = env(<span class="string">"APP_HOST"</span>,<span class="string">"127.0.0.1"</span>).<span class="string">":"</span>.env(<span class="string">"GRPC_PORT"</span>,<span class="number">9500</span>);</span><br><span class="line">$connectReq-&gt;setServer($serverId);</span><br><span class="line">$connectReq-&gt;setCookie(<span class="string">""</span>);</span><br><span class="line">$connectReq-&gt;setToken(json_encode($data));</span><br><span class="line"><span class="comment">/** <span class="doctag">@var</span> ConnectReply $rpy */</span></span><br><span class="line">$rpy = GrpcLogicClient::Connect($server,$connectReq)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></li><li><p>3.注册成功后将当前用户信息 写入bucket进程，独立维护所有的用户信息和连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[$mid,$key,$roomId,$accepts,$heartbeat] = $this-&gt;registerLogic($body);</span><br><span class="line">/** @var Task $task */</span><br><span class="line">\bean(Task::class)-&gt;deliver(Bucket::class,&quot;put&quot;,[$roomId,$key,$fd]);</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-tcp-server"><a href="#4-tcp-server" class="headerlink" title="4.@tcp server"></a>4.@tcp server</h2><blockquote><p>tcp 处理流程和websocket大致相似，走同样的流程,只是监听对应的api有些区别</p></blockquote><h2 id="5-自定义进程"><a href="#5-自定义进程" class="headerlink" title="5.自定义进程"></a>5.自定义进程</h2><p>cloud节点 默认启动了两个自定义进程伴随swoole启动而启动</p><h3 id="discoveryProcess-注册发现进程"><a href="#discoveryProcess-注册发现进程" class="headerlink" title="discoveryProcess 注册发现进程"></a>discoveryProcess 注册发现进程</h3><blockquote><p>该进程 在启动时注册到 注册中心(默认consul，可以扩展其他的注册中心),然后进行事件轮训，获取健康状态的实例节点</p><ul><li>配置文件<ul><li><code>config/process.php</code> 注册进程到进程管理器</li><li><code>config/consul.php</code>  配置发现中心的配置</li></ul></li><li>获取到实例节点后 更新swoole所有的worker进程里的实例节点信息使用<code>sendMessage()</code>进行进程间通信<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自定义子进程 执行入口</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> Process $process</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">(Process $process)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    provider()-&gt;select()-&gt;registerService();</span><br><span class="line">    $config = config(<span class="string">"discovery"</span>);</span><br><span class="line">    $discovery = $config[<span class="string">"consul"</span>][<span class="string">"discovery"</span>][<span class="string">"name"</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        $services = provider()-&gt;select()-&gt;getServiceList($discovery);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">empty</span>($services))&#123;</span><br><span class="line">            CLog::error(<span class="string">"not find any instance node:$discovery"</span>);</span><br><span class="line">            <span class="keyword">goto</span> SLEEP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; (int)env(<span class="string">"WORKER_NUM"</span>,<span class="number">4</span>);$i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将可以用的服务同步到所有的worker进程</span></span><br><span class="line">            Cloud::server()-&gt;getSwooleServer()-&gt;sendMessage($services,$i);</span><br><span class="line">        &#125;</span><br><span class="line">SLEEP:</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="bucketProcess-用户缓存池"><a href="#bucketProcess-用户缓存池" class="headerlink" title="bucketProcess    用户缓存池"></a>bucketProcess    用户缓存池</h3><blockquote><p>配置文件 <code>config/process.php</code> 注册该进程</p></blockquote><p>该进程两个任务:</p><ul><li><p>1 注册成功后缓存用户信息，管理用户连接</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//step 1</span></span><br><span class="line">[$mid,$key,$roomId,$accepts,$heartbeat] = <span class="keyword">$this</span>-&gt;registerLogic($body);</span><br><span class="line"><span class="comment">//step 2</span></span><br><span class="line"><span class="comment">/** <span class="doctag">@var</span> Task $task */</span></span><br><span class="line">\bean(Task::class)-&gt;deliver(Bucket::class,<span class="string">"put"</span>,[$roomId,$key,$fd]);</span><br><span class="line">使用deliver进程间通信，发送到bucketProcess进程处理</span><br></pre></td></tr></table></figure></li><li><p>2.作为主要的推送进程</p><blockquote><p>当cloud节点grpcserver 接收到推送请求，则创建一个协程写入bucketprocess进程，当前进程消费管道里的数据，每个数据创建一个协程，处理推送问题</p></blockquote></li><li><p>3.使用自定义进程管理用户信息的选择</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">出版采用的redis缓存用户信息，在实际压测的时候发现即使是redis缓存还是会影响并发处理。</span><br><span class="line">导致慢了4-5倍，而采用自定义进程处理的好处有如下两点，多进程下对数据不需要加锁。针对每个请求单独创建一个协程反而效率要高些</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-监听事件，生命周期管理"><a href="#5-监听事件，生命周期管理" class="headerlink" title="5.监听事件，生命周期管理"></a>5.监听事件，生命周期管理</h2><blockquote><p>swoole 相关生命周期执行管理都依赖监听事件，例如 <code>进程启动</code> <code>请求事件</code> <code>握手连接</code> <code>关闭连接</code> 等等。。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set event to base swoole</span></span><br><span class="line"><span class="comment"> * 给swoole 设置基础的监听事件，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">use</span> \<span class="title">Core</span>\<span class="title">Swoole</span>\<span class="title">SwooleEvent</span>;</span><br><span class="line"><span class="keyword">use</span> \<span class="title">App</span>\<span class="title">Event</span>\<span class="title">PipeMessageListener</span>;</span><br><span class="line"><span class="keyword">use</span> \<span class="title">App</span>\<span class="title">Event</span>\<span class="title">WorkerStopListener</span>;</span><br><span class="line"><span class="keyword">use</span> \<span class="title">App</span>\<span class="title">Event</span>\<span class="title">ShutdownListener</span>;</span><br><span class="line"><span class="keyword">use</span> \<span class="title">App</span>\<span class="title">Websocket</span>\<span class="title">MessageListener</span>;</span><br><span class="line"><span class="keyword">use</span> \<span class="title">App</span>\<span class="title">Websocket</span>\<span class="title">HandshakeListener</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Tcp</span>\<span class="title">ReceiveListener</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Event</span>\<span class="title">OnCloseListener</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Event</span>\<span class="title">WorkerStartListener</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="comment">//监听onpipmessage事件</span></span><br><span class="line">    SwooleEvent::PIPE_MESSAGE =&gt; <span class="keyword">new</span> PipeMessageListener(),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//监听进程启动事件</span></span><br><span class="line">    SwooleEvent::WORKER_START =&gt; <span class="keyword">new</span> WorkerStartListener(),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//监听进程关闭事件</span></span><br><span class="line">    SwooleEvent::WORKER_STOP  =&gt; <span class="keyword">new</span> WorkerStopListener(),</span><br><span class="line">    SwooleEvent::SHUTDOWN     =&gt; <span class="keyword">new</span> ShutdownListener(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听tcp事件</span></span><br><span class="line">    SwooleEvent::RECEIVE      =&gt; <span class="keyword">new</span> ReceiveListener(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听websocket 事件</span></span><br><span class="line">    SwooleEvent::MESSAGE      =&gt; <span class="keyword">new</span> MessageListener(),</span><br><span class="line">    <span class="comment">//websocket握手事件</span></span><br><span class="line">    SwooleEvent::HANDSHAKE    =&gt; <span class="keyword">new</span> HandshakeListener(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//server监听关闭连接事件然后grpc通知logic销毁连接信息</span></span><br><span class="line">    SwooleEvent::CLOSE        =&gt; <span class="keyword">new</span> OnCloseListener(),</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;im-cloud分布式中间件分析-cloud节点实现&quot;&gt;&lt;a href=&quot;#im-cloud分布式中间件分析-cloud节点实现&quot; class=&quot;headerlink&quot; title=&quot;im-cloud分布式中间件分析-cloud节点实现&quot;&gt;&lt;/a&gt;im-cloud
      
    
    </summary>
    
      <category term="im-cloud" scheme="http://blog.huido.site/categories/im-cloud/"/>
    
      <category term="2.底层实现" scheme="http://blog.huido.site/categories/im-cloud/2-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="rabbitmq" scheme="http://blog.huido.site/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>job节点实现</title>
    <link href="http://blog.huido.site/wiki/im-cloud/2.%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/4.job%E8%8A%82%E7%82%B9/"/>
    <id>http://blog.huido.site/wiki/im-cloud/2.底层实现/4.job节点/</id>
    <published>2017-10-25T13:28:59.000Z</published>
    <updated>2019-10-26T15:40:12.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="im-cloud分布式中间件分析-job节点实现"><a href="#im-cloud分布式中间件分析-job节点实现" class="headerlink" title="im-cloud分布式中间件分析-job节点实现"></a>im-cloud分布式中间件分析-job节点实现</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><blockquote><p>job 节点 作为消费端，消费logic生产的数据，然后通过grpc推送至cloud节点，cloud点真正处理客户端数据，job节点默认多进程消费启动4个worker进程，以及默认10个grpc连接池</p><ul><li>数据流程图<br><img src="/images/im-cloud/im-cloud-job节点.png" alt=""></li></ul></blockquote><h2 id="2-Consumer-消费中心"><a href="#2-Consumer-消费中心" class="headerlink" title="2.@Consumer 消费中心"></a>2.@Consumer 消费中心</h2><blockquote><p>默认启动4个worker进程消费logic请求，耗时处理投放至task进程处理，并转发至cloud节点</p></blockquote><h3 id="监听worker启动事件"><a href="#监听worker启动事件" class="headerlink" title="监听worker启动事件"></a>监听worker启动事件</h3><p>需要在<code>config/queue.php</code> ,<code>config/event.php</code> 注册相应的事件和相关配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">use App\Consumer\Consumer;</span><br><span class="line">use Core\App;</span><br><span class="line">use Core\Swoole\WorkerStartInterface;</span><br><span class="line">use Swoole\Server as SwooleServer;</span><br><span class="line"></span><br><span class="line">class WorkerStartListener implements WorkerStartInterface</span><br><span class="line">&#123;</span><br><span class="line">    const INIT_LOGIC = 1;</span><br><span class="line"></span><br><span class="line">    public function onWorkerStart(SwooleServer $server, int $workerId): void</span><br><span class="line">    &#123;</span><br><span class="line">        if(App::isWorkerStatus())&#123;</span><br><span class="line">            //启动的n个 worker进程 分别作为消费者进程消费，每个进程会直接阻塞直到消费到数据</span><br><span class="line">            consumer()-&gt;consume(new Consumer());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="消费主流程"><a href="#消费主流程" class="headerlink" title="消费主流程"></a>消费主流程</h3><ul><li>1.为每个消费数据请求建立一个协程，处理相关数据</li><li><p>2.将每个数据投递至worker进程进行真正的grpc与cloud推送请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Co::create(function()use($data)&#123;</span><br><span class="line">    if(empty(CloudClient::$table-&gt;getAllInstance()))&#123;</span><br><span class="line">        Log::error(&quot;cancle task deliver discovery cloud node is empty&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Task::deliver(Job::class,&quot;push&quot;,[$data]);</span><br><span class="line">&#125;,false);</span><br><span class="line">return Result::ACK;</span><br></pre></td></tr></table></figure></li><li><p>3.通过以上做法能加快并发是消费速度，task进程也进行协程处理，增加并行处理能力，如果task进程阻塞也会造成task任务投递阻塞，所以在worker进程也需要加一个协程处理</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;im-cloud分布式中间件分析-job节点实现&quot;&gt;&lt;a href=&quot;#im-cloud分布式中间件分析-job节点实现&quot; class=&quot;headerlink&quot; title=&quot;im-cloud分布式中间件分析-job节点实现&quot;&gt;&lt;/a&gt;im-cloud分布式中间件
      
    
    </summary>
    
      <category term="im-cloud" scheme="http://blog.huido.site/categories/im-cloud/"/>
    
      <category term="2.底层实现" scheme="http://blog.huido.site/categories/im-cloud/2-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="php" scheme="http://blog.huido.site/tags/php/"/>
    
      <category term="swoole" scheme="http://blog.huido.site/tags/swoole/"/>
    
      <category term="rabbitmq" scheme="http://blog.huido.site/tags/rabbitmq/"/>
    
  </entry>
  
</feed>
